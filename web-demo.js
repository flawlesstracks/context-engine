#!/usr/bin/env node

const fs = require('fs');
const crypto = require('crypto');
const path = require('path');
const express = require('express');
const Anthropic = require('@anthropic-ai/sdk').default;
const { merge, normalizeRelationshipType } = require('./merge-engine');
const multer = require('multer');
const cookieParser = require('cookie-parser');
const { readEntity, writeEntity, listEntities, listEntitiesByType, getNextCounter, loadConnectedObjects, deleteEntity, getSelfEntityId, isSelfEntity } = require('./src/graph-ops');
const { ingestPipeline } = require('./src/ingest-pipeline');
const { stageAndScoreExtraction, resolveCluster, getReviewQueue, getBundledReviewQueue, readCluster, resolveConflict } = require('./src/signalStaging');
const { normalizeFileToText } = require('./src/parsers/normalize');
const { buildLinkedInPrompt, linkedInResponseToEntity, linkedInExperienceToOrgs } = require('./src/parsers/linkedin');
const { mapContactRows } = require('./src/parsers/contacts');
const { scrapeLinkedInProfile, transformScrapingDogProfile } = require('./src/scrapingdog');
const { analyzeEntityHealth, getRelationshipTier, getTierInfo } = require('./src/health-analyzer');
const { parse: universalParse } = require('./universal-parser');
const { query: queryEngine, getSelfEntity, clearSelfEntityCache } = require('./query-engine');
const { loadSpokes, createSpoke, getSpoke, updateSpoke, setCenteredEntity, deleteSpoke, listSpokesWithCounts, migrateEntitiesToSpokes, findSpokeByShareToken } = require('./src/spoke-ops');
const { loadTemplates, getTemplate, saveTemplates, saveTemplate, deleteTemplate, bumpVersion, buildDisplayNameMap, generateRequestEmail, analyzeGaps, FIELD_ALIASES, TYPE_ALIASES } = require('./src/gap-analysis');
const { createConnection, getConnection, getConnectionDecrypted, updateConnection, deleteConnection: deleteConn, listConnections } = require('./src/connector-ops');
const { getRegisteredProviders, getConnectorClass } = require('./src/connectors/base-connector');
const { buildAuthorizeUrl, validateState, exchangeCodeForTokens, OAUTH_STATE_COOKIE } = require('./src/connectors/oauth-handler');
const auth = require('./src/auth');
const drive = require('./src/drive');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

require('dotenv').config({ path: path.resolve(__dirname, '.env') });

const app = express();
app.set('trust proxy', 1); // MUST be first — Render terminates HTTPS at load balancer
app.set('etag', false);

// --- Security headers ---
app.use(helmet({
  contentSecurityPolicy: false,  // inline scripts in HTML templates
  crossOriginEmbedderPolicy: false,
}));

app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Content-Type, X-Context-API-Key, Authorization');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE, OPTIONS');
  if (req.method === 'OPTIONS') return res.sendStatus(200);
  next();
});
app.use(express.json({ limit: '200mb' }));
app.use(cookieParser());

// --- Rate limiting ---
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, please try again later.' },
});

const shareLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 10,
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many share requests, please try again later.' },
});

const sharedViewLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 30,
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many requests. Please try again in a minute.',
});

app.use('/api/', apiLimiter);

// --- Shared extraction logic ---

const PERSON_SCHEMA = `{
  "entity_type": "person",
  "name": { "full": "", "preferred": "", "aliases": [] },
  "summary": "2-3 sentence synthesis",
  "attributes": { "role": "", "location": "", "expertise": [] },
  "relationships": [{ "name": "", "relationship": "", "context": "" }],
  "values": [],
  "communication_style": { "tone": "", "preferences": [] },
  "active_projects": [{ "name": "", "status": "", "description": "" }],
  "key_facts": [],
  "metadata": { "source": "", "generated": "", "version": "1.0" }
}`;

const BUSINESS_SCHEMA = `{
  "entity_type": "business",
  "name": { "legal": "", "common": "", "aliases": [] },
  "summary": "2-3 sentence synthesis",
  "industry": "",
  "products_services": [],
  "key_people": [{ "name": "", "role": "", "context": "" }],
  "values": [],
  "customers": { "target": "", "segments": [] },
  "competitive_position": "",
  "key_facts": [],
  "metadata": { "source": "", "generated": "", "version": "1.0" }
}`;

const INSTITUTION_SCHEMA = `{
  "entity_type": "institution",
  "name": { "legal": "", "common": "", "aliases": [] },
  "summary": "2-3 sentence synthesis",
  "institution_type": "university|school|government|hospital|public_service",
  "key_people": [{ "name": "", "role": "", "context": "" }],
  "values": [],
  "key_facts": [],
  "metadata": { "source": "", "generated": "", "version": "1.0" }
}`;

function buildPrompt(type, text) {
  const schema = type === 'person' ? PERSON_SCHEMA : (type === 'institution' ? INSTITUTION_SCHEMA : BUSINESS_SCHEMA);
  return `You are a structured data extraction engine. Given unstructured text about a ${type}, extract all relevant information into the following JSON structure. Fill in every field you can from the text. Leave fields as empty strings, empty arrays, or reasonable defaults if the information is not present. Do not invent information that is not in the text.

Output ONLY valid JSON, no markdown fences, no commentary.

JSON schema:
${schema}

Important:
- metadata.source should be "web-demo"
- metadata.generated should be the current timestamp in ISO 8601 format: "${new Date().toISOString()}"
- metadata.version should be "1.0"
- summary should be a 2-3 sentence synthesis of the most important information

Text to extract from:
---
${text}
---`;
}

async function callClaude(prompt) {
  const client = new Anthropic();
  const message = await client.messages.create({
    model: 'claude-sonnet-4-5-20250929',
    max_tokens: 4096,
    messages: [{ role: 'user', content: prompt }],
  });
  return message.content[0].text;
}

// --- Web UI extract endpoint (v2, no auth) ---

app.post('/extract', async (req, res) => {
  const { text, type } = req.body;

  if (!text || !type) {
    return res.status(400).json({ error: 'Missing text or type' });
  }
  if (!['person', 'business', 'institution'].includes(type)) {
    return res.status(400).json({ error: 'Type must be person, business, or institution' });
  }

  try {
    const { execFile } = require('child_process');
    const tmpIn = path.join(__dirname, 'watch-folder', 'output', `_web_input_${Date.now()}.txt`);
    const tmpOut = path.join(__dirname, 'watch-folder', 'output', `_web_output_${Date.now()}.json`);

    fs.writeFileSync(tmpIn, text);

    await new Promise((resolve, reject) => {
      execFile('node', [
        path.join(__dirname, 'context-engine.js'),
        '--input', tmpIn, '--output', tmpOut, '--type', type, '--schema-version', '2.0',
      ], {
        env: { ...process.env, PATH: `/opt/homebrew/bin:${process.env.PATH}` },
        timeout: 180000,
      }, (err) => err ? reject(err) : resolve());
    });

    const result = JSON.parse(fs.readFileSync(tmpOut, 'utf-8'));
    fs.unlinkSync(tmpIn);
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- Graph API ---

const IS_PRODUCTION = process.env.RENDER || process.env.NODE_ENV === 'production';
const LOCAL_GRAPH_DIR = path.join(__dirname, 'watch-folder', 'graph');
const CONFIG_PATH = path.join(__dirname, 'watch-folder', 'config.json');

// Resolve graph directory — try persistent disk candidates, fall back to local
let GRAPH_DIR = LOCAL_GRAPH_DIR;
let GRAPH_IS_PERSISTENT = false;
if (IS_PRODUCTION) {
  const candidates = [
    process.env.RENDER_DISK_PATH && path.join(process.env.RENDER_DISK_PATH, 'graph'),
    '/var/data/graph',
    '/data/graph',
  ].filter(Boolean);

  for (const candidate of candidates) {
    try {
      const parentDir = path.dirname(candidate);
      if (!fs.existsSync(parentDir)) continue;
      if (!fs.existsSync(candidate)) {
        fs.mkdirSync(candidate, { recursive: true });
      }
      // Test write access
      const testFile = path.join(candidate, '.write-test');
      fs.writeFileSync(testFile, '');
      fs.unlinkSync(testFile);

      // Seed from repo on first boot (root JSON files)
      const existing = fs.readdirSync(candidate).filter(f => f.endsWith('.json'));
      if (existing.length === 0) {
        const seedFiles = fs.readdirSync(LOCAL_GRAPH_DIR).filter(f => f.endsWith('.json'));
        for (const file of seedFiles) {
          fs.copyFileSync(path.join(LOCAL_GRAPH_DIR, file), path.join(candidate, file));
        }
        console.log(`  Seeded ${seedFiles.length} entity file(s) to ${candidate}`);
      }

      // Merge repo tenant config into persistent disk (repo is source of truth for api_keys)
      const persistentConfig = path.join(candidate, 'tenants.config.json');
      const localConfig = path.join(LOCAL_GRAPH_DIR, 'tenants.config.json');
      if (fs.existsSync(localConfig)) {
        const repoConfig = JSON.parse(fs.readFileSync(localConfig, 'utf-8'));
        let diskConfig = {};
        if (fs.existsSync(persistentConfig)) {
          try { diskConfig = JSON.parse(fs.readFileSync(persistentConfig, 'utf-8')); } catch {}
        }
        let updated = 0;
        for (const [id, tenant] of Object.entries(repoConfig)) {
          if (!diskConfig[id]) {
            diskConfig[id] = tenant;
            updated++;
          } else {
            // Merge: repo fields fill in gaps
            for (const [key, val] of Object.entries(tenant)) {
              if (!diskConfig[id][key]) {
                diskConfig[id][key] = val;
              }
            }
            // API key from repo always wins (so external consumers like GPTs can use known keys)
            if (tenant.api_key && diskConfig[id].api_key !== tenant.api_key) {
              diskConfig[id].api_key = tenant.api_key;
              updated++;
            }
          }
        }
        if (updated > 0 || !fs.existsSync(persistentConfig)) {
          fs.writeFileSync(persistentConfig, JSON.stringify(diskConfig, null, 2) + '\n');
          console.log(`  Merged tenants.config.json: ${updated} tenant(s) updated from repo`);
        }
      }

      // Sync tenant directories from repo if missing on persistent disk
      const localEntries = fs.readdirSync(LOCAL_GRAPH_DIR, { withFileTypes: true });
      for (const entry of localEntries) {
        if (entry.isDirectory() && entry.name.startsWith('tenant-')) {
          const destDir = path.join(candidate, entry.name);
          if (!fs.existsSync(destDir)) {
            fs.mkdirSync(destDir, { recursive: true });
            const srcDir = path.join(LOCAL_GRAPH_DIR, entry.name);
            const entityFiles = fs.readdirSync(srcDir);
            for (const ef of entityFiles) {
              fs.copyFileSync(path.join(srcDir, ef), path.join(destDir, ef));
            }
            console.log(`  Synced tenant dir ${entry.name} (${entityFiles.length} files) to persistent disk`);
          }
        }
      }
      GRAPH_DIR = candidate;
      GRAPH_IS_PERSISTENT = true;
      break;
    } catch {
      continue;
    }
  }
  if (!GRAPH_IS_PERSISTENT) {
    console.warn('  WARNING: No writable persistent disk found');
    console.warn('  Falling back to local graph: ' + LOCAL_GRAPH_DIR);
    console.warn('  Set RENDER_DISK_PATH env var to your disk mount path');
  }
}

function loadConfig() {
  return JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
}

function saveConfig(config) {
  fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2) + '\n');
}

// --- Tenant management ---

const TENANTS_CONFIG_PATH = path.join(GRAPH_DIR, 'tenants.config.json');
const TENANTS_STATE_PATH = path.join(GRAPH_DIR, 'tenants.state.json');

const STATE_FIELDS = new Set(['email', 'name', 'picture', 'last_login', 'refresh_token', 'access_token']);

function loadTenants() {
  let config = {};
  if (fs.existsSync(TENANTS_CONFIG_PATH)) {
    config = JSON.parse(fs.readFileSync(TENANTS_CONFIG_PATH, 'utf-8'));
  }
  let state = {};
  if (fs.existsSync(TENANTS_STATE_PATH)) {
    state = JSON.parse(fs.readFileSync(TENANTS_STATE_PATH, 'utf-8'));
  }
  // Merge state fields into config per tenant
  const merged = {};
  for (const [id, tenant] of Object.entries(config)) {
    merged[id] = { ...tenant, ...(state[id] || {}) };
  }
  return merged;
}

function saveTenants(tenants) {
  const config = {};
  const state = {};
  for (const [id, tenant] of Object.entries(tenants)) {
    config[id] = {};
    state[id] = {};
    for (const [key, val] of Object.entries(tenant)) {
      if (STATE_FIELDS.has(key)) {
        state[id][key] = val;
      } else {
        config[id][key] = val;
      }
    }
    // Only keep state entry if it has fields
    if (Object.keys(state[id]).length === 0) delete state[id];
  }
  fs.writeFileSync(TENANTS_CONFIG_PATH, JSON.stringify(config, null, 2) + '\n');
  fs.writeFileSync(TENANTS_STATE_PATH, JSON.stringify(state, null, 2) + '\n');
}

// --- Share helpers ---

function loadShares(tenantDir) {
  const sharesPath = path.join(tenantDir, 'shares.json');
  if (!fs.existsSync(sharesPath)) return [];
  return JSON.parse(fs.readFileSync(sharesPath, 'utf-8'));
}

function saveShares(tenantDir, shares) {
  fs.writeFileSync(path.join(tenantDir, 'shares.json'), JSON.stringify(shares, null, 2) + '\n');
}

// --- Google OAuth routes ---

auth.init({ graphDir: GRAPH_DIR, loadTenants, saveTenants });
app.use('/auth', auth.router);

// --- ChatGPT Ingest Helpers ---

function parseChatGPTExport(input) {
  let conversations;
  if (typeof input === 'string') {
    conversations = JSON.parse(input);
  } else if (Array.isArray(input)) {
    conversations = input;
  } else {
    throw new Error('Expected an array of conversations or a JSON string');
  }

  return conversations.map(conv => {
    const title = conv.title || 'Untitled';
    const createTime = conv.create_time
      ? new Date(conv.create_time * 1000).toISOString()
      : new Date().toISOString();
    const userMessages = [];

    if (conv.mapping) {
      const nodes = Object.values(conv.mapping);
      nodes.sort((a, b) => (a.message?.create_time || 0) - (b.message?.create_time || 0));
      for (const node of nodes) {
        const msg = node.message;
        if (!msg || !msg.author || msg.author.role !== 'user') continue;
        const parts = (msg.content?.parts || []);
        const text = parts.filter(p => typeof p === 'string').join('\n').trim();
        if (text) userMessages.push(text);
      }
    }

    return { title, createTime, userMessages };
  }).filter(c => c.userMessages.length > 0);
}

function chunkText(text, chunkSize, overlap) {
  chunkSize = chunkSize || 25000;
  overlap = overlap || 1000;
  if (text.length <= chunkSize) return [text];
  const chunks = [];
  let offset = 0;
  while (offset < text.length) {
    chunks.push(text.substring(offset, offset + chunkSize));
    offset += chunkSize - overlap;
  }
  return chunks;
}

function repairTruncatedJSON(raw) {
  // Try to recover a truncated {"entities": [...]} response
  // by finding the last complete object in the array
  const idx = raw.lastIndexOf('},');
  if (idx === -1) {
    // Try last complete object at end of array (no trailing comma)
    const idx2 = raw.lastIndexOf('}]');
    if (idx2 !== -1) return JSON.parse(raw.substring(0, idx2 + 2) + '}');
    return null;
  }
  const repaired = raw.substring(0, idx + 1) + ']}';
  return JSON.parse(repaired);
}

function safeParseExtraction(raw, label) {
  const cleaned = raw.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
  try {
    return JSON.parse(cleaned);
  } catch (e) {
    console.warn(`[${label}] JSON parse failed: ${e.message} — attempting repair`);
    try {
      const repaired = repairTruncatedJSON(cleaned);
      if (repaired && repaired.entities) {
        console.warn(`[${label}] Response truncated — recovered ${repaired.entities.length} entities from this chunk`);
        return repaired;
      }
    } catch (e2) {
      console.warn(`[${label}] JSON repair also failed: ${e2.message}`);
    }
    console.warn(`[${label}] Skipping chunk — no entities recovered`);
    return { entities: [] };
  }
}

// Resolve the primary user's full name from the graph directory
function getPrimaryUserName(graphDir) {
  try {
    const ents = listEntities(graphDir);
    let best = null;
    let maxConn = 0;
    for (const { data } of ents) {
      if ((data.entity || {}).entity_type === 'person') {
        const count = (data.connected_objects || []).length;
        if (count > maxConn) { maxConn = count; best = data; }
      }
    }
    if (best && best.entity && best.entity.name) {
      const n = best.entity.name;
      return n.full || n.preferred || '';
    }
  } catch (e) { /* ignore */ }
  return '';
}

function buildGenericTextPrompt(text, filename, chunkNum, totalChunks, primaryUserName) {
  const chunkLabel = totalChunks > 1 ? ` (chunk ${chunkNum} of ${totalChunks})` : '';
  const primaryBlock = primaryUserName ? `
PRIMARY USER CONTEXT:
The primary user of this system is ${primaryUserName}. Every person and organization you extract must be scored in relationship TO ${primaryUserName}.

RELATIONSHIP SCORING — PERSON ENTITIES:

For each PERSON entity, include a "relationship_dimensions" object AND a top-level "descriptor" field.

1. connection_type (required, enum)
   How is this person connected to ${primaryUserName}?
   "blood" — biological or legally adopted family
   "marriage" — connected through a marriage (current or former). Includes spouse, ex-spouse, in-law, step-relative.
   "chosen" — voluntary personal relationship (friend, mentor, mentee, confidant, surrogate family)
   "professional" — work or business relationship (colleague, manager, client, partner)
   "community" — shared context or proximity (classmate, neighbor, fellow member)

   TIEBREAKER RULE: When a relationship spans BOTH chosen AND professional (e.g., MBA classmate who became a business partner), pick whichever connection came FIRST chronologically. If they were friends before doing business together, connection_type = "chosen" and mention the business in the descriptor. DEFAULT TO "chosen" when ambiguous.

   SPOUSE RULE: If someone is identified as another person's wife/husband/spouse/partner, and that other person is NOT ${primaryUserName}, connection_type MUST be "marriage" with connected_through = the spouse. Marriage connection ALWAYS takes priority over any professional services they may also provide. Example: "Marcus's wife Keisha does hair" → connection_type = "marriage", connected_through = "Marcus", NOT connection_type = "professional".

   CRITICAL: "like a brother", "surrogate sister", "father figure" = "chosen", NOT "blood". Only actual blood/marriage/legal family = "blood" or "marriage".

2. access (required, float 0.00-1.00)
   How much vulnerability would ${primaryUserName} extend to this person?
   0.90-1.00: Unrestricted trust. Kids, home, finances, unlocked phone — all offered without anxiety.
   0.70-0.89: High trust. 3am emergency call. Vulnerable conversations. Significant favors expected to land.
   0.50-0.69: Mutual trust. Direct contact exists. Reaching out is normal. Would help if asked.
   0.30-0.49: Contextual trust. Warm in shared settings. Wouldn't reach out independently.
   0.10-0.29: Recognition. Know who they are. No real trust, just awareness.
   0.01-0.09: One-directional. Parasocial or purely observational.
   Score based on EVIDENCE in the text. Look for trust indicators, emotional language, frequency of contact, shared vulnerability, practical reliance.

3. connected_through (required, string or null)
   Is this a direct relationship with ${primaryUserName} or through someone else?
   null — direct relationship. ${primaryUserName} and this person have an independent connection.
   "Person Name" — connected through this person.

   CRITICAL RULES:
   a) If the text says "[Person] is [Someone Else]'s [wife/husband/spouse/partner]" and [Someone Else] is NOT ${primaryUserName}, then connected_through = "[Someone Else]". This person is NOT ${primaryUserName}'s family.
   b) If the text says "[Person] is [Someone]'s [sister/brother/child/parent]" and [Someone] is NOT ${primaryUserName}, then connected_through = "[Someone]".
   c) EXCEPTION — Spouse's family: If connected_through is ${primaryUserName}'s CURRENT SPOUSE, and the person is the spouse's blood relative, they are an in-law. Set sub_role = "in_law".
   d) EXCEPTION — Sibling's spouse: If the person is married to ${primaryUserName}'s sibling, they are an in-law. Set sub_role = "in_law" and connected_through = the sibling's name.
   e) If someone originally met ${primaryUserName} through a bridge person but NOW has an independent relationship, set connected_through = null and put the origin story in the descriptor.

4. status (required, enum)
   "active" — regular engagement, generating contact
   "stable" — solid, doesn't need regular contact. Would re-engage instantly.
   "passive" — no regular contact, zero animosity. Dormant, not dead.
   "diminishing" — actively fading. Less contact over time.
   "inactive" — effectively ended. Not hostile, just done.
   "estranged" — active conflict, avoidance, or tension.
   "deceased" — person has passed away.
   "complicated" — multiple simultaneous states. MUST explain in descriptor.

5. strength (required, float 0.00-1.00)
   How much would ${primaryUserName}'s life change without this person?
   0.90-1.00: Life-altering. Daily existence changes. The 5-7 anchors.
   0.75-0.89: Significant. Felt at milestones, holidays, hard decisions.
   0.50-0.74: Meaningful. Would miss them. Daily life continues unchanged.
   0.30-0.49: Mild. Latent goodwill. Would notice eventually if prompted.
   0.10-0.29: Negligible. Memory, not active life.
   0.01-0.09: None. Cultural awareness only.

   INDEPENDENCE RULE: Strength is independent of access. A deceased best friend has access 0.00 but strength can be 0.90. A friendly acquaintance might have access 0.55 but strength 0.30. Do not conflate reachability with emotional impact.
   EVIDENCE RULE: Do not inflate strength based on connection_type alone. Not all siblings are close. Not all colleagues are distant. Score what the text SHOWS, not what the relationship type implies.

6. sub_role (required, string)
   Most specific role this person plays:
   Family: spouse | child | parent | grandparent | sibling | uncle | aunt | cousin | in_law | extended
   Friends: friend | mentor | mentee | confidant | surrogate_sibling | surrogate_parent
   Professional: colleague | manager | report | partner | client | vendor
   Community: classmate | neighbor | member | acquaintance
   Other: influence

7. descriptor (required, string, 4-8 words)
   Completes "That's my ___" in ${primaryUserName}'s voice.
   Rules:
   - Use NICKNAMES when present in the data
   - High access (0.70+): qualifier + relationship + origin ("best friend from the block", "day-one from Howard, like a brother")
   - Moderate access (0.40-0.69): context + relationship ("CAU MBA classmate, trivia crew")
   - Low access (<0.40): connection path only ("old acquaintance from Markham")
   - Deceased: use "late" naturally ("late best friend from the block")
   - Former: include transition + ongoing connection ("ex-wife, London's mother")
   - Complicated: name the layers ("ex-wife, co-parent, complicated history")
   - Distance 2+ people: use bridge person's NICKNAME ("Ro's wife" not "Rodrique Fru's wife", "Jeff's wife" not "Jeffrey Richard Mitchell's wife")

8. descriptor_origin (required, string)
   Origin context for the relationship (e.g., "childhood", "Howard University", "work", "Lola's family", "the block")

RELATIONSHIP SCORING — ORGANIZATION ENTITIES:

ONLY extract organizations where ${primaryUserName} has a DIRECT relationship. If the org is mentioned in someone else's bio or as a general reference, DO NOT EXTRACT IT.

Include an "org_dimensions" object AND a top-level "descriptor" field:
- relationship_to_primary: "employer" | "alma_mater" | "membership" | "service_provider"
- org_category: "career" | "education" | "affiliations" | "services"
- org_status: "current" | "former"
- primary_user_role: ${primaryUserName}'s role/title at this org
- org_dates: approximate date range or ""
- org_descriptor: 3-6 word natural description
` : '';

  return `You are a structured data extraction engine. Extract ALL named people and organizations from this document.

This is a raw text document${chunkLabel}. It may be personal notes, relationship descriptions, memories, meeting notes, journal entries, correspondence, profiles, or any other text. Your job is to find EVERY named person and EVERY named organization mentioned, no matter how briefly.

CRITICAL — ANTI-HALLUCINATION RULES:
- ONLY extract entities whose names EXPLICITLY appear in the source text below
- Do NOT infer, generate, or fabricate any names that are not written in the text
- Every entity MUST include at least one observation with a DIRECT QUOTE from the source text as evidence
- If you are unsure whether a name appears in the text, do NOT include it
- Do NOT combine or merge separate people into one entity
- If the text says "his daughter" but does not name her, do NOT invent a name for her

CELEBRITY / PUBLIC FIGURE FILTER:
- Do NOT create entities for celebrities, public figures, or famous people unless they have a direct personal relationship with the author (e.g., they are a friend, colleague, family member, or direct acquaintance)
- If someone is mentioned as a comparison, reference, or example (e.g., "he's like the LeBron of his field"), do NOT create an entity for them
- If a famous person is mentioned only in passing or as a cultural reference, skip them
${primaryBlock}
EXTRACTION RULES:
- Return a MAXIMUM of 10 entities per chunk. Focus on the most significant named people and organizations. Skip minor mentions.
- entity_type MUST be "person", "business", or "institution"
- Use "business" for companies, for-profit organizations, and commercial entities
- Use "institution" for schools, universities, governments, hospitals, public services, churches, non-profits, and civic organizations
- When processing incorporation documents, articles of organization, EIN letters, operating agreements, or tax filings, ALWAYS create an entity of type "business" for the company itself — not just the people mentioned in the document
- For persons: include name, role, relationship to the author, location, personality traits, key facts — whatever the text says
- For organizations: include name, industry, location, what the author says about them
- Each observation MUST contain a direct quote or close paraphrase from the source text
- If someone is mentioned by first name only (e.g. "Marcus"), still extract them — but use exactly the name from the text
- If an organization is mentioned even once (e.g. "he works at Google"), extract it

OUTPUT FORMAT — valid JSON only, no markdown fences, no commentary:
{
  "entities": [
    {
      "entity_type": "person",
      "name": { "full": "Jane Smith" },
      "summary": "2-3 sentence summary of what the document says about this person",
      "attributes": { "role": "Product Manager", "location": "Atlanta", "personality": "outgoing and reliable" },
      "relationships": [{ "name": "Other Entity", "relationship": "colleague", "context": "worked together at Acme Corp" }],
      "observations": [{ "text": "Exact quote or paraphrase from the document about this entity" }],
      "relationship_dimensions": { "connection_type": "professional", "access": 0.55, "connected_through": null, "status": "active", "strength": 0.50, "sub_role": "colleague", "descriptor": "colleague at Acme Corp", "descriptor_origin": "work" },
      "descriptor": "colleague at Acme Corp"
    },
    {
      "entity_type": "business",
      "name": { "common": "Google" },
      "summary": "...",
      "attributes": { "industry": "Technology" },
      "relationships": [],
      "observations": [{ "text": "..." }],
      "org_dimensions": { "relationship_to_primary": "employer", "org_category": "career", "org_status": "current", "primary_user_role": "Engineer", "org_dates": "2020-present", "org_descriptor": "current employer, tech" },
      "descriptor": "current employer, tech"
    },
    {
      "entity_type": "institution",
      "name": { "common": "Howard University" },
      "summary": "...",
      "attributes": { "institution_type": "university" },
      "relationships": [],
      "observations": [{ "text": "..." }],
      "org_dimensions": { "relationship_to_primary": "alma_mater", "org_category": "education", "org_status": "former", "primary_user_role": "Student", "org_dates": "", "org_descriptor": "alma mater" },
      "descriptor": "alma mater"
    }
  ]
}

Source file: ${filename}${chunkLabel}

--- DOCUMENT TEXT ---
${text}
--- END ---`;
}

function buildIngestPrompt(batch, primaryUserName) {
  let text = '';
  batch.forEach((conv, i) => {
    text += '\nCONVERSATION ' + i + ' (title: "' + conv.title.replace(/"/g, '\\"') + '"):\n';
    let convText = conv.userMessages.join('\n');
    if (convText.length > 5000) convText = convText.substring(0, 5000) + '\n[...truncated]';
    text += convText + '\n';
  });

  let primaryBlock = '';
  if (primaryUserName) {
    primaryBlock = '\nPRIMARY USER CONTEXT:\n'
      + 'The primary user of this system is ' + primaryUserName + '. Every person and organization you extract must be scored in relationship TO ' + primaryUserName + '.\n'
      + '\nRELATIONSHIP SCORING — PERSON ENTITIES:\n'
      + 'For each PERSON entity, include a "relationship_dimensions" object AND a top-level "descriptor" field.\n'
      + '\n1. connection_type (required, enum): "blood" | "marriage" | "chosen" | "professional" | "community"\n'
      + '   "blood" = biological or legally adopted family. "marriage" = connected through marriage (spouse, ex-spouse, in-law, step-relative). "chosen" = voluntary personal relationship (friend, mentor, confidant, surrogate family). "professional" = work/business. "community" = shared context (classmate, neighbor).\n'
      + '   TIEBREAKER: When relationship spans BOTH chosen AND professional, pick whichever came FIRST chronologically. Default to "chosen" when ambiguous.\n'
      + '   SPOUSE RULE: If someone is identified as another person\'s wife/husband/spouse/partner, and that person is NOT ' + primaryUserName + ', connection_type MUST be "marriage" with connected_through = the spouse. Marriage ALWAYS takes priority over professional services.\n'
      + '   CRITICAL: "like a brother", "surrogate sister", "father figure" = "chosen", NOT "blood".\n'
      + '\n2. access (required, float 0.00-1.00): How much vulnerability would ' + primaryUserName + ' extend?\n'
      + '   0.90-1.00: Unrestricted trust (kids, home, finances). 0.70-0.89: High trust (3am call, vulnerable conversations). 0.50-0.69: Mutual trust (direct contact, would help). 0.30-0.49: Contextual (warm in shared settings). 0.10-0.29: Recognition only. 0.01-0.09: One-directional.\n'
      + '   Score based on EVIDENCE in the text.\n'
      + '\n3. connected_through (required, string or null): null = direct relationship. "Person Name" = connected through that person.\n'
      + '   CRITICAL: If "[Person] is [Someone]\'s [wife/husband/spouse]" and [Someone] is NOT ' + primaryUserName + ', then connected_through = "[Someone]". NOT ' + primaryUserName + '\'s family.\n'
      + '   EXCEPTION — Spouse\'s family: If connected_through is ' + primaryUserName + '\'s CURRENT SPOUSE and person is spouse\'s blood relative, set sub_role = "in_law".\n'
      + '   EXCEPTION — Sibling\'s spouse: If married to ' + primaryUserName + '\'s sibling, set sub_role = "in_law", connected_through = sibling\'s name.\n'
      + '   If someone originally met ' + primaryUserName + ' through a bridge person but NOW has an independent relationship, set connected_through = null.\n'
      + '\n4. status (required, enum): "active" | "stable" | "passive" | "diminishing" | "inactive" | "estranged" | "deceased" | "complicated"\n'
      + '\n5. strength (required, float 0.00-1.00): How much would ' + primaryUserName + '\'s life change without this person?\n'
      + '   0.90-1.00: Life-altering (5-7 anchors). 0.75-0.89: Significant (milestones, holidays). 0.50-0.74: Meaningful. 0.30-0.49: Mild. 0.10-0.29: Negligible. 0.01-0.09: None.\n'
      + '   INDEPENDENCE RULE: Strength is independent of access. Deceased best friend = access 0.00, strength 0.90. Do not inflate based on connection_type alone.\n'
      + '\n6. sub_role (required, string): Family: spouse|child|parent|grandparent|sibling|uncle|aunt|cousin|in_law|extended. Friends: friend|mentor|mentee|confidant|surrogate_sibling|surrogate_parent. Professional: colleague|manager|report|partner|client|vendor. Community: classmate|neighbor|member|acquaintance. Other: influence\n'
      + '\n7. descriptor (required, 4-8 words): Completes "That\'s my ___" in ' + primaryUserName + '\'s voice. Use NICKNAMES. Distance 2+ people use bridge person\'s nickname ("Ro\'s wife" not full name).\n'
      + '\n8. descriptor_origin (required, string): Origin context ("childhood", "Howard", "work", etc.)\n'
      + '\nRELATIONSHIP SCORING — ORGANIZATION ENTITIES:\n'
      + 'ONLY extract orgs where ' + primaryUserName + ' has a DIRECT relationship. If mentioned in someone else\'s bio, DO NOT EXTRACT.\n'
      + 'Include "org_dimensions" object: relationship_to_primary ("employer"|"alma_mater"|"membership"|"service_provider"), org_category ("career"|"education"|"affiliations"|"services"), org_status ("current"|"former"), primary_user_role, org_dates, org_descriptor (3-6 words).\n'
      + 'Also include top-level "descriptor" = org_dimensions.org_descriptor.\n\n';
  }

  return 'You are a structured data extraction engine. Analyze these user messages from ChatGPT conversations and extract every person, business, and institution the user mentions by name.\n\nRULES:\n- Only extract named entities (skip "my boss", "the company" without a specific name)\n- entity_type: "person", "business", or "institution"\n- Use "business" for companies and commercial entities; use "institution" for schools, universities, governments, hospitals, public services, churches, non-profits\n- name: { "full": "..." } for persons, { "common": "..." } for businesses and institutions\n- summary: 2-3 sentences synthesizing what the user said about this entity\n- attributes: only include clearly stated facts (role, location, expertise, industry)\n- relationships: connections between extracted entities\n- observations: each specific mention tagged with conversation_index (0-based integer matching conversation numbers below)\n- For persons: include relationship_dimensions and descriptor as top-level fields (see PRIMARY USER CONTEXT)\n- For orgs: include org_dimensions and descriptor as top-level fields\n- Do NOT invent information beyond what the user explicitly stated\n- Do NOT create entities for celebrities or public figures unless they have a direct personal relationship with the user\n- If no named entities found, return {"entities": []}\n'
    + primaryBlock
    + 'Output ONLY valid JSON, no markdown fences, no commentary:\n{\n  "entities": [\n    {\n      "entity_type": "person",\n      "name": { "full": "Jane Smith" },\n      "summary": "...",\n      "attributes": { "role": "...", "location": "..." },\n      "relationships": [{ "name": "Other Entity", "relationship": "colleague", "context": "..." }],\n      "observations": [{ "text": "What the user said about this entity", "conversation_index": 0 }],\n      "relationship_dimensions": { "connection_type": "professional", "access": 0.55, "connected_through": null, "status": "active", "strength": 0.50, "sub_role": "colleague", "descriptor": "colleague at Acme Corp", "descriptor_origin": "work" },\n      "descriptor": "colleague at Acme Corp"\n    }\n  ]\n}\n\n--- USER MESSAGES FROM CONVERSATIONS ---' + text + '\n--- END ---';
}

function buildProfilePrompt(text, filename, primaryUserName) {
  const primaryBlock = primaryUserName ? 'PRIMARY USER CONTEXT:\n'
    + 'The primary user of this system is ' + primaryUserName + '. Score this entity in relationship TO ' + primaryUserName + '.\n\n'
    + 'RELATIONSHIP SCORING — PERSON ENTITIES:\n'
    + 'Include a "relationship_dimensions" object AND a top-level "descriptor" field.\n'
    + '1. connection_type (required): "blood" | "marriage" | "chosen" | "professional" | "community"\n'
    + '2. access (required, float 0.00-1.00): vulnerability/trust level\n'
    + '3. connected_through (required, string or null)\n'
    + '4. status (required): "active" | "stable" | "passive" | "diminishing" | "inactive" | "estranged" | "deceased" | "complicated"\n'
    + '5. strength (required, float 0.00-1.00): life-impact score\n'
    + '6. sub_role (required, string): most specific role\n'
    + '7. descriptor (required, 4-8 words): completes "That\'s my ___"\n'
    + '8. descriptor_origin (required, string): origin context\n\n' : '';

  return 'You are processing a DEEP STRUCTURED PROFILE. Your job is to PRESERVE the full depth and structure of this assessment.\n\n'
    + 'CRITICAL RULES:\n'
    + '1. PRESERVE ALL STRUCTURE — nested objects, arrays, scores, and hierarchies must survive extraction. Do NOT flatten.\n'
    + '2. PRESERVE EXACT NUMBERS — OCEAN scores, Enneagram numbers, percentages, dates. Never round or approximate.\n'
    + '3. PRESERVE LISTS — energized_by, drained_by, blind_spots are ARRAYS. Keep them as arrays.\n'
    + '4. PRESERVE DISPUTES — if a score is marked as disputed, contested, or has a _note, include both the score AND the dispute.\n'
    + '5. PRESERVE MANAGEMENT PROTOCOLS — what_works, what_doesnt_work, communication guidelines are HIGH-VALUE data.\n'
    + '6. PRESERVE MJ/AI ANALYSIS — any analysis attributed to an AI, MJ, or external assessor is an OBSERVATION with attribution.\n'
    + '7. ONE ENTITY PER PROFILE — this document describes ONE person. Extract exactly one primary entity.\n'
    + '8. RELATIONSHIP DEDUP — if the same person appears in multiple sections (e.g., spouse in family AND spouse_dynamic), create ONE relationship entry with the richest context.\n'
    + '9. NO SELF-REFERENCES — do NOT create a relationship from the subject to themselves.\n'
    + '10. DIMENSION SCORING — score the relationship_dimensions from ' + (primaryUserName || 'the primary user') + '\'s perspective.\n\n'
    + primaryBlock
    + 'STRUCTURED ATTRIBUTE CATEGORIES:\n'
    + 'Extract into "structured_attributes" with these category keys:\n\n'
    + '- identity: { preferred_name, full_name, age, date_of_birth, location, origin, nationality, languages }\n'
    + '- professional: { current_role, company, industry, career_history (array), skills (array), education (array) }\n'
    + '- personality_assessments: {\n'
    + '    mbti: { type, description, confidence },\n'
    + '    enneagram: { core_type, wing, tritype, instinctual_variant, description },\n'
    + '    ocean: { openness: { score, percentile, _note? }, conscientiousness: { score, percentile, _note? }, extraversion: { score, percentile, _note? }, agreeableness: { score, percentile, _note? }, neuroticism: { score, percentile, _note? } }\n'
    + '  }\n'
    + '- behavioral_patterns: { communication_style, decision_making, conflict_style, energized_by (array), drained_by (array), blind_spots (array) }\n'
    + '- enneagram_dynamics: { core_motivation, fear, desire, growth_direction, stress_direction, integration_path, disintegration_path }\n'
    + '- family: { spouse: { name, relationship_type }, children (array of { name, age?, notes? }), family_notes }\n'
    + '- spouse_dynamic: { core_dynamic, friction_points (array), strengths (array), confirmed (array), disputed (array), modified (array) }\n'
    + '- relationship_to_primary_user: { what_works (array), what_doesnt_work (array), management_protocol, mj_analysis, communication_guidelines }\n'
    + '- ai_interaction_guidelines: { expectations (array), cautions (array), preferred_approach }\n'
    + '- profile_metadata: { assessment_date, last_updated, created_date, confidence_level, data_sources (array), verification_status, schema_version, gaps (array) }\n\n'
    + 'OBSERVATIONS RULES:\n'
    + '- Observations must be INSIGHT-LEVEL: blind spots, relationship dynamics, external analyses, behavioral patterns\n'
    + '- Do NOT dump flat attribute data as observations\n'
    + '- Each observation should be something a human would find genuinely insightful\n'
    + '- Include MJ/AI analyses as observations with source attribution\n\n'
    + 'OUTPUT FORMAT — valid JSON only, no markdown fences, no commentary:\n'
    + '{\n'
    + '  "entities": [{\n'
    + '    "entity_type": "person",\n'
    + '    "name": { "full": "Full Name", "preferred": "Nickname" },\n'
    + '    "summary": "2-3 sentence summary of this person based on the profile",\n'
    + '    "attributes": { "key": "value pairs for flat searchable data" },\n'
    + '    "relationships": [{ "name": "Person Name", "relationship": "type", "context": "rich context" }],\n'
    + '    "observations": [{ "text": "Insight-level observation with evidence" }],\n'
    + '    "structured_attributes": { "identity": {}, "professional": {}, "personality_assessments": {}, "behavioral_patterns": {}, "enneagram_dynamics": {}, "family": {}, "spouse_dynamic": {}, "relationship_to_primary_user": {}, "ai_interaction_guidelines": {}, "profile_metadata": {} },\n'
    + '    "relationship_dimensions": { "connection_type": "...", "access": 0.0, "connected_through": null, "status": "...", "strength": 0.0, "sub_role": "...", "descriptor": "...", "descriptor_origin": "..." },\n'
    + '    "descriptor": "4-8 word descriptor"\n'
    + '  }]\n'
    + '}\n\n'
    + 'Source file: ' + filename + '\n\n'
    + '--- PROFILE TEXT ---\n'
    + text + '\n'
    + '--- END ---';
}

// --- Auth middleware (multi-tenant) ---

function apiAuth(req, res, next) {
  const config = loadConfig();

  // Source 1: X-Context-API-Key header (existing behavior for API consumers)
  const key = req.headers['x-context-api-key'];

  if (key) {
    // Admin key — root namespace
    if (key === config.api_key) {
      req.agentId = req.headers['x-agent-id'] || 'external';
      req.graphDir = GRAPH_DIR;
      req.isAdmin = true;
      req.tenantId = null;
      return next();
    }

    // Tenant key lookup
    const tenants = loadTenants();
    const tenant = Object.values(tenants).find(t => t.api_key === key);
    if (tenant) {
      const tenantDir = path.join(GRAPH_DIR, `tenant-${tenant.tenant_id}`);
      if (!fs.existsSync(tenantDir)) fs.mkdirSync(tenantDir, { recursive: true });
      req.agentId = req.headers['x-agent-id'] || tenant.tenant_name;
      req.graphDir = tenantDir;
      req.isAdmin = false;
      req.tenantId = tenant.tenant_id;
      return next();
    }

    return res.status(401).json({ error: 'Invalid API key' });
  }

  // Source 2: Bearer token or ca_session cookie (browser sessions via Google OAuth)
  const session = auth.verifySession(req);
  if (session && session.api_key) {
    const tenants = loadTenants();
    const tenant = Object.values(tenants).find(t => t.api_key === session.api_key);
    if (tenant) {
      const tenantDir = path.join(GRAPH_DIR, `tenant-${tenant.tenant_id}`);
      if (!fs.existsSync(tenantDir)) fs.mkdirSync(tenantDir, { recursive: true });
      req.agentId = tenant.tenant_name;
      req.graphDir = tenantDir;
      req.isAdmin = false;
      req.tenantId = tenant.tenant_id;
      return next();
    }
  }

  return res.status(401).json({ error: 'Missing X-Context-API-Key header or valid session' });
}

function adminOnly(req, res, next) {
  if (!req.isAdmin) {
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
}

// GET /api/tenant/config — Return tenant config (self_entity_id, tenant_id)
app.get('/api/tenant/config', apiAuth, (req, res) => {
  const selfEntityId = getSelfEntityId(req.graphDir);
  res.json({ self_entity_id: selfEntityId, tenant_id: req.tenantId || null });
});

// POST /api/tenant — Create a new tenant (admin only)
app.post('/api/tenant', apiAuth, adminOnly, (req, res) => {
  const { tenant_name } = req.body;
  if (!tenant_name || typeof tenant_name !== 'string' || !tenant_name.trim()) {
    return res.status(400).json({ error: 'tenant_name is required' });
  }

  const tenants = loadTenants();

  // Check duplicate name
  if (Object.values(tenants).some(t => t.tenant_name.toLowerCase() === tenant_name.trim().toLowerCase())) {
    return res.status(409).json({ error: `Tenant "${tenant_name}" already exists` });
  }

  const tenantId = crypto.randomBytes(4).toString('hex');
  const apiKey = 'ctx-' + crypto.randomBytes(16).toString('hex');
  const tenantDir = path.join(GRAPH_DIR, `tenant-${tenantId}`);
  fs.mkdirSync(tenantDir, { recursive: true });

  tenants[tenantId] = {
    tenant_id: tenantId,
    tenant_name: tenant_name.trim(),
    api_key: apiKey,
    created_at: new Date().toISOString(),
    created_by: req.agentId,
  };
  saveTenants(tenants);

  res.status(201).json({
    status: 'created',
    tenant_id: tenantId,
    tenant_name: tenant_name.trim(),
    api_key: apiKey,
    graph_directory: `tenant-${tenantId}`,
    note: 'Save this API key — it will not be shown again.',
  });
});

// POST /api/ingest/chatgpt — Import ChatGPT conversation history
app.post('/api/ingest/chatgpt', apiAuth, async (req, res) => {
  const startTime = Date.now();

  // Parse input
  let conversations;
  try {
    const input = req.body.conversations || req.body.raw;
    if (!input) {
      return res.status(400).json({ error: 'Missing "conversations" array or "raw" JSON string' });
    }
    conversations = parseChatGPTExport(input);
  } catch (err) {
    return res.status(400).json({ error: 'Failed to parse input: ' + err.message });
  }

  if (conversations.length === 0) {
    return res.status(400).json({ error: 'No conversations with user messages found' });
  }

  // Stream NDJSON progress
  res.setHeader('Content-Type', 'application/x-ndjson');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.flushHeaders();

  const sendEvent = (event) => res.write(JSON.stringify(event) + '\n');

  const BATCH_SIZE = 10;
  const batches = [];
  for (let i = 0; i < conversations.length; i += BATCH_SIZE) {
    batches.push(conversations.slice(i, i + BATCH_SIZE));
  }

  let entitiesCreated = 0;
  let entitiesUpdated = 0;
  let observationsAdded = 0;
  let conversationsProcessed = 0;

  sendEvent({
    type: 'started',
    total_conversations: conversations.length,
    total_batches: batches.length,
  });

  const client = new Anthropic();
  const primaryUserName = getPrimaryUserName(req.graphDir);

  for (let bi = 0; bi < batches.length; bi++) {
    const batch = batches[bi];

    try {
      const prompt = buildIngestPrompt(batch, primaryUserName);
      const message = await client.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 16384,
        messages: [{ role: 'user', content: prompt }],
      });
      const rawResponse = message.content[0].text;
      const cleaned = rawResponse.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
      const parsed = JSON.parse(cleaned);

      // Build v2 entities from Claude's extraction
      const v2Entities = [];
      for (const extracted of (parsed.entities || [])) {
        const entityType = extracted.entity_type;
        if (!entityType || !['person', 'business'].includes(entityType)) continue;

        const displayName = entityType === 'person'
          ? (extracted.name?.full || '')
          : (extracted.name?.common || extracted.name?.legal || '');
        if (!displayName) continue;

        const now = new Date().toISOString();

        // Build observations from extracted data
        const observations = (extracted.observations || []).map(obs => {
          const convIdx = typeof obs.conversation_index === 'number' ? obs.conversation_index : 0;
          const conv = batch[convIdx] || batch[0];
          return {
            observation: (obs.text || '').trim(),
            observed_at: conv.createTime,
            source: 'chatgpt_import',
            confidence: 0.6,
            confidence_label: 'MODERATE',
            facts_layer: 'L2_GROUP',
            layer_number: 2,
            observed_by: req.agentId,
          };
        }).filter(o => o.observation);

        // Build attributes
        const attributes = [];
        if (extracted.attributes && typeof extracted.attributes === 'object') {
          let attrSeq = 1;
          for (const [key, value] of Object.entries(extracted.attributes)) {
            const val = Array.isArray(value) ? value.join(', ') : String(value);
            if (!val) continue;
            attributes.push({
              attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`,
              key, value: val, confidence: 0.6, confidence_label: 'MODERATE',
              time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
              source_attribution: { facts_layer: 2, layer_label: 'group' },
            });
          }
        }

        // Build relationships
        const relationships = [];
        if (Array.isArray(extracted.relationships)) {
          let relSeq = 1;
          for (const rel of extracted.relationships) {
            relationships.push({
              relationship_id: `REL-${String(relSeq++).padStart(3, '0')}`,
              name: rel.name || '', relationship_type: rel.relationship || '', context: rel.context || '',
              sentiment: 'neutral', confidence: 0.6, confidence_label: 'MODERATE',
            });
          }
        }

        const v2Entity = {
          schema_version: '2.0',
          schema_type: 'context_architecture_entity',
          extraction_metadata: {
            extracted_at: now,
            updated_at: now,
            source_description: 'chatgpt_import',
            extraction_model: 'claude-sonnet-4-5-20250929',
            extraction_confidence: 0.6,
            schema_version: '2.0',
          },
          entity: {
            entity_type: entityType,
            name: { ...extracted.name, confidence: 0.6, facts_layer: 2 },
            summary: extracted.summary
              ? { value: extracted.summary, confidence: 0.6, facts_layer: 2 }
              : { value: '', confidence: 0, facts_layer: 2 },
          },
          attributes,
          relationships,
          values: [],
          key_facts: [],
          constraints: [],
          observations,
          provenance_chain: {
            created_at: now,
            created_by: req.agentId,
            source_documents: [{ source: 'chatgpt_import', ingested_at: now }],
            merge_history: [],
          },
        };
        if (extracted.relationship_dimensions) {
          // Compute visual_tier from strength
          if (typeof extracted.relationship_dimensions.strength === 'number') {
            extracted.relationship_dimensions.visual_tier = computeVisualTier(extracted.relationship_dimensions.strength);
          }
          v2Entity.relationship_dimensions = extracted.relationship_dimensions;
          // Compute wiki_page and wiki_section
          var wp = computeWikiPage(extracted.relationship_dimensions);
          v2Entity.wiki_page = wp;
          v2Entity.wiki_section = computeWikiSection(extracted.relationship_dimensions, wp);
        }
        if (extracted.descriptor) v2Entity.descriptor = extracted.descriptor;
        if (extracted.org_dimensions) {
          v2Entity.org_dimensions = extracted.org_dimensions;
          // Add org_category attribute for sidebar compatibility
          if (extracted.org_dimensions.org_category) {
            v2Entity.attributes = v2Entity.attributes || [];
            v2Entity.attributes.push({
              attribute_id: 'ATTR-ORG-CAT',
              key: 'org_category', value: extracted.org_dimensions.org_category,
              confidence: 0.8, confidence_label: 'HIGH',
              time_decay: { stability: 'stable', captured_date: new Date().toISOString().slice(0, 10) },
              source_attribution: { facts_layer: 2, layer_label: 'group' },
            });
          }
        }
        v2Entities.push(v2Entity);
      }

      // Ingest via unified pipeline
      const result = await ingestPipeline(v2Entities, req.graphDir, req.agentId, {
        source: 'chatgpt_import',
        truthLevel: 'INFERRED',
      });

      entitiesCreated += result.created;
      entitiesUpdated += result.updated;
      observationsAdded += result.observationsAdded;

      conversationsProcessed += batch.length;
      sendEvent({
        type: 'progress',
        batch: bi + 1,
        total_batches: batches.length,
        conversations_processed: conversationsProcessed,
        total_conversations: conversations.length,
        entities_created: entitiesCreated,
        entities_updated: entitiesUpdated,
        observations_added: observationsAdded,
      });

    } catch (err) {
      conversationsProcessed += batch.length;
      sendEvent({
        type: 'batch_error',
        batch: bi + 1,
        error: err.message,
        conversations_processed: conversationsProcessed,
      });
    }
  }

  // Final summary
  sendEvent({
    type: 'complete',
    summary: {
      entities_created: entitiesCreated,
      entities_updated: entitiesUpdated,
      observations_added: observationsAdded,
      conversations_processed: conversationsProcessed,
      processing_time_seconds: Math.round((Date.now() - startTime) / 10) / 100,
    },
  });
  res.end();
});

// --- Spoke auto-resolution for ingest endpoints ---
// If spoke_id is provided but doesn't exist (and isn't "default"), auto-create it.
function resolveOrCreateSpoke(graphDir, spokeId) {
  if (!spokeId || spokeId === 'default') return 'default';
  const existing = getSpoke(graphDir, spokeId);
  if (existing) return spokeId;
  // Treat as a name if it doesn't look like a spoke ID
  if (!spokeId.startsWith('spoke-')) {
    // Check if a spoke with this name exists
    const spokes = loadSpokes(graphDir);
    const byName = Object.values(spokes).find(s => s.name.toLowerCase() === spokeId.toLowerCase());
    if (byName) return byName.id;
    // Auto-create spoke with this name
    const newSpoke = createSpoke(graphDir, { name: spokeId, description: 'Auto-created from ingest', source: 'manual' });
    console.log(`[spoke] Auto-created spoke "${spokeId}" → ${newSpoke.id}`);
    return newSpoke.id;
  }
  // Looks like an ID but doesn't exist — create with generic name
  return spokeId;
}

// --- Provenance: Preserve original source files ---

const MIME_MAP = {
  '.txt': 'text/plain', '.md': 'text/markdown', '.json': 'application/json',
  '.pdf': 'application/pdf', '.csv': 'text/csv', '.tsv': 'text/tab-separated-values',
  '.html': 'text/html', '.htm': 'text/html', '.xml': 'application/xml',
  '.doc': 'application/msword', '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  '.xls': 'application/vnd.ms-excel', '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.gif': 'image/gif',
  '.tiff': 'image/tiff', '.tif': 'image/tiff', '.bmp': 'image/bmp', '.webp': 'image/webp',
};

function preserveSourceFile(graphDir, spokeId, filename, fileBuffer) {
  const ext = path.extname(filename).toLowerCase();
  const fileId = 'file-' + crypto.createHash('sha256').update(filename + Date.now()).digest('hex').slice(0, 8);
  const sha256 = crypto.createHash('sha256').update(fileBuffer).digest('hex');
  const mimeType = MIME_MAP[ext] || 'application/octet-stream';
  const storedAs = fileId + ext;
  const dir = path.join(graphDir, 'spoke_files', spokeId);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(path.join(dir, storedAs), fileBuffer);

  const manifest = {
    file_id: fileId,
    original_name: filename,
    mime_type: mimeType,
    size_bytes: fileBuffer.length,
    uploaded_at: new Date().toISOString(),
    sha256,
    stored_as: storedAs,
  };

  // Append to spoke files manifest
  const spoke = getSpoke(graphDir, spokeId);
  const files = (spoke && spoke.files) || [];
  files.push(manifest);
  updateSpoke(graphDir, spokeId, { files });

  return fileId;
}

// POST /api/ingest/files — Upload files for entity extraction
const upload = multer({ storage: multer.memoryStorage(), limits: { files: 20, fileSize: 50 * 1024 * 1024 } });
const ALLOWED_EXTENSIONS = new Set(['.pdf', '.docx', '.doc', '.xlsx', '.xls', '.csv', '.txt', '.md', '.json']);

app.post('/api/ingest/files', apiAuth, upload.array('files', 20), async (req, res) => {
  const previewMode = req.query.preview === 'true';
  const rawSpokeId = req.query.spoke_id || req.body?.spoke_id || 'default';
  const spokeId = resolveOrCreateSpoke(req.graphDir, rawSpokeId);
  const files = req.files;
  if (files) {
    for (const f of files) {
      console.log('INGEST_DEBUG: file received:', f.originalname, f.mimetype, f.size, previewMode ? '(PREVIEW)' : '', `spoke: ${spokeId}`);
    }
  }
  if (!files || files.length === 0) {
    return res.status(400).json({ error: 'No files uploaded. Send files via multipart field "files".' });
  }

  // Resolve primary user name for extraction prompts
  const primaryUserName = getPrimaryUserName(req.graphDir);

  // Validate extensions
  for (const file of files) {
    const ext = path.extname(file.originalname).toLowerCase();
    if (!ALLOWED_EXTENSIONS.has(ext)) {
      return res.status(400).json({ error: `Unsupported file type: ${ext}. Allowed: ${[...ALLOWED_EXTENSIONS].join(', ')}` });
    }
  }

  // Stream NDJSON progress
  res.setHeader('Content-Type', 'application/x-ndjson');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.flushHeaders();

  const sendEvent = (event) => res.write(JSON.stringify(event) + '\n');

  sendEvent({ type: 'started', total_files: files.length });

  let totalCreated = 0;
  let totalUpdated = 0;
  let totalObservations = 0;
  const allPreviewEntities = [];
  const client = new Anthropic();

  for (let fi = 0; fi < files.length; fi++) {
    const file = files[fi];
    const filename = file.originalname;

    try {
      // JSON files: detect ChatGPT conversations format, otherwise treat as raw text
      if (path.extname(filename).toLowerCase() === '.json') {
        const raw = file.buffer.toString('utf-8');
        let parsed;
        try { parsed = JSON.parse(raw); } catch { parsed = null; }

        if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].mapping && parsed[0].title !== undefined) {
          // ChatGPT conversations.json format
          const conversations = parseChatGPTExport(parsed);
          if (conversations.length > 0) {
            const BATCH_SIZE = 5;
            let created = 0, updated = 0, obsAdded = 0;
            for (let b = 0; b < conversations.length; b += BATCH_SIZE) {
              const batch = conversations.slice(b, b + BATCH_SIZE);
              const prompt = buildIngestPrompt(batch, primaryUserName);
              const message = await client.messages.create({
                model: 'claude-sonnet-4-5-20250929',
                max_tokens: 16384,
                messages: [{ role: 'user', content: prompt }],
              });
              const rawResp = message.content[0].text;
              const cleaned = rawResp.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
              const batchParsed = JSON.parse(cleaned);
              const rawEntities = (batchParsed.entities || []).filter(e => e && ['person', 'business', 'institution'].includes(e.entity_type));
              // Convert raw LLM output to v2 entity format
              const now = new Date().toISOString();
              const v2Batch = rawEntities.map(ext => {
                const eType = ext.entity_type === 'organization' ? 'business' : ext.entity_type;
                const v2 = {
                  schema_version: '2.0', schema_type: 'context_architecture_entity',
                  extraction_metadata: { extracted_at: now, updated_at: now, source_description: filename, extraction_model: 'claude-sonnet-4-5-20250929', extraction_confidence: 0.6, schema_version: '2.0' },
                  entity: { entity_type: eType, name: { ...ext.name, confidence: 0.6, facts_layer: 2 }, summary: ext.summary ? { value: ext.summary, confidence: 0.6, facts_layer: 2 } : { value: '', confidence: 0, facts_layer: 2 } },
                  attributes: [], relationships: [], values: [], key_facts: [], constraints: [],
                  observations: (ext.observations || []).map(o => ({ observation: (o.text || '').trim(), observed_at: now, source: filename, confidence: 0.6, confidence_label: 'MODERATE', facts_layer: 'L2_GROUP', layer_number: 2, observed_by: req.agentId, truth_level: 'INFERRED' })).filter(o => o.observation),
                  provenance_chain: { created_at: now, created_by: req.agentId, source_documents: [{ source: filename, ingested_at: now }], merge_history: [] },
                };
                if (Array.isArray(ext.attributes)) {
                  let seq = 1;
                  for (const attr of ext.attributes) {
                    const sv = String(attr.value || '');
                    const evidence = attr.evidence || null;
                    const eType = evidence ? (evidence.type || 'direct') : 'inferred';
                    const attrConf = (eType === 'direct' && evidence) ? 0.85 : 0.6;
                    if (sv) v2.attributes.push({ attribute_id: 'ATTR-' + String(seq++).padStart(3, '0'), key: attr.key, value: sv, confidence: attrConf, confidence_label: attrConf >= 0.8 ? 'HIGH' : 'MODERATE', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { facts_layer: 2, layer_label: 'group' }, provenance: evidence ? { file_id: null, original_filename: filename, snippet: evidence.snippet, location: evidence.location, extraction_model: 'claude-sonnet-4-5-20250929', extraction_type: eType, extracted_at: now } : null });
                  }
                } else if (ext.attributes && typeof ext.attributes === 'object') {
                  let seq = 1;
                  for (const [k, val] of Object.entries(ext.attributes)) {
                    const sv = Array.isArray(val) ? val.join(', ') : String(val);
                    if (sv) v2.attributes.push({ attribute_id: 'ATTR-' + String(seq++).padStart(3, '0'), key: k, value: sv, confidence: 0.6, confidence_label: 'MODERATE', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { facts_layer: 2, layer_label: 'group' }, provenance: null });
                  }
                }
                if (Array.isArray(ext.relationships)) {
                  let seq = 1;
                  for (const r of ext.relationships) v2.relationships.push({ relationship_id: 'REL-' + String(seq++).padStart(3, '0'), name: r.name || '', relationship_type: r.relationship || '', context: r.context || '', sentiment: 'neutral', confidence: 0.6, confidence_label: 'MODERATE' });
                }
                if (ext.relationship_dimensions) {
                  if (!ext.relationship_dimensions.visual_tier && typeof ext.relationship_dimensions.strength === 'number') ext.relationship_dimensions.visual_tier = computeVisualTier(ext.relationship_dimensions.strength);
                  v2.relationship_dimensions = ext.relationship_dimensions;
                }
                if (ext.descriptor) v2.descriptor = ext.descriptor;
                if (ext.org_dimensions) v2.org_dimensions = ext.org_dimensions;
                return v2;
              });
              if (v2Batch.length > 0) {
                const r = await ingestPipeline(v2Batch, req.graphDir, req.agentId, { source: filename, truthLevel: 'INFERRED' });
                created += r.created; updated += r.updated; obsAdded += r.observationsAdded;
              }
            }
            sendEvent({ type: 'file_progress', file: filename, file_index: fi + 1, total_files: files.length, entities_created: created, entities_updated: updated, observations_added: obsAdded });
            totalCreated += created; totalUpdated += updated; totalObservations += obsAdded;
            continue;
          }
        }
        // Not ChatGPT format — fall through to generic text extraction
      }

      const { text, metadata } = await normalizeFileToText(file.buffer, filename);

      let result;
      let pendingEntities = [];
      let pendingSource = filename;
      let pendingTruth = 'INFERRED';

      if (metadata.isContactList && metadata.rows) {
        // Direct mapping — no LLM call
        pendingEntities = mapContactRows(metadata.rows, filename, req.agentId);
        pendingSource = filename;
        pendingTruth = 'STRONG';

      } else if (metadata.isLinkedIn) {
        // LinkedIn PDF auto-detected — Career extraction via signal staging
        console.log(`[ingest] LinkedIn PDF detected: ${filename}`);
        const prompt = buildLinkedInPrompt(text, filename);
        const message = await client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: 8192,
          messages: [{ role: 'user', content: prompt }],
        });
        const rawResponse = message.content[0].text;
        const cleaned = rawResponse.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
        const parsed = JSON.parse(cleaned);
        const personEntity = linkedInResponseToEntity(parsed, filename, req.agentId);
        const personName = parsed.name?.full || '';
        const orgEntities = linkedInExperienceToOrgs(parsed, personName, filename, req.agentId);
        const linkedInEntities = [personEntity, ...orgEntities];
        // Stamp spoke_id + source tracking on all entities
        for (const ent of linkedInEntities) { ent.spoke_id = spokeId; ent.source = ent.source || 'manual'; ent.source_ref = ent.source_ref || filename; }

        // Always flow through signal staging — no direct entity creation
        // Source type 'linkedin_pdf' with signal_confidence 0.85
        const scoredClusters = stageAndScoreExtraction(linkedInEntities, {
          type: 'linkedin_pdf',
          url: '',
          description: `linkedin_pdf:${filename}`,
        }, req.graphDir);

        sendEvent({
          type: 'file_progress',
          file: filename,
          file_index: fi + 1,
          total_files: files.length,
          linkedin_detected: true,
          staged_count: scoredClusters.length,
          scored_clusters: scoredClusters.map(c => ({
            cluster_id: c.cluster_id,
            entity_name: (c.signals?.names || [])[0] || '',
            quadrant: c.quadrant,
            confidence: c.confidence,
            state: c.state,
          })),
        });
        continue; // Skip the pendingEntities flow — already staged

      } else if (metadata.isProfile) {
        // Profile mode — deep structured extraction
        console.log('INGEST_DEBUG: profile mode for', filename, '— text length:', text.length);
        const prompt = buildProfilePrompt(text, filename, primaryUserName);
        const message = await client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: 16384,
          messages: [{ role: 'user', content: prompt }],
        });
        const rawResponse = message.content[0].text;
        console.log('INGEST_DEBUG: profile response length:', rawResponse.length);
        const parsed = safeParseExtraction(rawResponse, 'profile');
        const profileEntities = parsed.entities || [];
        console.log('INGEST_DEBUG: profile extracted', profileEntities.length, 'entities');

        const now = new Date().toISOString();
        pendingEntities = profileEntities.map(function(extracted) {
          let entityType = extracted.entity_type;
          if (entityType === 'organization') entityType = 'business';
          if (!entityType || !['person', 'business', 'institution'].includes(entityType)) return null;

          // Validate relationships: remove self-refs and dedup
          const entityFullName = extracted.name?.full || extracted.name?.common || '';
          const entityPreferred = extracted.name?.preferred || '';
          const entityAliases = extracted.name?.aliases || [];
          const validatedRels = validateRelationships(
            extracted.relationships || [], entityFullName, entityPreferred, entityAliases
          );

          const observations = (extracted.observations || []).map(function(obs) {
            return {
              observation: (obs.text || '').trim(),
              observed_at: now,
              source: 'file_import:' + filename,
              confidence: 0.8,
              confidence_label: 'HIGH',
              facts_layer: 'L2_GROUP',
              layer_number: 2,
              observed_by: req.agentId,
            };
          }).filter(function(o) { return o.observation; });

          var attributes = [];
          if (extracted.attributes && typeof extracted.attributes === 'object') {
            var attrSeq = 1;
            for (var _key in extracted.attributes) {
              if (!extracted.attributes.hasOwnProperty(_key)) continue;
              var val = extracted.attributes[_key];
              val = Array.isArray(val) ? val.join(', ') : String(val);
              if (!val) continue;
              attributes.push({
                attribute_id: 'ATTR-' + String(attrSeq++).padStart(3, '0'),
                key: _key, value: val, confidence: 0.8, confidence_label: 'HIGH',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
              });
            }
          }

          var relationships = [];
          var relSeq = 1;
          for (var ri = 0; ri < validatedRels.length; ri++) {
            var rel = validatedRels[ri];
            relationships.push({
              relationship_id: 'REL-' + String(relSeq++).padStart(3, '0'),
              name: rel.name || '', relationship_type: rel.relationship_type || rel.relationship || '',
              context: rel.context || '',
              sentiment: 'neutral', confidence: 0.8, confidence_label: 'HIGH',
            });
          }

          // Build structured_attributes with interface marker
          var structuredAttrs = extracted.structured_attributes || {};
          structuredAttrs.interface = 'profile';

          // Extract source date from profile metadata
          var sourceDate = null;
          if (structuredAttrs.profile_metadata) {
            sourceDate = structuredAttrs.profile_metadata.last_updated
              || structuredAttrs.profile_metadata.created_date
              || null;
          }

          var v2Entity = {
            schema_version: '2.0',
            schema_type: 'context_architecture_entity',
            extraction_metadata: {
              extracted_at: now, updated_at: now,
              source_description: 'file_import:' + filename,
              extraction_model: 'claude-sonnet-4-5-20250929',
              extraction_confidence: 0.8, schema_version: '2.0',
              extraction_mode: 'profile',
            },
            entity: {
              entity_type: entityType,
              name: Object.assign({}, extracted.name, { confidence: 0.8, facts_layer: 2 }),
              summary: extracted.summary
                ? { value: extracted.summary, confidence: 0.8, facts_layer: 2 }
                : { value: '', confidence: 0, facts_layer: 2 },
            },
            attributes: attributes, relationships: relationships,
            values: [], key_facts: [], constraints: [],
            observations: observations,
            structured_attributes: structuredAttrs,
            provenance_chain: {
              created_at: now, created_by: req.agentId,
              source_documents: [{ source: 'file_import:' + filename, ingested_at: now }],
              merge_history: [],
            },
          };

          if (sourceDate) {
            v2Entity.extraction_metadata.source_date = sourceDate;
          }

          if (extracted.relationship_dimensions) {
            if (typeof extracted.relationship_dimensions.strength === 'number') {
              extracted.relationship_dimensions.visual_tier = computeVisualTier(extracted.relationship_dimensions.strength);
            }
            v2Entity.relationship_dimensions = extracted.relationship_dimensions;
            var wp = computeWikiPage(extracted.relationship_dimensions);
            v2Entity.wiki_page = wp;
            v2Entity.wiki_section = computeWikiSection(extracted.relationship_dimensions, wp);
          }
          if (extracted.descriptor) v2Entity.descriptor = extracted.descriptor;

          return v2Entity;
        }).filter(Boolean);

        pendingSource = filename;
        pendingTruth = 'STRONG';
        console.log('INGEST_DEBUG: profile v2Entities:', pendingEntities.length);

      } else {
        // Generic text extraction via Claude (with chunking for large files)
        const chunks = chunkText(text);
        console.log('INGEST_DEBUG: generic text path for', filename, '— text length:', text.length, '— chunks:', chunks.length);

        const allExtracted = [];
        for (let ci = 0; ci < chunks.length; ci++) {
          const prompt = buildGenericTextPrompt(chunks[ci], filename, ci + 1, chunks.length, primaryUserName);
          console.log('INGEST_DEBUG: sending chunk', ci + 1, 'of', chunks.length, '— chunk length:', chunks[ci].length);
          const message = await client.messages.create({
            model: 'claude-sonnet-4-5-20250929',
            max_tokens: 16384,
            messages: [{ role: 'user', content: prompt }],
          });
          const rawResponse = message.content[0].text;
          console.log('INGEST_DEBUG: chunk', ci + 1, 'response length:', rawResponse.length);
          const parsed = safeParseExtraction(rawResponse, 'chunk ' + (ci + 1));
          const chunkEntities = parsed.entities || [];
          console.log('INGEST_DEBUG: chunk', ci + 1, 'extracted', chunkEntities.length, 'entities');
          allExtracted.push(...chunkEntities);
        }
        console.log('INGEST_DEBUG: total extracted across all chunks:', allExtracted.length);

        const now = new Date().toISOString();
        const v2Entities = allExtracted.map(extracted => {
          let entityType = extracted.entity_type;
          if (entityType === 'organization') entityType = 'business';
          if (!entityType || !['person', 'business', 'institution'].includes(entityType)) {
            console.log('INGEST_DEBUG: skipping entity with unknown type:', entityType, extracted.name);
            return null;
          }

          const observations = (extracted.observations || []).map(obs => ({
            observation: (obs.text || '').trim(),
            observed_at: now,
            source: `file_import:${filename}`,
            confidence: 0.6,
            confidence_label: 'MODERATE',
            facts_layer: 'L2_GROUP',
            layer_number: 2,
            observed_by: req.agentId,
          })).filter(o => o.observation);

          const attributes = [];
          if (extracted.attributes && typeof extracted.attributes === 'object') {
            let attrSeq = 1;
            for (const [key, value] of Object.entries(extracted.attributes)) {
              const val = Array.isArray(value) ? value.join(', ') : String(value);
              if (!val) continue;
              attributes.push({
                attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`,
                key, value: val, confidence: 0.6, confidence_label: 'MODERATE',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
              });
            }
          }

          const relationships = [];
          if (Array.isArray(extracted.relationships)) {
            let relSeq = 1;
            for (const rel of extracted.relationships) {
              relationships.push({
                relationship_id: `REL-${String(relSeq++).padStart(3, '0')}`,
                name: rel.name || '', relationship_type: rel.relationship || '', context: rel.context || '',
                sentiment: 'neutral', confidence: 0.6, confidence_label: 'MODERATE',
              });
            }
          }

          const v2Entity = {
            schema_version: '2.0',
            schema_type: 'context_architecture_entity',
            extraction_metadata: {
              extracted_at: now, updated_at: now,
              source_description: `file_import:${filename}`,
              extraction_model: 'claude-sonnet-4-5-20250929',
              extraction_confidence: 0.6, schema_version: '2.0',
            },
            entity: {
              entity_type: entityType,
              name: { ...extracted.name, confidence: 0.6, facts_layer: 2 },
              summary: extracted.summary
                ? { value: extracted.summary, confidence: 0.6, facts_layer: 2 }
                : { value: '', confidence: 0, facts_layer: 2 },
            },
            attributes, relationships,
            values: [], key_facts: [], constraints: [],
            observations,
            provenance_chain: {
              created_at: now, created_by: req.agentId,
              source_documents: [{ source: `file_import:${filename}`, ingested_at: now }],
              merge_history: [],
            },
          };
          if (extracted.relationship_dimensions) {
            if (typeof extracted.relationship_dimensions.strength === 'number') {
              extracted.relationship_dimensions.visual_tier = computeVisualTier(extracted.relationship_dimensions.strength);
            }
            v2Entity.relationship_dimensions = extracted.relationship_dimensions;
            // Compute wiki_page and wiki_section
            var wp = computeWikiPage(extracted.relationship_dimensions);
            v2Entity.wiki_page = wp;
            v2Entity.wiki_section = computeWikiSection(extracted.relationship_dimensions, wp);
          }
          if (extracted.descriptor) v2Entity.descriptor = extracted.descriptor;
          if (extracted.org_dimensions) {
            v2Entity.org_dimensions = extracted.org_dimensions;
            // Add org_category attribute for sidebar compatibility
            if (extracted.org_dimensions.org_category) {
              v2Entity.attributes = v2Entity.attributes || [];
              v2Entity.attributes.push({
                attribute_id: 'ATTR-ORG-CAT',
                key: 'org_category', value: extracted.org_dimensions.org_category,
                confidence: 0.8, confidence_label: 'HIGH',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
              });
            }
          }
          return v2Entity;
        }).filter(Boolean);

        console.log('INGEST_DEBUG: v2Entities after type filter:', v2Entities.length);

        pendingEntities = v2Entities;
      }

      // Stamp spoke_id + source tracking on all pending entities
      for (const ent of pendingEntities) {
        if (!ent.spoke_id) ent.spoke_id = spokeId;
        if (ent.source === undefined) ent.source = 'manual';
        if (ent.source_ref === undefined) ent.source_ref = filename;
      }

      // Preview mode: return entities for user review instead of saving
      if (previewMode) {
        const previewList = pendingEntities.map(e => {
          const ent = e.entity || {};
          const type = ent.entity_type || '';
          return {
            entity_type: type,
            name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
            summary: ent.summary?.value || '',
            attribute_count: (e.attributes || []).length,
            relationship_count: (e.relationships || []).length,
            observation_count: (e.observations || []).length,
          };
        });
        allPreviewEntities.push(...pendingEntities);
        // Stage and score through signal staging layer
        const fileScoredClusters = stageAndScoreExtraction(pendingEntities, {
          type: 'file',
          url: '',
          description: `file_upload:${filename}`,
        }, req.graphDir);
        sendEvent({
          type: 'file_preview',
          file: filename,
          file_index: fi + 1,
          total_files: files.length,
          entities: previewList,
          full_entities: pendingEntities,
          scored_clusters: fileScoredClusters,
        });
      } else {
        result = await ingestPipeline(pendingEntities, req.graphDir, req.agentId, {
          source: pendingSource,
          truthLevel: pendingTruth,
        });

        totalCreated += result.created;
        totalUpdated += result.updated;
        totalObservations += result.observationsAdded;

        const progressEvent = {
          type: 'file_progress',
          file: filename,
          file_index: fi + 1,
          total_files: files.length,
          entities_created: result.created,
          entities_updated: result.updated,
          observations_added: result.observationsAdded,
        };
        if (result.created === 0 && result.updated === 0) {
          progressEvent.warning = 'No named entities found in this file. The file may not contain recognizable person or business names.';
          console.log('INGEST_DEBUG: 0 entities extracted from', filename);
        }
        sendEvent(progressEvent);
      }

    } catch (err) {
      console.error('INGEST_DEBUG: extraction error for', filename, err.message);
      sendEvent({
        type: 'file_error',
        file: filename,
        file_index: fi + 1,
        error: err.message,
      });
    }
  }

  if (previewMode) {
    sendEvent({
      type: 'preview_complete',
      total_entities: allPreviewEntities.length,
    });
  } else {
    // Auto-center detection: if spoke has no centered entity, find the dominant person/business
    if (spokeId !== 'default') {
      try {
        const spoke = getSpoke(req.graphDir, spokeId);
        if (spoke && !spoke.centered_entity_id) {
          // Count entity name frequency from staged clusters in this spoke
          const queue = getReviewQueue(req.graphDir);
          const spokeClusters = queue.filter(c => c.spoke_id === spokeId);
          const nameCounts = {};
          for (const c of spokeClusters) {
            const name = (c.signals?.names || [])[0] || '';
            if (name) nameCounts[name] = (nameCounts[name] || 0) + 1;
          }
          // Also count from entities already in spoke
          const spokeEntities = listEntities(req.graphDir, { spokeId });
          for (const { data } of spokeEntities) {
            const e = data.entity || {};
            const name = e.name?.full || e.name?.common || '';
            if (name && (e.entity_type === 'person' || e.entity_type === 'business')) {
              nameCounts[name] = (nameCounts[name] || 0) + 2; // Weight existing entities higher
            }
          }
          // Find the most frequent
          let bestName = null, bestCount = 0, bestEntityId = null;
          for (const [name, count] of Object.entries(nameCounts)) {
            if (count > bestCount) { bestCount = count; bestName = name; }
          }
          if (bestName) {
            // Try to find matching entity in spoke
            for (const { data } of spokeEntities) {
              const e = data.entity || {};
              const eName = e.name?.full || e.name?.common || '';
              if (eName.toLowerCase() === bestName.toLowerCase()) { bestEntityId = e.entity_id; break; }
            }
            if (bestEntityId) {
              setCenteredEntity(req.graphDir, spokeId, bestEntityId, bestName);
              sendEvent({ type: 'auto_center', spoke_id: spokeId, entity_id: bestEntityId, entity_name: bestName,
                message: `Auto-detected centered entity for spoke: ${bestName}` });
              console.log(`[spoke] Auto-centered ${bestName} (${bestEntityId}) for spoke ${spoke.name}`);
            }
          }
        }
      } catch (err) {
        console.log(`[spoke] Auto-center detection skipped: ${err.message}`);
      }
    }

    sendEvent({
      type: 'complete',
      summary: {
        files_processed: files.length,
        entities_created: totalCreated,
        entities_updated: totalUpdated,
        observations_added: totalObservations,
      },
    });
  }
  res.end();
});

// POST /api/ingest/universal — Universal parser: upload any file, get entities + relationships
// Supports TWO input modes:
//   1. Multipart upload: field "file" (for web UI)
//   2. JSON body: { filename: "doc.pdf", content: "<base64_encoded>" } (for Render API / programmatic)
const universalUpload = multer({ storage: multer.memoryStorage(), limits: { files: 1, fileSize: 50 * 1024 * 1024 } });
app.post('/api/ingest/universal', apiAuth, universalUpload.single('file'), async (req, res) => {
  try {
    let fileBuffer, filename;

    if (req.file) {
      // Mode 1: Multipart file upload
      fileBuffer = req.file.buffer;
      filename = req.file.originalname;
    } else if (req.body && req.body.filename && req.body.content) {
      // Mode 2: JSON body with base64 content
      filename = req.body.filename;
      fileBuffer = Buffer.from(req.body.content, 'base64');
    } else {
      return res.status(400).json({
        error: 'No file provided. Either upload via multipart field "file" or send JSON { filename, content (base64) }.',
      });
    }
    // Optional spoke_id — from JSON body or query param. Auto-creates if needed.
    const rawSpokeId = req.body?.spoke_id || req.query.spoke_id || 'default';
    const spokeId = resolveOrCreateSpoke(req.graphDir, rawSpokeId);

    console.log(`[universal-parser] Processing: ${filename} (${fileBuffer.length} bytes) → spoke: ${spokeId}`);

    // Preserve original source file for provenance
    let fileId = null;
    if (spokeId !== 'default') {
      fileId = preserveSourceFile(req.graphDir, spokeId, filename, fileBuffer);
      console.log(`[provenance] Preserved ${filename} → ${fileId}`);
    }

    // Run universal parser
    const result = await universalParse(fileBuffer, filename);

    // If structured profile or chat export, we can stage directly
    // For AI-extracted entities, convert to signal staging format
    if (result.entities.length > 0 && result.metadata.parse_strategy !== 'chat_import') {
      const now = new Date().toISOString();
      const v2Entities = result.entities.map(ent => {
        const entityType = ent.type === 'PERSON' ? 'person'
          : ent.type === 'ORG' ? 'business'
          : 'business'; // CONCEPT → business for signal staging

        const v2 = {
          schema_version: '2.0',
          schema_type: 'context_architecture_entity',
          extraction_metadata: {
            extracted_at: now,
            updated_at: now,
            source_description: `universal_parser:${filename}`,
            extraction_model: result.metadata.model_used || 'claude-sonnet-4-5-20250929',
            extraction_confidence: ent.confidence || 0.7,
            schema_version: '2.0',
          },
          entity: {
            entity_type: entityType,
            name: { full: ent.name, confidence: ent.confidence || 0.7, facts_layer: 2 },
            summary: { value: ent.evidence || '', confidence: ent.confidence || 0.7, facts_layer: 2 },
          },
          attributes: [],
          relationships: [],
          values: [],
          key_facts: [],
          constraints: [],
          observations: [],
          provenance_chain: {
            created_at: now,
            created_by: req.agentId,
            source_documents: [{ source: `universal_parser:${filename}`, ingested_at: now }],
            merge_history: [],
          },
          spoke_id: spokeId,
          source: 'manual',
          source_ref: filename,
        };

        // Map attributes — handle both new array format and old object format
        if (Array.isArray(ent.attributes)) {
          let seq = 1;
          for (const attr of ent.attributes) {
            const sv = String(attr.value || '');
            if (sv) {
              const evidence = attr.evidence || null;
              const evidType = evidence ? (evidence.type || 'direct') : 'inferred';
              const attrConf = (evidType === 'direct' && evidence) ? Math.max(ent.confidence || 0.7, 0.85) : (ent.confidence || 0.7);
              v2.attributes.push({
                attribute_id: 'ATTR-' + String(seq++).padStart(3, '0'),
                key: attr.key,
                value: sv,
                confidence: attrConf,
                confidence_label: attrConf >= 0.8 ? 'HIGH' : 'MODERATE',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
                provenance: evidence ? {
                  file_id: fileId,
                  original_filename: filename,
                  snippet: evidence.snippet,
                  location: evidence.location,
                  extraction_model: result.metadata.model_used || 'claude-sonnet-4-5-20250929',
                  extraction_type: evidType,
                  extracted_at: now,
                } : null,
              });
            }
          }
        } else if (ent.attributes && typeof ent.attributes === 'object') {
          let seq = 1;
          for (const [k, val] of Object.entries(ent.attributes)) {
            const sv = String(val);
            if (sv) {
              v2.attributes.push({
                attribute_id: 'ATTR-' + String(seq++).padStart(3, '0'),
                key: k,
                value: sv,
                confidence: ent.confidence || 0.7,
                confidence_label: ent.confidence >= 0.8 ? 'HIGH' : 'MODERATE',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
                provenance: null,
              });
            }
          }
        }

        // Map relationships from parser output
        const myRels = result.relationships.filter(r => r.source === ent.name);
        let relSeq = 1;
        for (const r of myRels) {
          v2.relationships.push({
            relationship_id: 'REL-' + String(relSeq++).padStart(3, '0'),
            name: r.target,
            relationship_type: r.relationship,
            context: r.evidence || '',
            sentiment: 'neutral',
            confidence: r.confidence || 0.5,
            confidence_label: r.confidence >= 0.8 ? 'HIGH' : 'MODERATE',
          });
        }

        return v2;
      });

      // Stage through signal staging pipeline
      const scoredClusters = stageAndScoreExtraction(v2Entities, {
        type: 'manual',
        url: '',
        description: `manual_upload:${filename}`,
      }, req.graphDir);

      console.log(`[universal-parser] Staged ${scoredClusters.length} clusters from ${filename}`);

      // Auto-center detection for non-default spokes
      let autoCentered = null;
      if (spokeId !== 'default') {
        try {
          const spoke = getSpoke(req.graphDir, spokeId);
          if (spoke && !spoke.centered_entity_id) {
            // Find most frequent person entity from this extraction
            const personClusters = scoredClusters.filter(c => c.entity_type === 'person');
            if (personClusters.length > 0) {
              const bestCluster = personClusters[0]; // First person entity
              const bestName = (bestCluster.signals?.names || [])[0] || '';
              if (bestName) {
                // Check if there's already a resolved entity matching this name
                const spokeEntities = listEntities(req.graphDir, { spokeId });
                const match = spokeEntities.find(({ data }) => {
                  const n = data.entity?.name?.full || data.entity?.name?.common || '';
                  return n.toLowerCase() === bestName.toLowerCase();
                });
                if (match) {
                  setCenteredEntity(req.graphDir, spokeId, match.data.entity?.entity_id, bestName);
                  autoCentered = { entity_id: match.data.entity?.entity_id, entity_name: bestName };
                  console.log(`[spoke] Auto-centered ${bestName} for spoke ${spoke.name}`);
                }
              }
            }
          }
        } catch (err) {
          console.log(`[spoke] Auto-center detection skipped: ${err.message}`);
        }
      }

      const response = {
        success: true,
        metadata: result.metadata,
        summary: result.summary,
        entities_found: result.entities.length,
        relationships_found: result.relationships.length,
        clusters_staged: scoredClusters.length,
        clusters: scoredClusters.map(c => ({
          cluster_id: c.cluster_id,
          entity_name: (c.signals?.names || [])[0] || '',
          quadrant: c.quadrant,
          confidence: c.confidence,
          state: c.state,
        })),
      };
      if (autoCentered) response.auto_centered = autoCentered;
      return res.json(response);
    }

    // No entities or chat import — return raw result
    return res.json({
      success: true,
      metadata: result.metadata,
      summary: result.summary,
      entities_found: result.entities.length,
      relationships_found: result.relationships.length,
      entities: result.entities,
      relationships: result.relationships,
    });

  } catch (err) {
    console.error('[universal-parser] Error:', err);
    return res.status(500).json({ error: err.message });
  }
});

// POST /api/ingest/confirm — Save user-approved entities from preview
app.post('/api/ingest/confirm', apiAuth, express.json({ limit: '10mb' }), async (req, res) => {
  const { entities, source } = req.body;
  if (!Array.isArray(entities) || entities.length === 0) {
    return res.status(400).json({ error: 'No entities provided' });
  }

  try {
    const result = await ingestPipeline(entities, req.graphDir, req.agentId, {
      source: source || 'confirmed_upload',
      truthLevel: 'INFERRED',
    });
    console.log(`[ingest] Confirmed ${entities.length} entities: ${result.created} created, ${result.updated} updated`);
    res.json(result);
  } catch (err) {
    console.error('[ingest] Confirm error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// --- Signal Staging / Review Queue API ---

// GET /api/review-queue — List unresolved and provisional signal clusters (bundled)
app.get('/api/review-queue', apiAuth, (req, res) => {
  try {
    const bundled = getBundledReviewQueue(req.graphDir);
    // Also include flat clusters for backward compat
    const queue = getReviewQueue(req.graphDir);
    res.json({ clusters: queue, count: queue.length, bundles: bundled.bundles, standalone: bundled.standalone });
  } catch (err) {
    console.error('[review-queue] Error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// POST /api/resolve-bundle — Resolve an extraction event bundle
app.post('/api/resolve-bundle', apiAuth, (req, res) => {
  const { cluster_ids, action, excluded_cluster_ids } = req.body;
  if (!cluster_ids || !Array.isArray(cluster_ids) || !action) {
    return res.status(400).json({ error: 'Missing cluster_ids array or action' });
  }
  if (!['add_to_graph', 'dismiss'].includes(action)) {
    return res.status(400).json({ error: 'Action must be add_to_graph or dismiss' });
  }

  const excluded = new Set(excluded_cluster_ids || []);
  const results = [];
  const errors = [];

  // Sort: person clusters first (primary), then orgs
  const orderedIds = cluster_ids.filter(id => !excluded.has(id));

  for (const cid of orderedIds) {
    try {
      const cluster = readCluster(cid, req.graphDir);
      if (!cluster) { errors.push({ cluster_id: cid, error: 'Not found' }); continue; }

      let clusterAction;
      if (action === 'dismiss') {
        clusterAction = 'skip';
      } else {
        // add_to_graph: use appropriate action based on quadrant
        if (cluster.candidate_entity_id && (cluster.quadrant === 2 || cluster.quadrant === 4)) {
          clusterAction = 'merge';
        } else {
          clusterAction = 'create_new';
        }
      }

      const result = resolveCluster(cid, clusterAction, req.graphDir, req.agentId);
      if (result.error) {
        errors.push({ cluster_id: cid, error: result.error });
      } else {
        results.push(result);
      }
    } catch (err) {
      errors.push({ cluster_id: cid, error: err.message });
    }
  }

  console.log(`[bundle] Resolved ${results.length} clusters (${errors.length} errors) action=${action}`);
  res.json({ action, resolved: results, errors, excluded: [...excluded] });
});

// GET /api/clusters/:id — Get a single signal cluster
app.get('/api/clusters/:id', apiAuth, (req, res) => {
  const cluster = readCluster(req.params.id, req.graphDir);
  if (!cluster) return res.status(404).json({ error: 'Cluster not found' });
  res.json(cluster);
});

// POST /api/clusters/resolve — Resolve a signal cluster
app.post('/api/clusters/resolve', apiAuth, (req, res) => {
  const { cluster_id, action } = req.body;
  if (!cluster_id || !action) {
    return res.status(400).json({ error: 'Missing cluster_id or action' });
  }
  if (!['create_new', 'merge', 'skip', 'hold', 'confirm_merge'].includes(action)) {
    return res.status(400).json({ error: 'Action must be one of: create_new, merge, skip, hold, confirm_merge' });
  }

  try {
    const result = resolveCluster(cluster_id, action, req.graphDir, req.agentId);
    if (result.error) return res.status(400).json(result);
    console.log(`[staging] Resolved cluster ${cluster_id}: action=${action}, result=${JSON.stringify(result)}`);
    res.json(result);
  } catch (err) {
    console.error('[staging] Resolve error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// --- Conflict Resolution ---

app.post('/api/conflicts/resolve', apiAuth, (req, res) => {
  const { entity_id, conflict_id, resolution } = req.body;
  if (!entity_id || !conflict_id || !resolution) {
    return res.status(400).json({ error: 'Missing entity_id, conflict_id, or resolution' });
  }
  if (!['keep_a', 'keep_b', 'keep_both'].includes(resolution)) {
    return res.status(400).json({ error: 'Resolution must be one of: keep_a, keep_b, keep_both' });
  }

  try {
    const result = resolveConflict(entity_id, conflict_id, resolution, req.graphDir);
    if (result.error) return res.status(400).json(result);
    console.log(`[conflicts] Resolved ${conflict_id} on ${entity_id}: ${resolution}`);
    res.json(result);
  } catch (err) {
    console.error('[conflicts] Resolve error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/entity/:id/conflicts', apiAuth, (req, res) => {
  try {
    const entity = readEntity(req.params.id, req.graphDir);
    if (!entity) return res.status(404).json({ error: 'Entity not found' });
    res.json({
      entity_id: req.params.id,
      conflicts: entity.conflicts || [],
      resolved_conflicts: entity.resolved_conflicts || []
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- Google Drive integration ---

// Helper: get tenant's Drive tokens
function getDriveTokens(tenantId) {
  const tenants = loadTenants();
  const tenant = tenants[tenantId];
  if (!tenant) return null;
  return { accessToken: tenant.access_token, refreshToken: tenant.refresh_token, tenant, tenants };
}

function saveDriveToken(tenantId, newAccessToken) {
  const tenants = loadTenants();
  if (tenants[tenantId]) {
    tenants[tenantId].access_token = newAccessToken;
    saveTenants(tenants);
  }
}

// GET /api/drive/files?folderId=X&q=searchterm — List or search Drive files
app.get('/api/drive/files', apiAuth, async (req, res) => {
  const tokens = getDriveTokens(req.tenantId);
  if (!tokens || !tokens.accessToken) {
    return res.status(401).json({ error: 'No Google Drive access. Please sign in with Google.' });
  }

  const folderId = req.query.folderId || null;
  const searchQuery = req.query.q || null;

  try {
    let files;
    if (searchQuery) {
      const r = await drive.withTokenRefresh(
        (token) => drive.searchFiles(token, searchQuery),
        tokens.accessToken,
        tokens.refreshToken,
      );
      files = r.result;
      if (r.newAccessToken) saveDriveToken(req.tenantId, r.newAccessToken);
      res.json({ files, search: searchQuery });
    } else {
      const r = await drive.withTokenRefresh(
        (token) => drive.listFiles(token, folderId),
        tokens.accessToken,
        tokens.refreshToken,
      );
      files = r.result;
      if (r.newAccessToken) saveDriveToken(req.tenantId, r.newAccessToken);
      res.json({ files, folderId: folderId || 'root' });
    }
  } catch (err) {
    console.error('Drive list error:', err.message);
    res.status(500).json({ error: 'Failed to list Drive files: ' + err.message });
  }
});

// POST /api/drive/ingest — Download files from Drive and ingest
app.post('/api/drive/ingest', apiAuth, async (req, res) => {
  console.log('INGEST_DEBUG: drive ingest request, fileIds:', req.body?.fileIds);
  const { fileIds } = req.body;
  if (!Array.isArray(fileIds) || fileIds.length === 0) {
    return res.status(400).json({ error: 'Missing fileIds array' });
  }

  const tokens = getDriveTokens(req.tenantId);
  if (!tokens || !tokens.accessToken) {
    return res.status(401).json({ error: 'No Google Drive access. Please sign in with Google.' });
  }

  let currentToken = tokens.accessToken;
  const primaryUserName = getPrimaryUserName(req.graphDir);

  // Stream NDJSON
  res.setHeader('Content-Type', 'application/x-ndjson');
  res.setHeader('Transfer-Encoding', 'chunked');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.flushHeaders();

  const sendEvent = (event) => res.write(JSON.stringify(event) + '\n');
  sendEvent({ type: 'started', total_files: fileIds.length });

  let totalCreated = 0;
  let totalUpdated = 0;
  let totalObservations = 0;
  const client = new Anthropic();

  for (let fi = 0; fi < fileIds.length; fi++) {
    const fileId = fileIds[fi];
    let filename = fileId;

    try {
      // Download from Drive (with token refresh)
      sendEvent({ type: 'file_downloading', file_index: fi + 1, file_id: fileId });

      const { result: downloaded, newAccessToken } = await drive.withTokenRefresh(
        (token) => drive.downloadFile(token, fileId),
        currentToken,
        tokens.refreshToken,
      );
      if (newAccessToken) {
        currentToken = newAccessToken;
        saveDriveToken(req.tenantId, newAccessToken);
      }

      const { buffer, filename: dlFilename } = downloaded;
      filename = dlFilename;

      // Run through the same parser pipeline as file upload
      const { text, metadata } = await normalizeFileToText(buffer, filename);

      let result;

      if (metadata.isContactList && metadata.rows) {
        const entities = mapContactRows(metadata.rows, filename, req.agentId);
        result = await ingestPipeline(entities, req.graphDir, req.agentId, {
          source: `drive:${filename}`,
          truthLevel: 'STRONG',
        });
      } else if (metadata.isLinkedIn) {
        // LinkedIn PDF auto-detected — Career extraction via signal staging
        console.log(`[ingest] LinkedIn PDF detected (Drive): ${filename}`);
        const prompt = buildLinkedInPrompt(text, filename);
        const message = await client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: 8192,
          messages: [{ role: 'user', content: prompt }],
        });
        const rawResponse = message.content[0].text;
        const cleaned = rawResponse.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
        const parsed = JSON.parse(cleaned);
        const entity = linkedInResponseToEntity(parsed, filename, req.agentId);
        const personName = parsed.name?.full || '';
        const orgEntities = linkedInExperienceToOrgs(parsed, personName, filename, req.agentId);
        const scoredClusters = stageAndScoreExtraction([entity, ...orgEntities], {
          type: 'linkedin_pdf',
          url: '',
          description: `linkedin_pdf:drive:${filename}`,
        }, req.graphDir);
        result = { created: 0, updated: 0, observationsAdded: 0, staged: scoredClusters.length };
      } else {
        const chunks = chunkText(text);
        console.log('INGEST_DEBUG: drive generic text path for', filename, '— text length:', text.length, '— chunks:', chunks.length);

        const allExtracted = [];
        for (let ci = 0; ci < chunks.length; ci++) {
          const prompt = buildGenericTextPrompt(chunks[ci], filename, ci + 1, chunks.length, primaryUserName);
          console.log('INGEST_DEBUG: drive sending chunk', ci + 1, 'of', chunks.length);
          const message = await client.messages.create({
            model: 'claude-sonnet-4-5-20250929',
            max_tokens: 16384,
            messages: [{ role: 'user', content: prompt }],
          });
          const rawResponse = message.content[0].text;
          console.log('INGEST_DEBUG: drive chunk', ci + 1, 'response length:', rawResponse.length);
          const parsed = safeParseExtraction(rawResponse, 'drive chunk ' + (ci + 1));
          const chunkEntities = parsed.entities || [];
          console.log('INGEST_DEBUG: drive chunk', ci + 1, 'extracted', chunkEntities.length, 'entities');
          allExtracted.push(...chunkEntities);
        }
        console.log('INGEST_DEBUG: drive total extracted across all chunks:', allExtracted.length);

        const now = new Date().toISOString();
        const v2Entities = allExtracted.map(extracted => {
          let entityType = extracted.entity_type;
          if (entityType === 'organization') entityType = 'business';
          if (!entityType || !['person', 'business', 'institution'].includes(entityType)) {
            console.log('INGEST_DEBUG: drive skipping entity with unknown type:', entityType, extracted.name);
            return null;
          }

          const observations = (extracted.observations || []).map(obs => ({
            observation: (obs.text || '').trim(),
            observed_at: now,
            source: `drive_import:${filename}`,
            confidence: 0.6,
            confidence_label: 'MODERATE',
            facts_layer: 'L2_GROUP',
            layer_number: 2,
            observed_by: req.agentId,
          })).filter(o => o.observation);

          const attributes = [];
          if (extracted.attributes && typeof extracted.attributes === 'object') {
            let attrSeq = 1;
            for (const [key, value] of Object.entries(extracted.attributes)) {
              const val = Array.isArray(value) ? value.join(', ') : String(value);
              if (!val) continue;
              attributes.push({
                attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`,
                key, value: val, confidence: 0.6, confidence_label: 'MODERATE',
                time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
                source_attribution: { facts_layer: 2, layer_label: 'group' },
              });
            }
          }

          const relationships = [];
          if (Array.isArray(extracted.relationships)) {
            let relSeq = 1;
            for (const rel of extracted.relationships) {
              relationships.push({
                relationship_id: `REL-${String(relSeq++).padStart(3, '0')}`,
                name: rel.name || '', relationship_type: rel.relationship || '', context: rel.context || '',
                sentiment: 'neutral', confidence: 0.6, confidence_label: 'MODERATE',
              });
            }
          }

          return {
            schema_version: '2.0',
            schema_type: 'context_architecture_entity',
            extraction_metadata: {
              extracted_at: now, updated_at: now,
              source_description: `drive_import:${filename}`,
              extraction_model: 'claude-sonnet-4-5-20250929',
              extraction_confidence: 0.6, schema_version: '2.0',
            },
            entity: {
              entity_type: entityType,
              name: { ...extracted.name, confidence: 0.6, facts_layer: 2 },
              summary: extracted.summary
                ? { value: extracted.summary, confidence: 0.6, facts_layer: 2 }
                : { value: '', confidence: 0, facts_layer: 2 },
            },
            attributes, relationships,
            values: [], key_facts: [], constraints: [],
            observations,
            provenance_chain: {
              created_at: now, created_by: req.agentId,
              source_documents: [{ source: `drive_import:${filename}`, ingested_at: now }],
              merge_history: [],
            },
          };
        }).filter(Boolean);

        console.log('INGEST_DEBUG: drive v2Entities after type filter:', v2Entities.length);

        result = await ingestPipeline(v2Entities, req.graphDir, req.agentId, {
          source: `drive:${filename}`,
          truthLevel: 'INFERRED',
        });
      }

      totalCreated += result.created;
      totalUpdated += result.updated;
      totalObservations += result.observationsAdded;

      const progressEvent = {
        type: 'file_progress',
        file: filename,
        file_index: fi + 1,
        total_files: fileIds.length,
        entities_created: result.created,
        entities_updated: result.updated,
        observations_added: result.observationsAdded,
      };
      if (result.created === 0 && result.updated === 0) {
        progressEvent.warning = 'No named entities found in this file. The file may not contain recognizable person or business names.';
        console.log('INGEST_DEBUG: 0 entities extracted from', filename);
      }
      sendEvent(progressEvent);

    } catch (err) {
      console.error('INGEST_DEBUG: drive extraction error for', filename, err.message);
      sendEvent({
        type: 'file_error',
        file: filename,
        file_index: fi + 1,
        error: err.message,
      });
    }
  }

  sendEvent({
    type: 'complete',
    summary: {
      files_processed: fileIds.length,
      entities_created: totalCreated,
      entities_updated: totalUpdated,
      observations_added: totalObservations,
    },
  });
  res.end();
});

// GET /api/entity/:id — Full entity JSON
app.get('/api/entity/:id', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });
  res.json(entity);
});

// GET /api/entity/:id/dossier — Org dossier with connected roles, credentials, skills
app.get('/api/entity/:id/dossier', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const e = entity.entity || {};
  const type = e.entity_type || '';
  if (type !== 'organization' && type !== 'business' && type !== 'institution') {
    return res.status(400).json({ error: 'Dossier only available for organization/business/institution entities' });
  }

  const orgName = (e.name?.common || e.name?.legal || '').toLowerCase();
  const targetId = req.params.id;

  // Find the primary person entity for this tenant (the one with most connected_objects)
  const allEntities = listEntities(req.graphDir);
  let personData = null;
  let maxConnected = 0;
  for (const { data } of allEntities) {
    if ((data.entity || {}).entity_type === 'person') {
      const count = (data.connected_objects || []).length;
      if (count > maxConnected) { maxConnected = count; personData = data; }
    }
  }
  const connectedObjects = personData ? (personData.connected_objects || []) : [];

  // Collect role, credential, and skill entity IDs from person's connected_objects
  const roleRefs = connectedObjects.filter(c => c.entity_type === 'role');
  const credRefs = connectedObjects.filter(c => c.entity_type === 'credential');
  const skillRefs = connectedObjects.filter(c => c.entity_type === 'skill');

  // Read and filter roles that belong to this org
  const roles = [];
  for (const ref of roleRefs) {
    const roleEntity = readEntity(ref.entity_id, req.graphDir);
    if (!roleEntity) continue;
    const rd = roleEntity.role_data || {};
    if (rd.organization_id === targetId) {
      roles.push(roleEntity);
    } else if (orgName && (ref.label || '').toLowerCase().includes(orgName)) {
      roles.push(roleEntity);
    } else if (orgName && (rd.company || '').toLowerCase().includes(orgName)) {
      roles.push(roleEntity);
    }
  }

  // Read and filter credentials that belong to this org
  const credentials = [];
  for (const ref of credRefs) {
    const credEntity = readEntity(ref.entity_id, req.graphDir);
    if (!credEntity) continue;
    const cd = credEntity.credential_data || {};
    if (cd.organization_id === targetId) {
      credentials.push(credEntity);
    } else if (orgName && (ref.label || '').toLowerCase().includes(orgName)) {
      credentials.push(credEntity);
    } else if (orgName && (cd.institution || '').toLowerCase().includes(orgName)) {
      credentials.push(credEntity);
    }
  }

  // Build text corpus from role descriptions + org summary for skill filtering
  const roleText = roles.map(r => (r.role_data?.description || '').toLowerCase()).join(' ');
  const orgText = (entity.entity?.summary?.value || '').toLowerCase();
  const corpus = roleText + ' ' + orgText;

  // Filter skills to those mentioned in role descriptions or org summary
  const skills = [];
  for (const ref of skillRefs) {
    const skillEntity = readEntity(ref.entity_id, req.graphDir);
    if (!skillEntity) continue;
    const sn = (skillEntity.skill_data?.name || '').toLowerCase();
    if (sn && corpus.includes(sn)) {
      skills.push(skillEntity);
    }
  }

  // Sort roles by start_date descending
  roles.sort((a, b) => {
    const aDate = (a.role_data || {}).start_date || '';
    const bDate = (b.role_data || {}).start_date || '';
    return bDate.localeCompare(aDate);
  });

  const industry = (entity.attributes || []).find(a => a.key === 'industry');

  res.json({
    entity: entity.entity || {},
    attributes: entity.attributes || [],
    observations: entity.observations || [],
    roles,
    credentials,
    skills,
    industry: industry ? industry.value : '',
    relationships: entity.relationships || [],
  });
});

// DELETE /api/entity/:id — Delete an entity and its connected objects
app.delete('/api/entity/:id', apiAuth, (req, res) => {
  if (isSelfEntity(req.params.id, req.graphDir)) {
    return res.status(403).json({ error: 'self_entity_protected', message: 'Cannot delete the self entity' });
  }
  const result = deleteEntity(req.params.id, req.graphDir);
  if (!result.deleted) return res.status(404).json({ error: 'Entity not found' });
  console.log(`[delete] Deleted ${req.params.id} + ${result.connected_deleted.length} connected objects`);
  res.json(result);
});

// GET /api/entity/:id/health — Connection intelligence health report
app.get('/api/entity/:id/health', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });
  const health = analyzeEntityHealth(entity);
  res.json({ entity_id: req.params.id, ...health });
});

// GET /api/entity/:id/pipeline — Entity pipeline: Collect/Review/Confirm scoped to entity
app.get('/api/entity/:id/pipeline', apiAuth, (req, res) => {
  const entityId = req.params.id;
  const entity = readEntity(entityId, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const allClusters = getReviewQueue(req.graphDir);
  // Filter clusters associated with this entity
  const entityClusters = allClusters.filter(c => c.candidate_entity_id === entityId);

  // Review: provisional or ambiguous clusters for this entity
  const reviewClusters = entityClusters.filter(c =>
    c.state === 'provisional' || c.ambiguous === true
  );

  // Confirm: high confidence, non-ambiguous provisional clusters ready for one-click
  const confirmClusters = entityClusters.filter(c =>
    c.state === 'provisional' && !c.ambiguous && (c.association_confidence || 0) > 0.6
  );

  // Low confidence attributes
  const attrs = entity.attributes || [];
  const lowConfAttrs = attrs.filter(a => a.confidence != null && a.confidence < 0.5);

  // Active conflicts
  const conflicts = entity.conflicts || [];

  // Recent confirmations from provenance
  const prov = entity.provenance_chain || {};
  const merges = (prov.merge_history || []).slice(-3).reverse();

  res.json({
    entity_id: entityId,
    collect: { pending_count: entityClusters.filter(c => c.state === 'unresolved').length },
    review: {
      clusters: reviewClusters.map(c => ({
        cluster_id: c.cluster_id,
        source_type: c.source?.type || 'unknown',
        name: c.signals?.names?.[0] || c.candidate_entity_name || '',
        association_confidence: c.association_confidence || 0,
        quadrant: c.quadrant,
        quadrant_label: c.quadrant_label || '',
        ambiguous: c.ambiguous || false,
        evidence: c.evidence || [],
        match_zone: c.match_zone || '',
        contradictions: c.contradictions || []
      })),
      conflict_count: conflicts.filter(c => c.conflict_type === 'FACTUAL').length,
      low_confidence_count: lowConfAttrs.length,
      low_confidence_attrs: lowConfAttrs.slice(0, 5).map(a => ({ key: a.key, value: a.value, confidence: a.confidence }))
    },
    confirm: {
      ready_clusters: confirmClusters.map(c => ({
        cluster_id: c.cluster_id,
        source_type: c.source?.type || 'unknown',
        name: c.signals?.names?.[0] || '',
        signal_count: Object.values(c.confident_signals || {}).reduce((sum, v) => sum + (Array.isArray(v) ? v.length : (v ? 1 : 0)), 0),
        association_confidence: c.association_confidence || 0,
        quadrant_label: c.quadrant_label || ''
      })),
      recent_confirmations: merges.map(m => ({
        merged_from: m.merged_from,
        merged_at: m.merged_at,
        changes: m.changes || []
      }))
    }
  });
});

// GET /api/pipeline/global — Global pipeline: all entities
app.get('/api/pipeline/global', apiAuth, (req, res) => {
  const allClusters = getReviewQueue(req.graphDir);
  const reviewClusters = allClusters.filter(c => c.state === 'provisional' || c.ambiguous);
  const confirmClusters = allClusters.filter(c =>
    c.state === 'provisional' && !c.ambiguous && (c.association_confidence || 0) > 0.6
  );
  res.json({
    collect: { pending_count: allClusters.filter(c => c.state === 'unresolved').length },
    review: { clusters: reviewClusters.map(c => ({
      cluster_id: c.cluster_id, source_type: c.source?.type || 'unknown',
      name: c.signals?.names?.[0] || c.candidate_entity_name || '',
      candidate_entity_id: c.candidate_entity_id,
      association_confidence: c.association_confidence || 0,
      quadrant: c.quadrant, quadrant_label: c.quadrant_label || '',
      ambiguous: c.ambiguous || false, evidence: c.evidence || []
    })), count: reviewClusters.length },
    confirm: { ready_clusters: confirmClusters.map(c => ({
      cluster_id: c.cluster_id, source_type: c.source?.type || 'unknown',
      name: c.signals?.names?.[0] || '', signal_count: Object.values(c.confident_signals || {}).reduce((sum, v) => sum + (Array.isArray(v) ? v.length : (v ? 1 : 0)), 0),
      association_confidence: c.association_confidence || 0, quadrant_label: c.quadrant_label || ''
    })), count: confirmClusters.length }
  });
});

// POST /api/dedup-relationships — Retroactively deduplicate relationships across all entities
app.post('/api/dedup-relationships', apiAuth, (req, res) => {
  const { similarity } = require('./merge-engine');
  const allEntities = listEntities(req.graphDir);
  let totalDeduped = 0;
  const changes = [];

  for (const { filename, data } of allEntities) {
    const rels = data.relationships || [];
    if (rels.length < 2) continue;

    const deduped = [];
    for (const rel of rels) {
      const existing = deduped.find(r =>
        similarity(r.name || '', rel.name || '') > 0.85 &&
        normalizeRelationshipType(r.relationship_type) === normalizeRelationshipType(rel.relationship_type)
      );
      if (existing) {
        // Keep the version with more detail
        const existingDetail = (existing.context || '').length + (existing.relationship_type || '').length;
        const relDetail = (rel.context || '').length + (rel.relationship_type || '').length;
        if (relDetail > existingDetail || (rel.confidence || 0) > (existing.confidence || 0)) {
          const oldId = existing.relationship_id;
          Object.assign(existing, rel);
          existing.relationship_id = oldId;
        }
      } else {
        deduped.push({ ...rel });
      }
    }

    const removed = rels.length - deduped.length;
    if (removed > 0) {
      data.relationships = deduped;
      writeEntity(data.entity.entity_id, data, req.graphDir);
      totalDeduped += removed;
      const eName = data.entity.entity_type === 'person'
        ? (data.entity.name?.full || '')
        : (data.entity.name?.common || data.entity.name?.legal || '');
      changes.push({ entity_id: data.entity.entity_id, name: eName, removed });
    }
  }

  console.log(`[dedup] Removed ${totalDeduped} duplicate relationships across ${changes.length} entities`);
  res.json({ total_removed: totalDeduped, entities_affected: changes.length, changes });
});

// POST /api/entities/bulk-delete — Delete multiple entities at once
app.post('/api/entities/bulk-delete', apiAuth, (req, res) => {
  let ids = req.body.entity_ids;
  if (!Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ error: 'entity_ids array is required' });
  }

  // Filter out self entity — never bulk-delete the self entity
  const selfId = getSelfEntityId(req.graphDir);
  if (selfId) ids = ids.filter(id => id !== selfId);

  const results = [];
  let deleted = 0;
  let failed = 0;

  for (const id of ids) {
    const result = deleteEntity(id, req.graphDir);
    if (result.deleted) {
      deleted++;
      results.push({ entity_id: id, deleted: true, connected_deleted: result.connected_deleted.length });
    } else {
      failed++;
      results.push({ entity_id: id, deleted: false });
    }
  }

  console.log(`[bulk-delete] Deleted ${deleted}/${ids.length} entities (${failed} not found)`);
  res.json({ deleted, failed, total: ids.length, results });
});

// POST /api/recategorize — Re-process all person entities with relationship directionality
app.post('/api/recategorize', apiAuth, (req, res) => {
  const allEnts = listEntities(req.graphDir);

  // Find primary person entity (most connected objects)
  let primaryData = null;
  let maxConn = 0;
  for (const { data } of allEnts) {
    if ((data.entity || {}).entity_type === 'person') {
      const count = (data.connected_objects || []).length;
      if (count > maxConn) { maxConn = count; primaryData = data; }
    }
  }

  if (!primaryData) {
    return res.status(400).json({ error: 'No primary person entity found' });
  }

  const primaryId = primaryData.entity.entity_id;
  const primaryName = (primaryData.entity.name?.full || '').toLowerCase();

  // Build relationship map from primary entity's relationships
  const primaryRelMap = {};
  for (const rel of (primaryData.relationships || [])) {
    const rname = (rel.name || '').toLowerCase().trim();
    primaryRelMap[rname] = {
      type: (rel.relationship_type || '').toLowerCase(),
      context: (rel.context || '').toLowerCase(),
      strength: rel.strength || '',
      trust_level: rel.trust_level || '',
    };
    // Also strip parentheticals
    const stripped = rname.replace(/\s*\([^)]*\)/g, '').trim();
    if (stripped && stripped !== rname) primaryRelMap[stripped] = primaryRelMap[rname];
  }

  // Categorization function for a person entity
  // Build primary user's alias list for matching
  const primaryAliases = [primaryName];
  if (primaryData.entity.name?.preferred) primaryAliases.push(primaryData.entity.name.preferred.toLowerCase());
  for (const a of (primaryData.entity.name?.aliases || [])) { primaryAliases.push(a.toLowerCase()); }
  // Also add first name and first+last as aliases
  const pnParts = primaryName.split(/\s+/);
  if (pnParts.length >= 1) primaryAliases.push(pnParts[0]);
  if (pnParts.length >= 2) primaryAliases.push(pnParts[0] + ' ' + pnParts[pnParts.length - 1]);

  // Build spouse name list from primary entity's relationships (for in-law detection)
  const spouseNames = [];
  for (const rel of (primaryData.relationships || [])) {
    const rt = (rel.relationship_type || '').toLowerCase();
    if (rt === 'spouse' || rt === 'wife' || rt === 'husband' || rt === 'current spouse' || rt === 'ex-wife' || rt === 'ex-husband' || rt === 'co-parent') {
      const sn = (rel.name || '').toLowerCase().trim();
      if (sn) {
        spouseNames.push(sn);
        const snParts = sn.split(/\s+/);
        if (snParts.length >= 1) spouseNames.push(snParts[0]);
      }
    }
  }

  function categorizeEntity(data) {
    const e = data.entity || {};
    const eid = e.entity_id;
    if (eid === primaryId) return null; // skip primary

    const name = (e.name?.full || '').toLowerCase().trim();
    const summary = (e.summary?.value || '').toLowerCase();

    // --- Build TARGETED text layers (not a single noisy blob) ---

    // Layer 1: relEntry from CJ's own relationships (MOST reliable — describes CJ→person)
    let relEntry = primaryRelMap[name] || null;
    if (!relEntry) {
      const stripped = name.replace(/\s*\([^)]*\)/g, '').trim();
      if (stripped !== name) relEntry = primaryRelMap[stripped] || null;
    }
    if (!relEntry) {
      const np = name.split(/\s+/);
      if (np.length >= 2) {
        const nf = np[0], nl = np[np.length - 1];
        for (const rk of Object.keys(primaryRelMap)) {
          if (rk.indexOf(nf) !== -1 && rk.indexOf(nl) !== -1) { relEntry = primaryRelMap[rk]; break; }
        }
        if (!relEntry) {
          for (const rk of Object.keys(primaryRelMap)) {
            const rkp = rk.split(/\s+/);
            if (rkp.length >= 2 && name.indexOf(rkp[0]) !== -1 && name.indexOf(rkp[rkp.length - 1]) !== -1) {
              relEntry = primaryRelMap[rk]; break;
            }
          }
        }
      }
    }

    // Layer 2: Entity's own relationships that specifically mention the primary user
    let reverseRelText = '';
    for (const rel of (data.relationships || [])) {
      const rn = (rel.name || '').toLowerCase();
      let mentionsPrimary = false;
      for (const pa of primaryAliases) {
        if (pa && (rn.indexOf(pa) !== -1 || pa.indexOf(rn) !== -1)) { mentionsPrimary = true; break; }
      }
      if (!mentionsPrimary) {
        const rnp = rn.split(/\s+/);
        if (rnp.length >= 2 && primaryName.indexOf(rnp[0]) !== -1 && primaryName.indexOf(rnp[rnp.length - 1]) !== -1) {
          mentionsPrimary = true;
        }
      }
      if (mentionsPrimary) {
        reverseRelText += ' ' + (rel.relationship_type || '') + ' ' + (rel.context || '');
        if (!relEntry) {
          relEntry = { type: (rel.relationship_type || '').toLowerCase(), context: (rel.context || '').toLowerCase(), strength: '', trust_level: '' };
        }
      }
    }

    // Layer 3: Only attributes that explicitly describe relationship TO CJ
    // Exclude 'role' and 'relationship' — they often describe the person's role TO SOMEONE ELSE
    // (e.g., "spouse of Rodrique Fru", "mother of Diamond Loggins")
    let attrText = '';
    for (const attr of (data.attributes || [])) {
      const k = (attr.key || '').toLowerCase();
      if (k === 'relationship_to_cj') {
        attrText += ' ' + (attr.value || '');
      }
    }

    // --- TEXT TIERS ---
    // DIRECT: relEntry + reverse lookup + relationship attributes (HIGH confidence for family)
    const directText = [
      (relEntry ? (relEntry.type + ' ' + relEntry.context) : ''),
      reverseRelText,
      attrText,
    ].join(' ').toLowerCase();

    // PRIMARY: direct + summary (MEDIUM confidence — summary may describe OTHER people's families)
    const primaryText = (directText + ' ' + summary).toLowerCase();

    // BROAD: all attribute values + observations (LOW confidence — only for celebrity detection)
    const broadParts = [summary];
    for (const attr of (data.attributes || [])) {
      broadParts.push((attr.value || ''));
    }
    for (const obs of (data.observations || [])) {
      if (obs.observation) broadParts.push(obs.observation);
    }
    const broadText = broadParts.join(' ').toLowerCase();

    function hasAny(haystack, terms) {
      for (const t of terms) { if (haystack.indexOf(t) !== -1) return t; }
      return null;
    }
    function hasAnyWord(haystack, terms) {
      for (const t of terms) {
        const re = new RegExp('(?:^|\\b)' + t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '(?:\\b|$)', 'i');
        if (re.test(haystack)) return t;
      }
      return null;
    }

    // Check for surrogate/figurative terms — these override family keywords
    const surrogateTerms = ['like a brother', 'like a sister', 'like family', 'surrogate',
      'father figure', 'mother figure', 'big brother figure', 'big sister figure',
      'brother figure', 'sister figure'];
    const isSurrogate = hasAny(directText, surrogateTerms) || hasAny(summary, surrogateTerms);

    // INNER CIRCLE — check FIRST (more specific multi-word terms beat substring false-positives)
    // e.g., "childhood friend" must match before "child" matches for family
    const innerTerms = ['best friend', 'close friend', 'closest friend', 'groomsman', 'bridesmaid',
      'loyalty anchor', 'accountability partner', 'ride or die', 'day one',
      'childhood friend', 'lifelong friend', 'like a brother', 'like a sister',
      'like family', 'brotherhood', 'super close', 'surrogate', 'father figure',
      'mother figure', 'big brother', 'big sister', 'ai assistant', 'collaborator',
      'co-founder', 's-tier', 'a-tier', 'mentee', 'mba homie', 'homie',
      'groomsman', 'trusted', 'accountability'];
    const it = hasAny(primaryText, innerTerms);
    if (it) return { hint: 'friends', rel: it, dist: relEntry ? '1' : '2' };
    if (relEntry) {
      if (relEntry.strength === 'close') return { hint: 'friends', rel: 'strength:close', dist: '1' };
      const tl = String(relEntry.trust_level || '');
      if (tl.indexOf('9') !== -1 || tl.indexOf('10') !== -1) return { hint: 'friends', rel: 'trust:' + tl, dist: '1' };
    }

    // FAMILY — skip if surrogate
    // CRITICAL: Must verify the family keyword is IN RELATION TO CJ, not someone else
    // Strategy: relEntry.type is CJ's DIRECT relationship label (trusted). Context text needs directionality check.
    if (!isSurrogate) {
      const familyTerms = ['spouse', 'wife', 'husband', 'ex-wife', 'ex-husband', 'ex-spouse', 'co-parent',
        'mother', 'father', 'parent', 'mom', 'dad', 'son', 'daughter', 'child',
        'brother', 'sister', 'sibling', 'half-brother', 'half-sister',
        'stepmother', 'stepfather', 'nephew', 'niece', 'uncle', 'aunt', 'cousin',
        'in-law', 'sister-in-law', 'brother-in-law', 'mother-in-law', 'father-in-law',
        'grandparent', 'grandmother', 'grandfather'];

      // Check relEntry.type first — this is CJ's direct relationship label, always trusted
      const relTypeText = relEntry ? (relEntry.type || '').toLowerCase() : '';
      const ftRelType = hasAnyWord(relTypeText, familyTerms);
      if (ftRelType) {
        return { hint: 'family', rel: ftRelType, dist: relEntry ? '1' : '2' };
      }

      // If relEntry.type exists and is NOT a family term, do NOT promote to family from context
      // e.g., "childhood neighbor" with context "same age as CJ's sister" — "sister" describes someone else
      if (!relEntry || !relTypeText) {
        // No relEntry — check directText with directionality guard
        const ft = hasAnyWord(directText, familyTerms);
        if (ft) {
          const ofPattern = new RegExp('(?:spouse|wife|husband|mother|father|sister|brother|daughter|son|parent|child|sibling|nephew|niece|uncle|aunt|cousin|grandmother|grandfather)\\s+of\\s+(\\w[\\w\\s]*)', 'gi');
          let isFamilyOfOther = false;
          let match;
          while ((match = ofPattern.exec(directText)) !== null) {
            const ofWhom = match[1].trim().toLowerCase();
            const isCJ = primaryAliases.some(a => a && ofWhom.indexOf(a) !== -1);
            const isSpouse = spouseNames.some(s => s && ofWhom.indexOf(s) !== -1);
            if (!isCJ && !isSpouse) { isFamilyOfOther = true; break; }
          }
          if (!isFamilyOfOther) {
            const possPattern = /(\w[\w\s]*?)(?:'s|'s)\s+(?:spouse|wife|husband|mother|father|sister|brother|daughter|son|parent|child|sibling|nephew|niece|uncle|aunt|cousin|grandmother|grandfather)/gi;
            while ((match = possPattern.exec(directText)) !== null) {
              const owner = match[1].trim().toLowerCase();
              const isCJ = primaryAliases.some(a => a && owner.indexOf(a) !== -1);
              const isSpouse = spouseNames.some(s => s && owner.indexOf(s) !== -1);
              if (!isCJ && !isSpouse && owner.length > 1) { isFamilyOfOther = true; break; }
            }
          }
          if (!isFamilyOfOther) {
            const friendFamilyPattern = /(?:spouse|wife|husband|mother|father|sister|brother|daughter|son)\s+of\s+(?:a\s+|deceased\s+)?(?:friend|colleague|coworker|associate|peer|buddy)/gi;
            if (friendFamilyPattern.test(directText)) isFamilyOfOther = true;
          }
          if (!isFamilyOfOther) {
            return { hint: 'family', rel: ft, dist: relEntry ? '1' : '2' };
          }
        }
      }
    }

    // PROFESSIONAL — search PRIMARY text (direct + summary)
    const proTerms = ['colleague', 'coworker', 'manager', 'direct report', 'supervisor',
      'mentor', 'business partner', 'professional', 'security architect',
      'from your school', 'employer', 'employee', 'amazon'];
    const pt = hasAny(primaryText, proTerms);
    if (pt) return { hint: 'professional', rel: pt, dist: relEntry ? '1' : '2' };

    // CELEBRITY — search BROAD text, only if no relationship to primary
    if (!relEntry) {
      const celTerms = ['rapper', 'musician', 'artist', 'athlete', 'actor', 'actress',
        'singer', 'public figure', 'celebrity', 'entertainer', 'comedian'];
      const ct = hasAny(broadText, celTerms);
      if (ct) return { hint: 'celebrity', rel: ct, dist: '3' };
    }

    // If we have a relEntry but didn't match any keywords, they're at least connected
    if (relEntry) {
      // Check if relEntry type itself gives a hint
      const relType = relEntry.type || '';
      if (relType && relType !== '3rd degree connection' && relType !== '2nd degree connection') {
        return { hint: 'other', rel: 'connected:' + relType, dist: '1' };
      }
    }

    return { hint: 'other', rel: 'default', dist: relEntry ? '1' : '3' };
  }

  // Process all person entities
  const counts = { family: 0, friends: 0, professional: 0, community: 0, celebrity: 0, other: 0, skipped: 0 };
  const details = [];
  const now = new Date().toISOString();

  for (const { data, file } of allEnts) {
    const e = data.entity || {};
    if (e.entity_type !== 'person') continue;
    if (e.entity_id === primaryId) { counts.skipped++; continue; }

    // Strip old categorization attributes BEFORE categorizing (prevents circular contamination)
    data.attributes = (data.attributes || []).filter(a =>
      a.key !== 'categorization_hint' && a.key !== 'relationship_to_primary' && a.key !== 'relationship_distance'
    );

    const result = categorizeEntity(data);
    if (!result) { counts.skipped++; continue; }

    const eName = e.name?.full || e.entity_id;

    // Build final attributes
    const filtered = data.attributes;

    // Add new ones
    let nextSeq = filtered.length + 1;
    filtered.push({
      attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
      key: 'categorization_hint', value: result.hint,
      confidence: 0.8, confidence_label: 'HIGH',
      time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
      source_attribution: { facts_layer: 1, layer_label: 'recategorize' },
    });
    filtered.push({
      attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
      key: 'relationship_to_primary', value: result.rel,
      confidence: 0.8, confidence_label: 'HIGH',
      time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
      source_attribution: { facts_layer: 1, layer_label: 'recategorize' },
    });
    filtered.push({
      attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
      key: 'relationship_distance', value: result.dist,
      confidence: 0.8, confidence_label: 'HIGH',
      time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
      source_attribution: { facts_layer: 1, layer_label: 'recategorize' },
    });

    data.attributes = filtered;

    // Write back
    writeEntity(e.entity_id, data, req.graphDir);

    counts[result.hint] = (counts[result.hint] || 0) + 1;
    details.push({ entity_id: e.entity_id, name: eName, hint: result.hint, trigger: result.rel, distance: result.dist });
  }

  const total = details.length;
  const summary = `Recategorized ${total} people: Family (${counts.family}), Friends (${counts.friends}), Professional (${counts.professional}), Community (${counts.community}), Celebrity (${counts.celebrity}), Other (${counts.other})`;
  console.log('[recategorize]', summary);

  res.json({ summary, counts, total, details });
});

// POST /api/cleanup-orgs — Delete unaffiliated orgs, merge duplicates, categorize remaining
app.post('/api/cleanup-orgs', apiAuth, (req, res) => {
  const allEnts = listEntities(req.graphDir);

  // --- STEP 1: Delete unaffiliated orgs ---
  const deleteNames = [
    'atlanta community foundation', 'aspen institute', 'brightpath advisory', 'careerbuilder',
    'carnegie mellon university', 'duke university', 'fintech innovations inc',
    'four seasons resort o\'ahu at ko olina', 'four seasons resort oahu at ko olina',
    'google', 'goldman sachs', 'georgia tech', 'georgia tech alumni association',
    'hyatt regency', 'kualoa ranch', 'lyft', 'mckinsey', 'mit', 'meta',
    'newell brands', 'national society of black engineers', 'openai', 'payverse',
    'stripe', 'swiftgo africa', 'spiritual aurora', 'savannah high school',
    'solace therapeutics', 'stanford university', 'studio verde',
    'techbridge atlanta', 'urbannest properties', 'wharton',
    'waikoloa beach marriott resort & spa', 'waikoloa beach marriott resort and spa',
    'testcorp', 'bigtech inc', 'bigtech', 'new hope baptist church',
  ];
  // Also delete known test entities
  const deleteSet = new Set(deleteNames);

  let deleted = 0;
  const deletedList = [];
  for (const { data } of allEnts) {
    const e = data.entity || {};
    const t = e.entity_type || '';
    if (t !== 'organization' && t !== 'business' && t !== 'institution') continue;
    const name = (e.name?.common || e.name?.full || e.name?.legal || '').toLowerCase().trim();
    if (deleteSet.has(name)) {
      const result = deleteEntity(e.entity_id, req.graphDir);
      if (result.deleted) {
        deleted++;
        deletedList.push({ entity_id: e.entity_id, name: e.name?.common || e.name?.full || '' });
      }
    }
  }

  // --- STEP 2: Merge duplicates ---
  const refreshed = listEntities(req.graphDir);
  const mergePairs = [
    { keep: 'amazon', absorb: 'amazon web services' },
    { keep: 'dell emc', absorb: 'emc corporation' },
    { keep: 'clark atlanta university', absorb: 'clark atlanta' },
  ];
  let merged = 0;
  const mergedList = [];
  for (const pair of mergePairs) {
    let keepEnt = null, absorbEnt = null;
    for (const { data } of refreshed) {
      const e = data.entity || {};
      const t = e.entity_type || '';
      if (t !== 'organization' && t !== 'business' && t !== 'institution') continue;
      const name = (e.name?.common || e.name?.full || e.name?.legal || '').toLowerCase().trim();
      if (name === pair.keep && !keepEnt) keepEnt = data;
      if (name === pair.absorb && !absorbEnt) absorbEnt = data;
    }
    if (keepEnt && absorbEnt) {
      // Merge relationships from absorb into keep
      const keepRels = keepEnt.relationships || [];
      const absorbRels = absorbEnt.relationships || [];
      const keepRelNames = new Set(keepRels.map(r => (r.name || '').toLowerCase()));
      for (const rel of absorbRels) {
        if (!keepRelNames.has((rel.name || '').toLowerCase())) {
          keepRels.push(rel);
        }
      }
      keepEnt.relationships = keepRels;
      // Merge observations
      const keepObs = keepEnt.observations || [];
      const absorbObs = absorbEnt.observations || [];
      for (const obs of absorbObs) keepObs.push(obs);
      keepEnt.observations = keepObs;
      // Write updated keep entity
      writeEntity(keepEnt.entity.entity_id, keepEnt, req.graphDir);
      // Delete absorbed entity
      deleteEntity(absorbEnt.entity.entity_id, req.graphDir);
      merged++;
      mergedList.push({ kept: keepEnt.entity.entity_id, absorbed: absorbEnt.entity.entity_id, name: pair.keep });
    }
  }

  // --- STEP 3: Also deduplicate ORG- entities vs BIZ- entities (same org, different IDs) ---
  // e.g., ENT-ORG-001 "Amazon (Relay)" and ENT-BIZ-A-030 "Amazon" — keep both but don't double-count
  // ENT-ORG-005 "Dell EMC" and ENT-BIZ-DE-044 "Dell EMC" — merge
  const refreshed2 = listEntities(req.graphDir);
  const orgsByName = {};
  for (const { data } of refreshed2) {
    const e = data.entity || {};
    const t = e.entity_type || '';
    if (t !== 'organization' && t !== 'business' && t !== 'institution') continue;
    const name = (e.name?.common || e.name?.full || e.name?.legal || '').toLowerCase().trim().replace(/\s*\([^)]*\)/g, '');
    if (!orgsByName[name]) orgsByName[name] = [];
    orgsByName[name].push(data);
  }
  for (const [name, dupes] of Object.entries(orgsByName)) {
    if (dupes.length <= 1) continue;
    // Keep the one with more content (more attributes + observations)
    dupes.sort((a, b) => {
      const sa = (a.attributes || []).length + (a.observations || []).length + (a.relationships || []).length;
      const sb = (b.attributes || []).length + (b.observations || []).length + (b.relationships || []).length;
      return sb - sa;
    });
    const keep = dupes[0];
    for (let i = 1; i < dupes.length; i++) {
      const abs = dupes[i];
      // Merge rels/obs into keep
      const kRels = keep.relationships || [];
      const kRelNames = new Set(kRels.map(r => (r.name || '').toLowerCase()));
      for (const rel of (abs.relationships || [])) {
        if (!kRelNames.has((rel.name || '').toLowerCase())) kRels.push(rel);
      }
      keep.relationships = kRels;
      for (const obs of (abs.observations || [])) (keep.observations || []).push(obs);
      writeEntity(keep.entity.entity_id, keep, req.graphDir);
      deleteEntity(abs.entity.entity_id, req.graphDir);
      merged++;
      mergedList.push({ kept: keep.entity.entity_id, absorbed: abs.entity.entity_id, name });
    }
  }

  // --- STEP 4: Categorize remaining orgs ---
  const refreshed3 = listEntities(req.graphDir);
  // Find primary entity for connected object lookups
  let primaryData = null;
  let maxConn = 0;
  for (const { data } of refreshed3) {
    if ((data.entity || {}).entity_type === 'person') {
      const count = (data.connected_objects || []).length;
      if (count > maxConn) { maxConn = count; primaryData = data; }
    }
  }
  const connected = (primaryData && primaryData.connected_objects) || [];
  // Build role and credential maps by org name
  const roleByName = {};
  const credByName = {};
  for (const c of connected) {
    if (c.entity_type === 'role' && c.label) {
      const atIdx = c.label.indexOf(' at ');
      if (atIdx !== -1) {
        const orgName = c.label.substring(atIdx + 4).trim().toLowerCase();
        const roleTitle = c.label.substring(0, atIdx).trim();
        roleByName[orgName] = roleTitle;
      }
    }
    if (c.entity_type === 'credential' && c.label) {
      const commaIdx = c.label.indexOf(', ');
      if (commaIdx !== -1) {
        const instName = c.label.substring(commaIdx + 2).trim().toLowerCase();
        credByName[instName] = c.label.substring(0, commaIdx).trim();
      }
    }
  }

  // Career hints from known data
  const careerHints = {
    'amazon': { role: 'Principal Product Manager', dates: '2020-present' },
    'amazon (relay)': { role: 'Principal Product Manager', dates: '2020-present' },
    'fandom': { role: 'Senior Product Manager, AI/ML', dates: '2019-2021' },
    'wayfair': { role: 'Associate Director of Product Management', dates: '2017-2019' },
    'dell emc': { role: 'Consultant', dates: '2013-2015' },
    'deloitte': { role: 'Business Technology Analyst', dates: '2011-2013' },
    'deloitte consulting llp': { role: 'Senior Consultant - Data Science & AI', dates: '2011-2013' },
    'instrumental.ly': { role: 'Co-Founder', dates: '2013-2016' },
    'walmart': { role: 'AI/DS Lead', dates: '' },
    'walmart technology': { role: 'AI/DS Lead', dates: '' },
    'flawless tracks': { role: 'Founder', dates: '' },
    'putchuon channel': { role: 'YouTube Creator', dates: '' },
    'self-employed': { role: 'Context Architecture Consultant', dates: '' },
  };
  const educationHints = {
    'howard university': { credential: 'BBA', year: '2005' },
    'clark atlanta university': { credential: 'MBA', year: '2012' },
    'harvard university': { credential: 'MBA', year: '' },
    'harvard business school': { credential: 'MBA', year: '' },
    'thornwood high school': { credential: 'Diploma', year: '' },
  };
  const serviceHints = new Set([
    'carl e. sanders ymca', 'carl e. sanders ymca, buckhead',
    'kaiser permanente', 'jpmorgan chase', 'fulton county court',
  ]);

  const categorized = { career: 0, education: 0, affiliations: 0, services: 0 };
  const catDetails = [];
  const now = new Date().toISOString();

  for (const { data } of refreshed3) {
    const e = data.entity || {};
    const t = e.entity_type || '';
    if (t !== 'organization' && t !== 'business' && t !== 'institution') continue;
    const name = (e.name?.common || e.name?.full || e.name?.legal || '').toLowerCase().trim();
    const nameClean = name.replace(/\s*\([^)]*\)/g, '').trim();

    // Determine category
    let orgCat = 'affiliations'; // default
    let catMeta = {};

    if (careerHints[name] || careerHints[nameClean]) {
      orgCat = 'career';
      catMeta = careerHints[name] || careerHints[nameClean];
    } else if (roleByName[name] || roleByName[nameClean]) {
      orgCat = 'career';
      catMeta = { role: roleByName[name] || roleByName[nameClean] };
    } else if (educationHints[name] || educationHints[nameClean]) {
      orgCat = 'education';
      catMeta = educationHints[name] || educationHints[nameClean];
    } else if (credByName[name] || credByName[nameClean]) {
      orgCat = 'education';
      catMeta = { credential: credByName[name] || credByName[nameClean] };
    } else if (serviceHints.has(name) || serviceHints.has(nameClean)) {
      orgCat = 'services';
    }

    // Strip old org_category attributes and write new one
    data.attributes = (data.attributes || []).filter(a =>
      a.key !== 'org_category' && a.key !== 'cj_role' && a.key !== 'cj_dates' && a.key !== 'cj_credential' && a.key !== 'cj_grad_year'
    );
    let nextSeq = data.attributes.length + 1;
    data.attributes.push({
      attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
      key: 'org_category', value: orgCat,
      confidence: 0.9, confidence_label: 'HIGH',
      time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
      source_attribution: { facts_layer: 1, layer_label: 'cleanup-orgs' },
    });
    if (catMeta.role) {
      data.attributes.push({
        attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
        key: 'cj_role', value: catMeta.role,
        confidence: 0.9, confidence_label: 'HIGH',
        time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
        source_attribution: { facts_layer: 1, layer_label: 'cleanup-orgs' },
      });
    }
    if (catMeta.dates) {
      data.attributes.push({
        attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
        key: 'cj_dates', value: catMeta.dates,
        confidence: 0.9, confidence_label: 'HIGH',
        time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
        source_attribution: { facts_layer: 1, layer_label: 'cleanup-orgs' },
      });
    }
    if (catMeta.credential) {
      data.attributes.push({
        attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
        key: 'cj_credential', value: catMeta.credential,
        confidence: 0.9, confidence_label: 'HIGH',
        time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
        source_attribution: { facts_layer: 1, layer_label: 'cleanup-orgs' },
      });
    }
    if (catMeta.year) {
      data.attributes.push({
        attribute_id: `ATTR-${String(nextSeq++).padStart(3, '0')}`,
        key: 'cj_grad_year', value: catMeta.year,
        confidence: 0.9, confidence_label: 'HIGH',
        time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
        source_attribution: { facts_layer: 1, layer_label: 'cleanup-orgs' },
      });
    }
    writeEntity(e.entity_id, data, req.graphDir);
    categorized[orgCat]++;
    catDetails.push({ entity_id: e.entity_id, name: e.name?.common || e.name?.full || '', category: orgCat, role: catMeta.role || '', credential: catMeta.credential || '' });
  }

  const total = catDetails.length;
  const summary = `Deleted ${deleted} orgs, merged ${merged} pairs, categorized ${total} remaining: Career (${categorized.career}), Education (${categorized.education}), Affiliations (${categorized.affiliations}), Services (${categorized.services})`;
  console.log('[cleanup-orgs]', summary);
  console.log('[cleanup-orgs] Remaining orgs:');
  for (const d of catDetails) console.log(`  [${d.category}] ${d.name} (${d.entity_id})${d.role ? ' — ' + d.role : ''}${d.credential ? ' — ' + d.credential : ''}`);

  res.json({ summary, deleted: deletedList, merged: mergedList, categorized: catDetails, counts: categorized });
});

// Progress tracking for generate-dimensions
let dimProgress = null;

function computeVisualTier(strength) {
  if (strength >= 0.85) return 'gold';
  if (strength >= 0.65) return 'green';
  if (strength >= 0.30) return 'neutral';
  return 'muted';
}

/**
 * Post-extraction validation for relationships.
 * Removes self-references and deduplicates by target name.
 */
function validateRelationships(relationships, entityName, preferredName, aliases) {
  if (!Array.isArray(relationships) || relationships.length === 0) return relationships;

  // Build set of self-names to filter
  const selfNames = new Set();
  if (entityName) selfNames.add(entityName.toLowerCase().trim());
  if (preferredName) selfNames.add(preferredName.toLowerCase().trim());
  if (Array.isArray(aliases)) {
    for (const a of aliases) {
      if (a) selfNames.add(a.toLowerCase().trim());
    }
  }

  // Remove self-references
  let filtered = relationships.filter(r => {
    const name = (r.name || '').toLowerCase().trim();
    return name && !selfNames.has(name);
  });

  // Deduplicate by target name — merge descriptions, keep more specific type
  const seen = new Map();
  const deduped = [];
  for (const rel of filtered) {
    const key = (rel.name || '').toLowerCase().trim();
    if (seen.has(key)) {
      const existing = seen.get(key);
      // Merge context
      if (rel.context && (!existing.context || rel.context.length > existing.context.length)) {
        existing.context = rel.context;
      }
      // Keep more specific relationship type
      if (rel.relationship && (!existing.relationship_type || rel.relationship.length > (existing.relationship_type || '').length)) {
        existing.relationship_type = rel.relationship || rel.relationship_type;
      }
    } else {
      if (rel.relationship && !rel.relationship_type) {
        rel.relationship_type = rel.relationship;
      }
      seen.set(key, rel);
      deduped.push(rel);
    }
  }

  return deduped;
}

// Server-side page/section assignment — mirrors frontend getPage/getFamilySection/getFriendsSection/getProfessionalSection
function computeWikiPage(dims) {
  if (!dims || !dims.connection_type) return 'other';
  if (dims.connection_type === 'blood' || dims.connection_type === 'marriage') {
    if (!dims.connected_through) return 'family';
    if (dims.connection_type === 'blood') return 'family';
    if (dims.connection_type === 'marriage' && dims.sub_role === 'in_law') return 'family';
    if (dims.connection_type === 'marriage' && dims.connected_through) return 'other';
    return 'family';
  }
  if (dims.connected_through && (dims.strength || 0) < 0.30) return 'other';
  if (dims.connection_type === 'chosen') return 'friends';
  if (dims.connection_type === 'professional') return 'professional';
  if (dims.connection_type === 'community') return 'other';
  return 'other';
}

function computeWikiSection(dims, page) {
  if (!dims) return '';
  if (page === 'family') {
    if (dims.sub_role === 'spouse') return 'Spouse';
    if (dims.sub_role === 'child') return 'Children';
    if (dims.sub_role === 'parent' || dims.sub_role === 'sibling' || dims.sub_role === 'grandparent') return 'Parents & Siblings';
    return 'Extended Family';
  }
  if (page === 'friends') {
    var str = dims.strength || 0;
    if (str >= 0.85) return 'Inner Circle';
    if (str >= 0.65) return 'Close Friends';
    if (str >= 0.40) return 'Friends';
    return 'Acquaintances';
  }
  if (page === 'professional') {
    if (dims.sub_role === 'partner') return 'Partners';
    if (dims.status === 'active' || dims.status === 'stable') return 'Current';
    return 'Former';
  }
  return '';
}

// GET /api/generate-dimensions/status — Progress tracking
app.get('/api/generate-dimensions/status', apiAuth, (req, res) => {
  if (!dimProgress) return res.json({ running: false });
  res.json(dimProgress);
});

// POST /api/generate-dimensions — Bulk-generate relationship_dimensions and org_dimensions via LLM
app.post('/api/generate-dimensions', apiAuth, async (req, res) => {
  if (dimProgress && dimProgress.running) {
    return res.status(409).json({ error: 'Migration already in progress', progress: dimProgress });
  }

  try {
    const entities = listEntities(req.graphDir);

    // 1. Find primary person entity (most connected objects)
    let primaryEntity = null;
    let maxConn = 0;
    for (const { data } of entities) {
      if ((data.entity || {}).entity_type === 'person') {
        const count = (data.connected_objects || []).length;
        if (count > maxConn) { maxConn = count; primaryEntity = data; }
      }
    }
    if (!primaryEntity) return res.status(400).json({ error: 'No primary person entity found' });

    const primaryName = primaryEntity.entity.name?.full || primaryEntity.entity.name?.preferred || '';
    const primaryId = primaryEntity.entity.entity_id;
    const primarySummary = primaryEntity.entity.summary?.value || '';

    // Build primary context: relationship map + nicknames
    const primaryRelMap = {};
    for (const rel of (primaryEntity.relationships || [])) {
      primaryRelMap[rel.name || ''] = { type: rel.relationship_type || '', context: rel.context || '' };
    }

    // 2. Separate persons vs orgs (exclude primary)
    const persons = [];
    const orgs = [];
    for (const { data } of entities) {
      const e = data.entity || {};
      const eid = e.entity_id;
      if (eid === primaryId) continue;
      if (e.entity_type === 'person') {
        persons.push(data);
      } else if (e.entity_type === 'organization' || e.entity_type === 'business' || e.entity_type === 'institution') {
        orgs.push(data);
      }
    }

    const client = new Anthropic();
    const errors = [];
    const peopleSummary = { family: [], friends: [], professional: [], other: [] };
    const orgsSummary = { career: [], education: [], affiliations: [], services: [], deleted: [] };
    const tierCounts = { gold: 0, green: 0, neutral: 0, muted: 0 };
    const startTime = Date.now();

    dimProgress = {
      running: true,
      phase: 'people',
      current: 0,
      total: persons.length + orgs.length,
      people_total: persons.length,
      orgs_total: orgs.length,
      people_processed: 0,
      orgs_processed: 0,
      orgs_deleted: 0,
      started_at: new Date().toISOString(),
      errors: [],
    };

    // === PERSON SYSTEM PROMPT ===
    const personSystemPrompt = `You are analyzing a person entity from a knowledge graph. The PRIMARY USER of this graph is ${primaryName}. Every person must be scored in relationship TO ${primaryName}.
${primarySummary ? `\nAbout ${primaryName}: ${primarySummary}\n` : ''}
Given each person's entity data below, answer these questions and return a JSON array with one object per person.

QUESTIONS:

1. connection_type — How is this person connected to ${primaryName}?
   Pick ONE:
   - "blood": biological or legally adopted family (parent, child, sibling, cousin, grandparent, aunt, uncle, nephew, niece, half-sibling)
   - "marriage": connected through a marriage, current or former (spouse, ex-spouse, in-law, step-relative)
   - "chosen": voluntary personal relationship (friend, best friend, mentor, mentee, confidant, surrogate sibling)
   - "professional": work or business relationship (colleague, manager, report, client, business partner)
   - "community": shared context or proximity, not individual bond (classmate, neighbor, fellow member)

2. access — How much vulnerability would ${primaryName} extend to this person? Score 0.00 to 1.00.
   Calibration probes (scoring aids, not definitions):
   0.90-1.00: Unrestricted trust. Would trust them alone with his child for a week? Give them home and car keys as first option? Hand them his unlocked phone without a second thought?
   0.70-0.89: High trust. Would call them at 3am in an emergency? Share something vulnerable? Ask for a significant favor and expect them to show up?
   0.50-0.69: Mutual trust. Has their direct contact? Reaching out would be normal and welcomed? Would help each other without hesitation if asked?
   0.30-0.49: Contextual trust. Would engage warmly in a shared setting but not reach out independently? Relationship exists within a container (group, event, mutual friend)?
   0.10-0.29: Recognition. Knows who they are. Maybe met once or twice. No real trust, just awareness.
   0.01-0.09: One-directional. Knows OF them but no mutual awareness. Parasocial or purely observational.
   Use the EVIDENCE in the entity data to score.

3. connected_through — Is this a direct relationship with ${primaryName}, or through someone else?
   Return null if direct (${primaryName} has an independent relationship with this person).
   Return the bridge person/group/org name if indirect.
   CRITICAL RULES:
   - If described as "spouse of [someone who is NOT ${primaryName}]", connected through that person. NOT ${primaryName}'s family.
   - If described as "[someone]'s [relative]" where [someone] is not ${primaryName}, connected through that person.
   - EXCEPTION: If connected_through is ${primaryName}'s CURRENT SPOUSE and connection_type is blood, this person is an in-law. Still return the spouse name as connected_through.
   - If they originally met ${primaryName} through someone but NOW have a fully independent relationship, return null. Origin story goes in descriptor, not connected_through.

4. status — What is the current energy of this relationship?
   Pick ONE:
   - "active": regular engagement, relationship generating contact
   - "stable": solid but doesn't need regular contact. It just IS. Would re-engage instantly.
   - "passive": no regular contact, zero animosity. Dormant, not dead.
   - "diminishing": actively fading. Less contact over time. Trending toward inactive.
   - "inactive": effectively ended. No contact, no expectation of contact. Not hostile, just done.
   - "estranged": active negative state. Conflict, avoidance, or unresolved tension.
   - "deceased": person has passed away.
   - "complicated": multiple simultaneous states. ALWAYS explain in descriptor when using this.

5. strength — How much would ${primaryName}'s life change without this person? Score 0.00 to 1.00.
   Calibration probes:
   0.90-1.00: Life-altering. Daily existence changes fundamentally. The 5-7 people who anchor life.
   0.75-0.89: Significant. Felt deeply at key moments — holidays, milestones, hard decisions.
   0.50-0.74: Meaningful. Would miss them, think of them. Daily life continues unchanged.
   0.30-0.49: Mild. Would notice eventually if prompted. Latent goodwill.
   0.10-0.29: Negligible. Memory, not active life.
   0.01-0.09: None. Cultural awareness only.
   IMPORTANT: Strength is independent of access. A deceased person can have access 0.00 but strength 0.90 (deeply missed). Don't conflate reachability with impact. Don't inflate based on connection_type alone. Not all siblings are close. Not all colleagues are distant. Use the EVIDENCE.

6. sub_role — What specific role does this person play? Pick the MOST SPECIFIC:
   Family: spouse | child | parent | grandparent | sibling | uncle | aunt | cousin | in_law | extended
   Friends: friend | mentor | mentee | confidant | surrogate_sibling | surrogate_parent
   Professional: colleague | manager | report | partner | client | vendor
   Community: classmate | neighbor | member | acquaintance
   Other: influence (parasocial/cultural)

7. descriptor — Write a 4-8 word phrase that completes "That's my ___" in how ${primaryName} would naturally introduce this person.
   Rules:
   - Use the person's NICKNAME if one exists in the data (Honeyman not Zebedee, Chiefe not Ryan, Big Al not Allen, Ro not Rodrique)
   - High access (0.70+): [qualifier] + [relationship] + [origin]. "best friend from the block"
   - Moderate access (0.40-0.69): [context-first]. "Justin's wife, always cordial"
   - Low access (<0.40): [connection path only]. "old acquaintance from Markham"
   - Deceased: use "late" naturally. "late best friend from the block"
   - Former: include transition + ongoing connection. "ex-wife, London's mother"
   - Complicated: name the layers. "ex-wife, London's mother, complicated history"
   - For indirect relationships: use bridge person's NICKNAME. "Ro's wife" not "Rodrique Fru's wife"

Return ONLY a valid JSON array, no markdown fences, no commentary:
[{"entity_id":"...","connection_type":"...","access":0.82,"connected_through":null,"status":"active","strength":0.85,"sub_role":"friend","descriptor":"close friend, came through Tone originally"}]`;

    // === ORG SYSTEM PROMPT ===
    const orgSystemPrompt = `You are analyzing organization entities from a knowledge graph. The PRIMARY USER is ${primaryName}.
${primarySummary ? `\nAbout ${primaryName}: ${primarySummary}\n` : ''}
Determine ${primaryName}'s relationship to each organization below.

If ${primaryName} has NO direct relationship to this org (it was mentioned in someone else's bio, or is a general reference), return: {"entity_id":"...","relationship_to_primary":"none"}

Otherwise return:
{
  "entity_id": "...",
  "relationship_to_primary": "employer|alma_mater|membership|service_provider",
  "org_category": "career|education|affiliations|services",
  "org_status": "current|former",
  "primary_user_role": "Principal Product Manager",
  "org_dates": "2020-present",
  "org_descriptor": "current employer, AI forecasting"
}

Rules:
- "employer" → org_category "career"
- "alma_mater" → org_category "education"
- "membership" (fraternity, church, community org, professional assoc) → org_category "affiliations"
- "service_provider" (healthcare, banking, insurance, legal) → org_category "services"
- "none" → this org should be flagged for deletion (not relevant to ${primaryName})

Return ONLY a valid JSON array, no markdown fences, no commentary.`;

    // 3. Process persons in batches of 5
    const personBatches = [];
    for (let i = 0; i < persons.length; i += 5) {
      personBatches.push(persons.slice(i, i + 5));
    }

    for (let bi = 0; bi < personBatches.length; bi++) {
      const batch = personBatches[bi];
      try {
        const personDescriptions = batch.map(data => {
          const e = data.entity || {};
          const name = e.name?.full || '';
          const nickname = e.name?.preferred || e.name?.nickname || '';
          const summary = e.summary?.value || '';
          const attrs = (data.attributes || []).map(a => `${a.key}: ${a.value}`).join('; ');
          const rels = (data.relationships || []).map(r => `${r.name} (${r.relationship_type}): ${r.context || ''}`).join('; ');
          const obs = (data.observations || []).slice(0, 5).map(o => o.content || o.text || '').join('; ');
          const relMapEntry = primaryRelMap[name] || null;
          const relMapText = relMapEntry ? `Primary user's relationship entry: type="${relMapEntry.type}", context="${relMapEntry.context}"` : 'No direct relationship entry from primary user';
          return `PERSON: entity_id="${e.entity_id}", name="${name}"${nickname ? `, nickname="${nickname}"` : ''}
Summary: ${summary}
Attributes: ${attrs}
Relationships: ${rels}
Observations (first 5): ${obs}
${relMapText}`;
        }).join('\n\n---\n\n');

        const message = await client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: 16384,
          messages: [
            { role: 'user', content: `Analyze these persons:\n\n${personDescriptions}` },
          ],
          system: personSystemPrompt,
        });

        const responseText = message.content[0].text.trim();
        let dimensions;
        try {
          dimensions = JSON.parse(responseText);
        } catch {
          const jsonMatch = responseText.match(/\[[\s\S]*\]/);
          dimensions = jsonMatch ? JSON.parse(jsonMatch[0]) : [];
        }

        // Write results to entity files
        for (const dim of dimensions) {
          const entityData = batch.find(d => (d.entity || {}).entity_id === dim.entity_id);
          if (!entityData) continue;

          // Compute visual_tier from strength
          const strength = typeof dim.strength === 'number' ? dim.strength : 0.5;
          const access = typeof dim.access === 'number' ? dim.access : 0.5;
          const visualTier = computeVisualTier(strength);

          const relDims = {
            connection_type: dim.connection_type,
            access: Math.round(access * 100) / 100,
            connected_through: dim.connected_through || null,
            status: dim.status,
            strength: Math.round(strength * 100) / 100,
            sub_role: dim.sub_role,
            descriptor: dim.descriptor || '',
            descriptor_origin: dim.descriptor_origin || '',
            visual_tier: visualTier,
          };

          entityData.relationship_dimensions = relDims;
          entityData.descriptor = dim.descriptor || '';

          // Strip old categorization attributes
          if (entityData.attributes) {
            entityData.attributes = entityData.attributes.filter(a =>
              a.key !== 'categorization_hint' && a.key !== 'relationship_to_primary' && a.key !== 'relationship_distance'
            );
          }

          writeEntity(dim.entity_id, entityData, req.graphDir);
          tierCounts[visualTier] = (tierCounts[visualTier] || 0) + 1;

          // Categorize for summary using new getPage logic
          const name = (entityData.entity || {}).name?.full || '';
          const ct = relDims.connection_type;
          const connThrough = relDims.connected_through;
          if (ct === 'blood' || ct === 'marriage') {
            if (!connThrough || ct === 'blood') {
              peopleSummary.family.push(name);
            } else {
              peopleSummary.other.push(name);
            }
          } else if (ct === 'chosen' && access >= 0.30) {
            peopleSummary.friends.push(name);
          } else if (ct === 'professional' && access >= 0.30) {
            peopleSummary.professional.push(name);
          } else {
            peopleSummary.other.push(name);
          }
        }

        dimProgress.people_processed += dimensions.length;
        dimProgress.current = dimProgress.people_processed;
        console.log(`[generate-dimensions] Person batch ${bi + 1}/${personBatches.length}: processed ${dimensions.length} persons`);
      } catch (err) {
        console.error(`[generate-dimensions] Person batch ${bi + 1} error:`, err.message);
        errors.push(`Person batch ${bi + 1}: ${err.message}`);
        dimProgress.errors.push(`Person batch ${bi + 1}: ${err.message}`);
      }
    }

    // 4. Process orgs in batches of 5
    dimProgress.phase = 'orgs';
    const orgBatches = [];
    for (let i = 0; i < orgs.length; i += 5) {
      orgBatches.push(orgs.slice(i, i + 5));
    }

    for (let bi = 0; bi < orgBatches.length; bi++) {
      const batch = orgBatches[bi];
      try {
        const orgDescriptions = batch.map(data => {
          const e = data.entity || {};
          const name = e.name?.common || e.name?.full || e.name?.legal || '';
          const summary = e.summary?.value || '';
          const attrs = (data.attributes || []).map(a => `${a.key}: ${a.value}`).join('; ');
          const rels = (data.relationships || []).map(r => `${r.name} (${r.relationship_type}): ${r.context || ''}`).join('; ');
          return `ORG: entity_id="${e.entity_id}", name="${name}", type="${e.entity_type}"
Summary: ${summary}
Attributes: ${attrs}
Relationships: ${rels}`;
        }).join('\n\n---\n\n');

        const message = await client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: 16384,
          messages: [
            { role: 'user', content: `Analyze these organizations:\n\n${orgDescriptions}` },
          ],
          system: orgSystemPrompt,
        });

        const responseText = message.content[0].text.trim();
        let dimensions;
        try {
          dimensions = JSON.parse(responseText);
        } catch {
          const jsonMatch = responseText.match(/\[[\s\S]*\]/);
          dimensions = jsonMatch ? JSON.parse(jsonMatch[0]) : [];
        }

        for (const dim of dimensions) {
          const entityData = batch.find(d => (d.entity || {}).entity_id === dim.entity_id);
          if (!entityData) continue;

          const name = (entityData.entity || {}).name?.common || (entityData.entity || {}).name?.full || '';

          // Flag for deletion if "none"
          if (dim.relationship_to_primary === 'none') {
            orgsSummary.deleted.push(name);
            dimProgress.orgs_deleted++;
            // Mark entity for deletion (add attribute, don't delete yet)
            if (!entityData.attributes) entityData.attributes = [];
            entityData.attributes.push({ key: 'flagged_for_deletion', value: 'true', source: 'generate-dimensions' });
            writeEntity(dim.entity_id, entityData, req.graphDir);
            continue;
          }

          const orgDims = {
            relationship_to_primary: dim.relationship_to_primary,
            org_category: dim.org_category,
            org_status: dim.org_status,
            primary_user_role: dim.primary_user_role || '',
            org_dates: dim.org_dates || '',
            org_descriptor: dim.org_descriptor || '',
          };

          entityData.org_dimensions = orgDims;
          entityData.descriptor = dim.org_descriptor || '';

          // Also set org_category attribute for sidebar compatibility
          if (entityData.attributes) {
            const catAttr = entityData.attributes.find(a => a.key === 'org_category');
            if (catAttr) {
              catAttr.value = dim.org_category;
            } else {
              entityData.attributes.push({ key: 'org_category', value: dim.org_category, source: 'generate-dimensions' });
            }
          }

          writeEntity(dim.entity_id, entityData, req.graphDir);

          const cat = dim.org_category || 'services';
          if (orgsSummary[cat]) {
            orgsSummary[cat].push(name);
          } else {
            orgsSummary.services.push(name);
          }
        }

        dimProgress.orgs_processed += dimensions.length;
        dimProgress.current = dimProgress.people_processed + dimProgress.orgs_processed;
        console.log(`[generate-dimensions] Org batch ${bi + 1}/${orgBatches.length}: processed ${dimensions.length} orgs`);
      } catch (err) {
        console.error(`[generate-dimensions] Org batch ${bi + 1} error:`, err.message);
        errors.push(`Org batch ${bi + 1}: ${err.message}`);
        dimProgress.errors.push(`Org batch ${bi + 1}: ${err.message}`);
      }
    }

    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    const summaryText = `Generated dimensions for ${persons.length} people, ${orgs.length} orgs in ${elapsed}s`;
    console.log('[generate-dimensions]', summaryText);

    dimProgress.running = false;
    dimProgress.completed_at = new Date().toISOString();
    dimProgress.phase = 'done';

    res.json({
      summary: summaryText,
      people: peopleSummary,
      orgs: orgsSummary,
      tiers: tierCounts,
      errors,
    });
  } catch (err) {
    console.error('[generate-dimensions] Fatal error:', err);
    dimProgress = { running: false, error: err.message };
    res.status(500).json({ error: err.message });
  }
});

// POST /api/merge-entities — Merge two entities into one
app.post('/api/merge-entities', apiAuth, (req, res) => {
  const { primary_id, secondary_id, name_override, nickname_additions, descriptor_override } = req.body;
  if (!primary_id || !secondary_id) return res.status(400).json({ error: 'primary_id and secondary_id required' });
  if (primary_id === secondary_id) return res.status(400).json({ error: 'Cannot merge entity with itself' });

  const primary = readEntity(primary_id, req.graphDir);
  const secondary = readEntity(secondary_id, req.graphDir);
  if (!primary) return res.status(404).json({ error: 'Primary entity not found: ' + primary_id });
  if (!secondary) return res.status(404).json({ error: 'Secondary entity not found: ' + secondary_id });

  const now = new Date().toISOString();
  const changes = [];

  // Merge name: optionally override, add nicknames
  if (name_override && primary.entity) {
    if (primary.entity.entity_type === 'person') {
      primary.entity.name.full = name_override;
    } else {
      primary.entity.name.common = name_override;
    }
    changes.push('name overridden to: ' + name_override);
  }
  if (nickname_additions && primary.entity && primary.entity.name) {
    if (!primary.entity.name.aliases) primary.entity.name.aliases = [];
    for (const nick of nickname_additions) {
      if (!primary.entity.name.aliases.includes(nick)) {
        primary.entity.name.aliases.push(nick);
      }
    }
    changes.push('added aliases: ' + nickname_additions.join(', '));
  }

  // Merge summary: keep primary unless secondary is longer
  if (secondary.entity && secondary.entity.summary && primary.entity) {
    const pLen = (primary.entity.summary?.value || '').length;
    const sLen = (secondary.entity.summary?.value || '').length;
    if (sLen > pLen) {
      primary.entity.summary = secondary.entity.summary;
      changes.push('kept longer summary from secondary');
    }
  }

  // Override descriptor if provided
  if (descriptor_override) {
    primary.descriptor = descriptor_override;
    changes.push('descriptor overridden');
  }

  // Merge attributes (skip duplicates by key)
  const existingKeys = new Set((primary.attributes || []).map(a => a.key));
  for (const attr of (secondary.attributes || [])) {
    if (!existingKeys.has(attr.key)) {
      (primary.attributes = primary.attributes || []).push(attr);
      existingKeys.add(attr.key);
      changes.push('added attribute: ' + attr.key);
    }
  }

  // Merge relationships (skip duplicates by name)
  const existingRelNames = new Set((primary.relationships || []).map(r => (r.name || '').toLowerCase()));
  for (const rel of (secondary.relationships || [])) {
    if (!existingRelNames.has((rel.name || '').toLowerCase())) {
      (primary.relationships = primary.relationships || []).push(rel);
      existingRelNames.add((rel.name || '').toLowerCase());
      changes.push('added relationship: ' + rel.name);
    }
  }

  // Merge observations
  const obsCount = (secondary.observations || []).length;
  if (obsCount > 0) {
    primary.observations = (primary.observations || []).concat(secondary.observations || []);
    changes.push('merged ' + obsCount + ' observations');
  }

  // Merge connected_objects
  const existingConnIds = new Set((primary.connected_objects || []).map(c => c.entity_id));
  for (const conn of (secondary.connected_objects || [])) {
    if (!existingConnIds.has(conn.entity_id) && conn.entity_id !== primary_id) {
      (primary.connected_objects = primary.connected_objects || []).push(conn);
      existingConnIds.add(conn.entity_id);
    }
  }

  // Keep relationship_dimensions and org_dimensions from primary (or secondary if primary lacks them)
  if (!primary.relationship_dimensions && secondary.relationship_dimensions) {
    primary.relationship_dimensions = secondary.relationship_dimensions;
    changes.push('inherited relationship_dimensions from secondary');
  }
  if (!primary.descriptor && secondary.descriptor) {
    primary.descriptor = secondary.descriptor;
  }
  if (!primary.org_dimensions && secondary.org_dimensions) {
    primary.org_dimensions = secondary.org_dimensions;
  }

  // Update provenance
  if (!primary.provenance_chain) primary.provenance_chain = {};
  if (!primary.provenance_chain.merge_history) primary.provenance_chain.merge_history = [];
  primary.provenance_chain.merge_history.push({
    merged_from: secondary_id,
    merged_at: now,
    merged_by: req.agentId,
  });
  if (primary.extraction_metadata) primary.extraction_metadata.updated_at = now;

  // Write updated primary
  writeEntity(primary_id, primary, req.graphDir);

  // Update all references to secondary across the graph
  const allEntities = listEntities(req.graphDir);
  let refsUpdated = 0;
  const secondaryName = secondary.entity?.name?.full || secondary.entity?.name?.common || '';
  const primaryName = primary.entity?.name?.full || primary.entity?.name?.common || '';
  for (const { data } of allEntities) {
    const eid = (data.entity || {}).entity_id;
    if (eid === primary_id || eid === secondary_id) continue;
    let changed = false;

    // Update connected_objects references
    if (data.connected_objects) {
      for (let i = 0; i < data.connected_objects.length; i++) {
        if (data.connected_objects[i].entity_id === secondary_id) {
          data.connected_objects[i].entity_id = primary_id;
          changed = true;
        }
      }
    }

    // Update relationship references
    if (data.relationships) {
      for (let i = 0; i < data.relationships.length; i++) {
        if (data.relationships[i].name === secondaryName) {
          data.relationships[i].name = primaryName;
          changed = true;
        }
      }
    }

    if (changed) {
      writeEntity(eid, data, req.graphDir);
      refsUpdated++;
    }
  }

  // Delete secondary entity
  deleteEntity(secondary_id, req.graphDir);
  changes.push('deleted secondary entity: ' + secondary_id);
  changes.push('updated ' + refsUpdated + ' entity references');

  console.log('[merge-entities] Merged', secondary_id, 'into', primary_id, ':', changes.length, 'changes');

  res.json({
    merged_into: primary_id,
    deleted: secondary_id,
    changes,
    refs_updated: refsUpdated,
    entity: {
      entity_id: primary_id,
      name: primary.entity?.name?.full || primary.entity?.name?.common || '',
      descriptor: primary.descriptor || '',
    },
  });
});

// GET /api/entity/:id/connected — Entity + all connected objects
app.get('/api/entity/:id/connected', apiAuth, (req, res) => {
  const result = loadConnectedObjects(req.params.id, req.graphDir);
  if (!result) return res.status(404).json({ error: 'Entity not found' });
  res.json(result);
});

// GET /api/entity/:id/summary — Lightweight summary
app.get('/api/entity/:id/summary', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const e = entity.entity || {};
  const type = e.entity_type;
  let name = '';
  if (type === 'person') {
    name = e.name?.full || '';
  } else {
    name = e.name?.common || e.name?.legal || '';
  }

  res.json({
    entity_id: e.entity_id,
    entity_type: type,
    name,
    summary: e.summary?.value || '',
    confidence: entity.extraction_metadata?.extraction_confidence || null,
    last_updated: entity.extraction_metadata?.extracted_at || null,
    attributes_count: entity.attributes?.length || 0,
    relationships_count: entity.relationships?.length || 0,
    key_facts_count: entity.key_facts?.length || 0,
  });
});

// GET /api/entity/:id/context — Entity profile + top 20 weighted observations
app.get('/api/entity/:id/context', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const e = entity.entity || {};
  const type = e.entity_type;
  const name = type === 'person' ? (e.name?.full || '') : (e.name?.common || e.name?.legal || '');
  const now = Date.now();

  // Score and sort observations
  const observations = (entity.observations || []).map(obs => {
    const obsTime = new Date(obs.observed_at).getTime();
    const daysSince = Math.max(0, (now - obsTime) / (1000 * 60 * 60 * 24));
    const timeDecayFactor = Math.exp(-0.03 * daysSince);
    const relevanceWeight = (obs.confidence || 0) * timeDecayFactor;
    return { ...obs, days_since: Math.round(daysSince * 100) / 100, time_decay_factor: Math.round(timeDecayFactor * 1000) / 1000, relevance_weight: Math.round(relevanceWeight * 1000) / 1000 };
  });

  observations.sort((a, b) => b.relevance_weight - a.relevance_weight);
  const top20 = observations.slice(0, 20);
  const top5 = observations.slice(0, 5);

  // Build context summary
  const entitySummary = e.summary?.value || '';
  let contextSummary = entitySummary;
  if (top5.length > 0) {
    const obsText = top5.map((o, i) => `(${i + 1}) ${o.observation}`).join(' ');
    contextSummary += ' Recent observations: ' + obsText;
  }

  res.json({
    entity_id: e.entity_id,
    entity_type: type,
    name,
    entity_summary: entitySummary,
    context_summary: contextSummary,
    observation_count: (entity.observations || []).length,
    observations: top20,
    profile: {
      attributes_count: (entity.attributes || []).length,
      relationships_count: (entity.relationships || []).length,
      values_count: (entity.values || []).length,
      key_facts_count: (entity.key_facts || []).length,
      constraints_count: (entity.constraints || []).length,
      confidence: entity.extraction_metadata?.extraction_confidence || null,
    },
  });
});

// GET /api/query?q=&spoke_id= — Natural language graph query (MECE-011)
app.get('/api/query', apiAuth, async (req, res) => {
  const q = (req.query.q || '').trim();
  if (!q) return res.status(400).json({ error: 'Missing query parameter q' });

  const spokeId = req.query.spoke_id || null;
  let queryOpts = null;
  if (spokeId) {
    const spoke = getSpoke(req.graphDir, spokeId);
    queryOpts = {
      spokeId,
      spokeName: spoke?.name || spokeId,
      centeredEntityName: spoke?.centered_entity_name || null,
    };
  }

  try {
    const result = await queryEngine(q, req.graphDir, queryOpts);
    res.json(result);
  } catch (err) {
    console.error('Query engine error:', err);
    res.status(500).json({ error: 'Query failed', message: err.message });
  }
});

// GET /api/self-entity — Get current self-entity config
app.get('/api/self-entity', apiAuth, (req, res) => {
  const selfEntity = getSelfEntity(req.graphDir);
  if (!selfEntity) return res.json({ configured: false });
  res.json({ configured: true, ...selfEntity });
});

// POST /api/self-entity — Set self-entity for this tenant
app.post('/api/self-entity', apiAuth, (req, res) => {
  const { entity_id, entity_name, purpose } = req.body || {};
  if (!entity_id) return res.status(400).json({ error: 'Missing entity_id' });

  const selfPath = path.join(req.graphDir, 'self-entity.json');
  const config = { self_entity_id: entity_id, self_entity_name: entity_name || '', purpose: purpose || 'primary_user' };
  fs.writeFileSync(selfPath, JSON.stringify(config, null, 2));
  clearSelfEntityCache(req.graphDir);

  // Update the entity's ownership to "self"
  const selfEntityData = readEntity(entity_id, req.graphDir);
  if (selfEntityData) {
    selfEntityData.ownership = 'self';
    selfEntityData.owner_tenant_id = req.tenantId || null;
    writeEntity(entity_id, selfEntityData, req.graphDir);
  }

  res.json({ success: true, ...config });
});

// ---------------------------------------------------------------------------
// Spoke Endpoints — Heliocentric Hub-Spoke Architecture (MECE-015)
// ---------------------------------------------------------------------------

// POST /api/spoke — Create a new spoke
app.post('/api/spoke', apiAuth, (req, res) => {
  try {
    const { name, description, source, centered_entity_id, external_id, sync_status } = req.body || {};
    if (!name) return res.status(400).json({ error: 'Missing spoke name' });

    const spoke = createSpoke(req.graphDir, { name, description, source, centered_entity_id, external_id, sync_status });
    res.status(201).json({ status: 'created', spoke });
  } catch (err) {
    if (err.message.includes('already exists')) {
      return res.status(409).json({ error: err.message });
    }
    res.status(400).json({ error: err.message });
  }
});

// GET /api/spokes — List all spokes with entity counts. Optional ?source= filter.
app.get('/api/spokes', apiAuth, (req, res) => {
  const sourceFilter = req.query.source || null;
  const spokes = listSpokesWithCounts(req.graphDir, sourceFilter);
  res.json({ spokes, total: spokes.length });
});

// GET /api/spoke/:id — Spoke detail with entity summary
app.get('/api/spoke/:id', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: 'Spoke not found' });

  // Get entities in this spoke for the summary
  const entities = listEntities(req.graphDir, { spokeId: req.params.id });
  const entitySummary = entities.slice(0, 20).map(({ data }) => {
    const e = data.entity || {};
    return {
      entity_id: e.entity_id,
      name: e.name?.full || e.name?.preferred || e.name?.common || e.entity_id,
      entity_type: e.entity_type,
    };
  });

  res.json({
    spoke: { ...spoke, entity_count: entities.length },
    entity_summary: entitySummary,
    total_entities: entities.length,
  });
});

// PUT /api/spoke/:id — Update spoke (name, description, source, etc.)
app.put('/api/spoke/:id', apiAuth, (req, res) => {
  const updates = req.body || {};
  const spoke = updateSpoke(req.graphDir, req.params.id, updates);
  if (!spoke) return res.status(404).json({ error: 'Spoke not found' });
  res.json({ status: 'updated', spoke });
});

// PUT /api/spoke/:id/center — Set or change the centered entity for a spoke
app.put('/api/spoke/:id/center', apiAuth, (req, res) => {
  const { entity_id } = req.body || {};
  if (!entity_id) return res.status(400).json({ error: 'Missing entity_id' });

  // Verify entity exists
  const entityData = readEntity(entity_id, req.graphDir);
  if (!entityData) return res.status(404).json({ error: `Entity ${entity_id} not found` });

  const spoke = setCenteredEntity(req.graphDir, req.params.id, entity_id);
  if (!spoke) return res.status(404).json({ error: 'Spoke not found' });

  res.json({ status: 'centered', spoke });
});

// DELETE /api/spoke/:id — Delete spoke (reject if entities exist unless ?force=true)
app.delete('/api/spoke/:id', apiAuth, (req, res) => {
  try {
    const force = req.query.force === 'true';
    const deleted = deleteSpoke(req.graphDir, req.params.id, force);
    if (!deleted) return res.status(404).json({ error: 'Spoke not found' });
    res.json({ status: 'deleted', spoke: deleted });
  } catch (err) {
    if (err.message.includes('Cannot delete the default spoke')) {
      return res.status(403).json({ error: err.message });
    }
    res.status(409).json({ error: err.message });
  }
});

// POST /api/spokes/migrate — Run spoke migration on existing entities (one-time)
app.post('/api/spokes/migrate', apiAuth, (req, res) => {
  const count = migrateEntitiesToSpokes(req.graphDir);
  // Ensure spokes.json exists (loadSpokes bootstraps default spoke)
  loadSpokes(req.graphDir);
  res.json({ status: 'migrated', entities_updated: count });
});

// ---------------------------------------------------------------------------
// Tier Adjustments (Build 11.5 — per-spoke field tier overrides)
// ---------------------------------------------------------------------------

// PATCH /api/spokes/:id/tier-adjustments — Override necessity_tier for specific fields on a spoke
app.patch('/api/spokes/:id/tier-adjustments', apiAuth, (req, res) => {
  try {
    const spokeId = req.params.id;
    const spoke = getSpoke(req.graphDir, spokeId);
    if (!spoke) return res.status(404).json({ error: 'Spoke not found' });

    const { adjustments } = req.body || {};
    if (!adjustments || typeof adjustments !== 'object') {
      return res.status(400).json({ error: 'Body must include { adjustments: { "field_id": "BLOCKING"|"EXPECTED"|"ENRICHING", ... } }' });
    }

    // Validate tier values
    const validTiers = new Set(['BLOCKING', 'EXPECTED', 'ENRICHING']);
    for (const [fieldId, tier] of Object.entries(adjustments)) {
      if (!validTiers.has(tier)) {
        return res.status(400).json({ error: `Invalid tier "${tier}" for field "${fieldId}". Must be BLOCKING, EXPECTED, or ENRICHING.` });
      }
    }

    // Merge with existing adjustments (new values override, null removes)
    const existing = spoke.tier_adjustments || {};
    for (const [fieldId, tier] of Object.entries(adjustments)) {
      if (tier === null) {
        delete existing[fieldId];
      } else {
        existing[fieldId] = tier;
      }
    }

    updateSpoke(req.graphDir, spokeId, { tier_adjustments: existing });

    // Invalidate cached gap analysis so next dashboard load recalculates
    updateSpoke(req.graphDir, spokeId, { gap_analysis: null });

    res.json({
      spoke_id: spokeId,
      tier_adjustments: existing,
      adjustment_count: Object.keys(existing).length
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// GET /api/spokes/:id/tier-adjustments — Get current tier overrides for a spoke
app.get('/api/spokes/:id/tier-adjustments', apiAuth, (req, res) => {
  try {
    const spoke = getSpoke(req.graphDir, req.params.id);
    if (!spoke) return res.status(404).json({ error: 'Spoke not found' });
    res.json({ spoke_id: req.params.id, tier_adjustments: spoke.tier_adjustments || {} });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ---------------------------------------------------------------------------
// Document Request Email Generator (Build 13)
// ---------------------------------------------------------------------------

// POST /api/spokes/:id/request-email — Generate client-friendly document request email
app.post('/api/spokes/:id/request-email', apiAuth, async (req, res) => {
  try {
    const spoke = getSpoke(req.graphDir, req.params.id);
    if (!spoke) return res.status(404).json({ error: 'Spoke not found' });
    if (!spoke.template_type) return res.status(400).json({ error: 'Spoke has no template assigned' });

    // Ensure gap analysis is current
    if (!spoke.gap_analysis) {
      try {
        const gap = await analyzeGaps(req.params.id, req.graphDir, spoke.template_type);
        updateSpoke(req.graphDir, req.params.id, { gap_analysis: gap });
      } catch (err) {
        return res.status(500).json({ error: 'Failed to run gap analysis: ' + err.message });
      }
    }

    // Build share URL if spoke has a share token, or create one
    let shareUrl = '';
    if (req.body.include_upload_link !== false) {
      const shares = spoke.shares || [];
      let uploadShare = shares.find(s => s.includes && s.includes.includes('upload'));
      if (!uploadShare) {
        // Auto-create an upload share
        const crypto = require('crypto');
        const token = crypto.randomBytes(12).toString('base64url');
        uploadShare = {
          token,
          label: 'Client Upload Portal',
          includes: ['gaps', 'upload'],
          created_at: new Date().toISOString()
        };
        shares.push(uploadShare);
        updateSpoke(req.graphDir, req.params.id, { shares });
      }
      const protocol = req.headers['x-forwarded-proto'] || req.protocol;
      const host = req.headers['x-forwarded-host'] || req.get('host');
      shareUrl = `${protocol}://${host}/shared/${uploadShare.token}`;
    }

    const result = generateRequestEmail(req.params.id, req.graphDir, spoke.template_type, {
      client_name: req.body.client_name || spoke.name || 'Client',
      firm_name: req.body.firm_name || 'Our Firm',
      share_url: shareUrl
    });

    if (result.error) return res.status(400).json({ error: result.error });

    // Log activity
    const activity = spoke.recent_activity || [];
    activity.unshift({
      type: 'email_generated',
      description: 'Document request email generated (' + (result.missing_items || []).length + ' items)',
      timestamp: new Date().toISOString()
    });
    updateSpoke(req.graphDir, req.params.id, { recent_activity: activity.slice(0, 50) });

    res.json({
      subject: result.subject,
      body: result.body,
      missing_items: result.missing_items,
      share_url: shareUrl,
      mailto_link: 'mailto:?subject=' + encodeURIComponent(result.subject) + '&body=' + encodeURIComponent(result.body)
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// GET /api/spokes/:id/display-names — Get client-friendly display name map
app.get('/api/spokes/:id/display-names', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: 'Spoke not found' });
  if (!spoke.template_type) return res.status(400).json({ error: 'No template assigned' });
  const map = buildDisplayNameMap(spoke.template_type);
  res.json({ spoke_id: req.params.id, template_type: spoke.template_type, ...map });
});

// ---------------------------------------------------------------------------
// Dashboard Endpoint (Build 11 + Build 11.5 three-tier scores)
// ---------------------------------------------------------------------------

// GET /api/dashboard — Firm-wide dashboard: all spokes with completeness, review status, entity counts
app.get('/api/dashboard', apiAuth, (req, res) => {
  try {
    const spokes = listSpokesWithCounts(req.graphDir);
    const templates = loadTemplates();

    const spokeSummaries = spokes.filter(s => s.id !== 'default').map(spoke => {
      const templateType = spoke.template_type || null;
      const template = templateType ? templates[templateType] : null;

      // Completeness from cached gap analysis
      const gap = spoke.gap_analysis || {};
      const completeness = gap.overall_score != null ? Math.round(gap.overall_score * 100) : null;

      // Review status: count reviewed vs total entities
      const entityCount = spoke.entity_count || 0;
      const reviewSummary = spoke.review_summary || {};
      const reviewedCount = reviewSummary.reviewed_count || 0;
      const totalReviewable = reviewSummary.total_reviewable || entityCount;

      // Missing documents from gap analysis
      const missingDocs = (gap.missing_documents || []).map(d => d.type_id || d.item);
      const foundDocs = (gap.found_documents || []).map(d => d.type_id || d.item);
      const crossDocViolations = (gap.cross_doc_violations || []).length;

      // Build 11.5 — three-tier scores from cached gap analysis
      const filingReadiness = gap.filing_readiness != null ? Math.round(gap.filing_readiness * 100) : null;
      const qualityScore = gap.quality_score != null ? Math.round(gap.quality_score * 100) : null;
      const completenessScore = gap.completeness != null ? Math.round(gap.completeness * 100) : null;
      const tierCounts = gap.tier_counts || null;
      const missingByTier = gap.missing_by_tier || null;
      const tierAdjustmentCount = spoke.tier_adjustments ? Object.keys(spoke.tier_adjustments).length : 0;

      return {
        spoke_id: spoke.id,
        name: spoke.name || spoke.id,
        template_type: templateType,
        template_label: template ? (template.label || template.display_name) : null,
        completeness_pct: completeness,
        // Build 11.5 — three-tier scores (as percentages)
        filing_readiness_pct: filingReadiness,
        quality_score_pct: qualityScore,
        completeness_score_pct: completenessScore,
        tier_counts: tierCounts,
        missing_by_tier: missingByTier,
        tier_adjustment_count: tierAdjustmentCount,
        // Existing fields
        review_status: `${reviewedCount} of ${totalReviewable} reviewed`,
        reviewed_count: reviewedCount,
        total_reviewable: totalReviewable,
        entity_count: entityCount,
        last_updated: spoke.updated_at || spoke.created_at || null,
        missing_documents: missingDocs,
        found_documents: foundDocs,
        cross_doc_violations: crossDocViolations
      };
    });

    // Sort by completeness ascending (worst first), nulls at top
    spokeSummaries.sort((a, b) => {
      if (a.completeness_pct == null && b.completeness_pct == null) return 0;
      if (a.completeness_pct == null) return -1;
      if (b.completeness_pct == null) return -1;
      return a.completeness_pct - b.completeness_pct;
    });

    // Aggregate stats
    const total = spokeSummaries.length;
    const critical = spokeSummaries.filter(s => s.completeness_pct != null && s.completeness_pct < 50).length;
    const inProgress = spokeSummaries.filter(s => s.completeness_pct != null && s.completeness_pct >= 50 && s.completeness_pct < 80).length;
    const complete = spokeSummaries.filter(s => s.completeness_pct != null && s.completeness_pct >= 80).length;
    const fullyReviewed = spokeSummaries.filter(s => s.total_reviewable > 0 && s.reviewed_count >= s.total_reviewable).length;
    const noAnalysis = spokeSummaries.filter(s => s.completeness_pct == null).length;
    // Build 11.5 — filing readiness stats
    const filingNotReady = spokeSummaries.filter(s => s.filing_readiness_pct != null && s.filing_readiness_pct < 100).length;
    const filingReady = spokeSummaries.filter(s => s.filing_readiness_pct != null && s.filing_readiness_pct >= 100).length;

    // Collect active template types for filter chip generation
    const activeTemplateTypes = [...new Set(spokeSummaries.map(s => s.template_type).filter(Boolean))];

    // Generate dynamic filter chips based on active templates
    const filterChips = [];

    // Universal chips (always present)
    filterChips.push({ id: 'critical', label: 'Critical (<50%)', type: 'universal', filter: { completeness_max: 49 } });
    filterChips.push({ id: 'needs_review', label: 'Needs Review', type: 'universal', filter: { review_incomplete: true } });
    filterChips.push({ id: 'complete', label: 'Complete', type: 'universal', filter: { completeness_min: 80 } });
    // Build 11.5 — tier-aware chips
    filterChips.push({ id: 'filing_not_ready', label: 'Filing Not Ready', type: 'universal', filter: { filing_not_ready: true } });
    filterChips.push({ id: 'low_quality', label: 'Low Quality (<70%)', type: 'universal', filter: { quality_max: 69 } });

    for (const tmplType of activeTemplateTypes) {
      const tmpl = templates[tmplType];
      if (!tmpl) continue;

      // Generate "Missing [doc]" chips for HIGH-priority document types
      for (const dt of (tmpl.document_types || [])) {
        if (dt.priority === 'HIGH') {
          filterChips.push({
            id: `missing_${dt.type_id}`,
            label: `Missing ${dt.display_name}`,
            type: 'template',
            template_type: tmplType,
            filter: { missing_document: dt.type_id }
          });
        }
      }

      // Template-specific special chips
      if (tmplType === 'financial_review') {
        filterChips.push({
          id: 'cross_doc_violations',
          label: 'Cross-Doc Violations',
          type: 'template',
          template_type: 'financial_review',
          filter: { has_cross_doc_violations: true }
        });
      }
      if (tmplType === 'personal_injury') {
        filterChips.push({
          id: 'ready_for_demand',
          label: 'Ready for Demand',
          type: 'template',
          template_type: 'personal_injury',
          filter: { completeness_min: 80 }
        });
      }
    }

    res.json({
      spokes: spokeSummaries,
      stats: {
        total, critical, in_progress: inProgress, complete, fully_reviewed: fullyReviewed, no_analysis: noAnalysis,
        filing_not_ready: filingNotReady, filing_ready: filingReady
      },
      filter_chips: filterChips,
      active_templates: activeTemplateTypes
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// POST /api/onboard — One-click client onboarding: create spoke + bind template + ingest files
const onboardUpload = multer({ storage: multer.memoryStorage(), limits: { files: 20, fileSize: 50 * 1024 * 1024 } });
app.post('/api/onboard', apiAuth, onboardUpload.array('files', 20), async (req, res) => {
  try {
    const { client_name, template_type } = req.body || {};
    if (!client_name) return res.status(400).json({ error: 'client_name is required' });
    if (!template_type) return res.status(400).json({ error: 'template_type is required' });

    const template = getTemplate(template_type);
    if (!template) return res.status(404).json({ error: 'Template not found', available_templates: Object.keys(loadTemplates()) });

    // Step 1: Create spoke
    const spokeId = resolveOrCreateSpoke(req.graphDir, client_name);
    console.log(`[onboard] Spoke: ${spokeId} (${client_name})`);

    // Step 2: Assign template
    updateSpoke(req.graphDir, spokeId, {
      template_type,
      gap_analysis: null,
      document_classification: null,
      review_status: null,
      review_summary: null
    });
    console.log(`[onboard] Template assigned: ${template_type}`);

    // Step 3: Ingest uploaded files (if any are in the multipart request)
    const ingestResults = [];
    if (req.files && req.files.length > 0) {
      for (const file of req.files) {
        const filename = file.originalname;
        const fileBuffer = file.buffer;

        // Preserve source file
        const fileId = preserveSourceFile(req.graphDir, spokeId, filename, fileBuffer);
        console.log(`[onboard] Preserved ${filename} → ${fileId}`);

        try {
          const result = await universalParse(fileBuffer, filename);
          const now = new Date().toISOString();

          if (result.entities.length > 0 && result.metadata.parse_strategy !== 'chat_import') {
            const v2Entities = result.entities.map(ent => {
              const entityType = ent.type === 'PERSON' ? 'person' : 'business';
              return {
                schema_version: '2.0',
                schema_type: 'context_architecture_entity',
                extraction_metadata: {
                  extracted_at: now, updated_at: now,
                  source_description: `onboard:${filename}`,
                  extraction_model: result.metadata.model_used || 'claude-sonnet-4-5-20250929',
                  extraction_confidence: ent.confidence || 0.7,
                  schema_version: '2.0',
                },
                entity: {
                  entity_type: entityType,
                  name: { full: ent.name, confidence: ent.confidence || 0.7, facts_layer: 2 },
                  summary: { value: ent.evidence || '', confidence: ent.confidence || 0.7, facts_layer: 2 },
                },
                attributes: (Array.isArray(ent.attributes) ? ent.attributes : Object.entries(ent.attributes || {}).map(([key, value]) => ({ key, value: String(value), evidence: null }))).map((attr, i) => ({
                  key: attr.key || attr.attribute || `attr_${i}`,
                  value: typeof attr.value === 'object' ? JSON.stringify(attr.value) : String(attr.value || ''),
                  confidence: ent.confidence || 0.7,
                  provenance: { source: `file_upload:${filename}`, extracted_at: now },
                })),
                observations: (ent.observations || []).map((obs, i) => ({
                  observation_id: `obs-${Date.now()}-${i}`,
                  observation: typeof obs === 'string' ? obs : (obs.observation || obs.fact || JSON.stringify(obs)),
                  confidence: ent.confidence || 0.7,
                  confidence_label: 'moderate',
                  facts_layer: 2,
                  source: `file_upload:${filename}`,
                  created_at: now,
                })),
                relationships: [],
                spoke_id: spokeId,
                source_ref: filename,
              };
            });

            for (const v2ent of v2Entities) {
              try {
                const id = writeEntity(v2ent, req.graphDir);
                ingestResults.push({ filename, entity_id: id, name: v2ent.entity.name.full });
              } catch (writeErr) {
                ingestResults.push({ filename, error: writeErr.message });
              }
            }
          }
        } catch (parseErr) {
          ingestResults.push({ filename, error: parseErr.message });
        }
      }
    }

    // Step 4: Run gap analysis (quick, signal-based only for initial view)
    let gapReport = null;
    try {
      gapReport = await analyzeGaps(spokeId, req.graphDir, template_type);
      updateSpoke(req.graphDir, spokeId, { gap_analysis: gapReport, template_type });
    } catch (gapErr) {
      console.warn('[onboard] Gap analysis failed:', gapErr.message);
    }

    const spoke = getSpoke(req.graphDir, spokeId);
    res.status(201).json({
      status: 'onboarded',
      spoke_id: spokeId,
      spoke,
      template_type,
      entities_created: ingestResults.length,
      ingest_results: ingestResults,
      gap_analysis: gapReport
    });
  } catch (err) {
    if (err.message.includes('already exists')) {
      return res.status(409).json({ error: err.message });
    }
    res.status(500).json({ error: err.message });
  }
});

// ---------------------------------------------------------------------------
// Gap Analysis Endpoints (MECE-019)
// ---------------------------------------------------------------------------

// GET /api/templates — List all matter templates (id, label, category count) (Build 10: enriched)
app.get('/api/templates', apiAuth, (req, res) => {
  const templates = loadTemplates();
  const list = Object.entries(templates).map(([id, t]) => ({
    id,
    label: t.label || t.display_name || id,
    version: t.version || '0.1.0',
    category_count: (t.required_documents || []).length,
    document_types: (t.document_types || []).length,
    entity_roles: (t.required_entities || []).length,
    cross_doc_rules: (t.cross_doc_rules || []).length,
    has_extraction_specs: (t.document_types || []).some(dt => (dt.extraction_spec || []).length > 0)
  }));
  res.json({ templates: list });
});

// GET /api/templates/:type — Full template detail
app.get('/api/templates/:type', apiAuth, (req, res) => {
  const template = getTemplate(req.params.type);
  if (!template) return res.status(404).json({ error: 'Template not found', available: Object.keys(loadTemplates()) });
  res.json({ id: req.params.type, ...template });
});

// POST /api/templates — Create new template (Build 12: full new-format template)
app.post('/api/templates', apiAuth, (req, res) => {
  const body = req.body || {};
  const templateId = body.template_id;
  if (!templateId) return res.status(400).json({ error: 'template_id is required' });
  if (!body.display_name) return res.status(400).json({ error: 'display_name is required' });
  if (!/^[a-z][a-z0-9_]*$/.test(templateId)) return res.status(400).json({ error: 'template_id must be lowercase alphanumeric with underscores, starting with a letter' });

  // Check if template already exists
  const existing = getTemplate(templateId);
  if (existing) return res.status(409).json({ error: `Template '${templateId}' already exists. Use PUT to update.` });

  // Build template structure
  const template = {
    template_id: templateId,
    version: body.version || '1.0.0',
    display_name: body.display_name,
    description: body.description || '',
    document_types: body.document_types || [],
    entity_roles: body.entity_roles || [],
    cross_doc_rules: body.cross_doc_rules || [],
    created_at: new Date().toISOString(),
    created_by: body.created_by || 'template_builder'
  };

  saveTemplate(templateId, template);
  res.json({ status: 'created', id: templateId, version: template.version });
});

// PUT /api/templates/:type — Update existing template (auto-bumps version)
app.put('/api/templates/:type', apiAuth, (req, res) => {
  const templateId = req.params.type;
  const existing = getTemplate(templateId);
  if (!existing) return res.status(404).json({ error: 'Template not found', available: Object.keys(loadTemplates()) });

  const body = req.body || {};
  const newVersion = body.version || bumpVersion(existing.version);

  // Merge updates onto existing template
  const template = {
    template_id: templateId,
    version: newVersion,
    display_name: body.display_name || existing.display_name,
    description: body.description !== undefined ? body.description : (existing.description || ''),
    document_types: body.document_types !== undefined ? body.document_types : (existing.document_types || []),
    entity_roles: body.entity_roles !== undefined ? body.entity_roles : (existing.entity_roles || []),
    cross_doc_rules: body.cross_doc_rules !== undefined ? body.cross_doc_rules : (existing.cross_doc_rules || []),
    created_at: existing.created_at || new Date().toISOString(),
    updated_at: new Date().toISOString(),
    created_by: existing.created_by || 'template_builder'
  };

  saveTemplate(templateId, template);
  res.json({ status: 'updated', id: templateId, version: template.version, previous_version: existing.version });
});

// DELETE /api/templates/:type — Delete a custom template
app.delete('/api/templates/:type', apiAuth, (req, res) => {
  const templateId = req.params.type;
  const deleted = deleteTemplate(templateId);
  if (!deleted) return res.status(404).json({ error: 'Template file not found in data/templates/' });
  res.json({ status: 'deleted', id: templateId });
});

// PUT /api/spoke/:id/template — Assign template to spoke, clear cached analysis (Build 10: re-analysis on change)
app.put('/api/spoke/:id/template', apiAuth, (req, res) => {
  const { template_type } = req.body || {};
  if (!template_type) return res.status(400).json({ error: 'template_type is required' });
  const template = getTemplate(template_type);
  if (!template) return res.status(404).json({ error: 'Template not found', available_templates: Object.keys(loadTemplates()) });
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: 'Spoke not found' });
  // Clear cached analysis + classification so re-analysis is triggered on next gaps request
  const updated = updateSpoke(req.graphDir, req.params.id, {
    template_type,
    gap_analysis: null,
    document_classification: null,
    review_status: null,
    review_summary: null
  });
  res.json({ status: 'assigned', spoke_id: req.params.id, template_type, spoke: updated });
});

// GET /api/spoke/:id/gaps — Run gap analysis (cached unless ?refresh=true)
app.get('/api/spoke/:id/gaps', apiAuth, async (req, res) => {
  try {
    const spoke = getSpoke(req.graphDir, req.params.id);
    if (!spoke) return res.status(404).json({ error: 'Spoke not found' });

    const templateType = req.query.template || spoke.template_type;
    if (!templateType) {
      return res.status(400).json({
        error: 'No template assigned to this spoke. Assign one with PUT /api/spoke/:id/template or pass ?template=type',
        available_templates: Object.keys(loadTemplates())
      });
    }

    // Return cached if available and not refreshing
    if (spoke.gap_analysis && !req.query.refresh) {
      return res.json({ ...spoke.gap_analysis, cached: true });
    }

    const report = await analyzeGaps(req.params.id, req.graphDir, templateType);

    // Cache on spoke
    updateSpoke(req.graphDir, req.params.id, { gap_analysis: report, template_type: templateType });

    res.json(report);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// GET /api/spoke/:spokeId/files — Return file manifest for a spoke
app.get('/api/spoke/:spokeId/files', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.spokeId);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.spokeId} not found` });
  res.json({ spoke_id: req.params.spokeId, files: spoke.files || [] });
});

// GET /api/spoke/:spokeId/file/:fileId — Serve original source file (supports ?token= for shared access)
app.get('/api/spoke/:spokeId/file/:fileId', (req, res, next) => {
  // Token-based auth for shared portal file downloads
  if (req.query.token) {
    const result = findSpokeByShareToken(GRAPH_DIR, req.query.token);
    if (!result) return res.status(403).json({ error: 'Invalid share token' });
    if (result.spoke.id !== req.params.spokeId) return res.status(403).json({ error: 'Token does not match spoke' });
    if (!result.share.includes || !result.share.includes.includes('files')) return res.status(403).json({ error: 'File access not included in share' });
    // Serve the file
    const manifest = (result.spoke.files || []).find(f => f.file_id === req.params.fileId);
    if (!manifest) return res.status(404).json({ error: `File ${req.params.fileId} not found in spoke` });
    const filePath = path.join(result.graphDir, 'spoke_files', req.params.spokeId, manifest.stored_as);
    if (!fs.existsSync(filePath)) return res.status(404).json({ error: 'File not found on disk' });
    res.setHeader('Content-Type', manifest.mime_type || 'application/octet-stream');
    res.setHeader('Content-Disposition', `inline; filename="${manifest.original_name}"`);
    return fs.createReadStream(filePath).pipe(res);
  }
  // Fall through to apiAuth
  next();
}, apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.spokeId);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.spokeId} not found` });
  const manifest = (spoke.files || []).find(f => f.file_id === req.params.fileId);
  if (!manifest) return res.status(404).json({ error: `File ${req.params.fileId} not found in spoke` });
  const filePath = path.join(req.graphDir, 'spoke_files', req.params.spokeId, manifest.stored_as);
  if (!fs.existsSync(filePath)) return res.status(404).json({ error: 'File not found on disk' });
  res.setHeader('Content-Type', manifest.mime_type || 'application/octet-stream');
  res.setHeader('Content-Disposition', `inline; filename="${manifest.original_name}"`);
  fs.createReadStream(filePath).pipe(res);
});

// POST /api/demo/tax-client — One-button demo: create spoke, ingest sample docs, run gap analysis
app.post('/api/demo/tax-client', apiAuth, async (req, res) => {
  try {
    const samplesDir = path.resolve(__dirname, 'samples', 'acme-tax-client');
    if (!fs.existsSync(samplesDir)) {
      return res.status(404).json({ error: 'Sample documents not found. Run: node scripts/generate-sample-docs.js --llm' });
    }

    const files = fs.readdirSync(samplesDir).filter(f => f.endsWith('.txt'));
    if (files.length === 0) {
      return res.status(404).json({ error: 'No sample .txt files found in samples/acme-tax-client/' });
    }

    // Step 0: Idempotency — clean up existing Acme spoke if present
    const spokeName = 'Acme Consulting LLC';
    const existingSpokes = loadSpokes(req.graphDir);
    const existingAcme = Object.values(existingSpokes).find(s => s.name === spokeName);
    if (existingAcme) {
      console.log(`[demo] Cleaning up existing spoke: ${existingAcme.id}`);
      // Delete entities belonging to this spoke
      const entsToDelete = listEntities(req.graphDir).filter(e => e.data.spoke_id === existingAcme.id);
      for (const ent of entsToDelete) {
        try { deleteEntity(ent.id, req.graphDir); } catch {}
      }
      // Delete spoke files from disk
      const spokeFilesDir = path.join(req.graphDir, 'spoke_files', existingAcme.id);
      if (fs.existsSync(spokeFilesDir)) {
        const sf = fs.readdirSync(spokeFilesDir);
        for (const f of sf) fs.unlinkSync(path.join(spokeFilesDir, f));
        fs.rmdirSync(spokeFilesDir);
      }
      deleteSpoke(req.graphDir, existingAcme.id, true);
      console.log(`[demo] Deleted ${entsToDelete.length} entities + spoke ${existingAcme.id}`);
    }

    // Step 1: Create spoke
    const spokeId = resolveOrCreateSpoke(req.graphDir, spokeName);
    console.log(`[demo] Spoke: ${spokeId} (${spokeName})`);

    // Step 2: Assign template
    updateSpoke(req.graphDir, spokeId, { template_type: 'tax_preparation', gap_analysis: null, document_classification: null });
    console.log(`[demo] Template assigned: tax_preparation`);

    // Step 3: Ingest all sample files
    const ingestResults = [];
    for (const filename of files) {
      const filePath = path.join(samplesDir, filename);
      const content = fs.readFileSync(filePath);

      // Preserve original source file for provenance
      const demoFileId = preserveSourceFile(req.graphDir, spokeId, filename, content);
      console.log(`[demo] Preserved ${filename} → ${demoFileId}`);

      try {
        const result = await universalParse(content, filename);
        const now = new Date().toISOString();

        if (result.entities.length > 0 && result.metadata.parse_strategy !== 'chat_import') {
          const v2Entities = result.entities.map(ent => {
            const entityType = ent.type === 'PERSON' ? 'person'
              : ent.type === 'ORG' ? 'business'
              : 'business';

            return {
              schema_version: '2.0',
              schema_type: 'context_architecture_entity',
              extraction_metadata: {
                extracted_at: now, updated_at: now,
                source_description: `demo_ingest:${filename}`,
                extraction_model: result.metadata.model_used || 'claude-sonnet-4-5-20250929',
                extraction_confidence: ent.confidence || 0.7,
                schema_version: '2.0',
              },
              entity: {
                entity_type: entityType,
                name: { full: ent.name, confidence: ent.confidence || 0.7, facts_layer: 2 },
                summary: { value: ent.evidence || '', confidence: ent.confidence || 0.7, facts_layer: 2 },
              },
              attributes: (Array.isArray(ent.attributes) ? ent.attributes : Object.entries(ent.attributes || {}).map(([key, value]) => ({ key, value: String(value), evidence: null }))).map((attr, i) => {
                const evidence = attr.evidence || null;
                const evidType = evidence ? (evidence.type || 'direct') : 'inferred';
                const attrConf = (evidType === 'direct' && evidence) ? Math.max(ent.confidence || 0.7, 0.85) : (ent.confidence || 0.7);
                return {
                  attribute_id: `ATTR-${String(i + 1).padStart(3, '0')}`,
                  key: attr.key,
                  value: String(attr.value || ''),
                  confidence: attrConf,
                  confidence_label: attrConf >= 0.8 ? 'HIGH' : 'MODERATE',
                  provenance: evidence ? {
                    file_id: demoFileId,
                    original_filename: filename,
                    snippet: evidence.snippet,
                    location: evidence.location,
                    extraction_model: result.metadata.model_used || 'claude-sonnet-4-5-20250929',
                    extraction_type: evidType,
                    extracted_at: now,
                  } : null,
                };
              }),
              relationships: [],
              values: [], key_facts: [], constraints: [], observations: [],
              provenance_chain: {
                created_at: now, created_by: 'demo',
                source_documents: [{ source: `demo_ingest:${filename}`, ingested_at: now }],
                merge_history: [],
              },
              spoke_id: spokeId,
              source: 'manual',
              source_ref: filename,
            };
          });

          const staged = stageAndScoreExtraction(v2Entities, { type: 'file', url: '', description: `Demo: ${filename}` }, req.graphDir);

          // Auto-resolve: add all staged entities directly to graph (skip review queue for demo)
          let resolved = 0;
          for (const cluster of staged) {
            if (cluster.cluster_id) {
              try {
                const action = (cluster.candidate_entity_id && (cluster.quadrant === 2 || cluster.quadrant === 4))
                  ? 'merge' : 'create_new';
                resolveCluster(cluster.cluster_id, action, req.graphDir, 'demo');
                resolved++;
              } catch (resolveErr) {
                console.warn(`[demo] Resolve failed for ${cluster.cluster_id}: ${resolveErr.message}`);
              }
            }
          }
          ingestResults.push({ filename, entities_staged: staged.length, entities_resolved: resolved, entities_found: result.entities.length });
        } else {
          ingestResults.push({ filename, entities_staged: 0, entities_resolved: 0, entities_found: result.entities.length });
        }
      } catch (err) {
        ingestResults.push({ filename, error: err.message });
      }
    }
    console.log(`[demo] Ingested ${files.length} files`);

    // Step 3b: Ensure business entity for Acme Consulting LLC exists
    const allSpokeEnts = listEntities(req.graphDir).filter(e => e.data.spoke_id === spokeId);
    const hasBizEntity = allSpokeEnts.some(e => {
      const t = e.data.entity?.entity_type;
      return (t === 'business' || t === 'organization');
    });

    if (!hasBizEntity) {
      console.log('[demo] No business entity found — creating Acme Consulting LLC entity');
      // Look up file IDs from the spoke's file manifest for provenance
      const spokeNow = getSpoke(req.graphDir, spokeId);
      const spokeFiles = spokeNow.files || [];
      const einFile = spokeFiles.find(f => f.original_name === 'acme_ein_letter.txt');
      const articlesFile = spokeFiles.find(f => f.original_name === 'acme_articles_of_incorporation.txt');
      const now = new Date().toISOString();

      const bizEntity = {
        schema_version: '2.0',
        schema_type: 'context_architecture_entity',
        extraction_metadata: {
          extracted_at: now, updated_at: now,
          source_description: 'demo_ingest:business_entity_synthesis',
          extraction_model: 'demo', extraction_confidence: 0.95, schema_version: '2.0',
        },
        entity: {
          entity_type: 'business',
          name: { common: 'Acme Consulting LLC', legal: 'Acme Consulting LLC', confidence: 0.95, facts_layer: 1 },
          summary: { value: 'Georgia limited liability company providing management consulting, business advisory, and technology consulting services. Founded March 2022.', confidence: 0.95, facts_layer: 1 },
        },
        attributes: [
          { attribute_id: 'ATTR-001', key: 'legal_name', value: 'Acme Consulting LLC', confidence: 0.95, confidence_label: 'HIGH', provenance: articlesFile ? { file_id: articlesFile.file_id, original_filename: 'acme_articles_of_incorporation.txt', snippet: 'NAME OF LIMITED LIABILITY COMPANY: Acme Consulting LLC', location: 'Section 1', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-002', key: 'ein', value: '88-4923156', confidence: 0.95, confidence_label: 'HIGH', provenance: einFile ? { file_id: einFile.file_id, original_filename: 'acme_ein_letter.txt', snippet: 'We assigned you EIN 88-4923156', location: 'CP 575 A', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-003', key: 'entity_type', value: 'Limited Liability Company', confidence: 0.95, confidence_label: 'HIGH', provenance: einFile ? { file_id: einFile.file_id, original_filename: 'acme_ein_letter.txt', snippet: 'Entity Type: Limited Liability Company', location: 'CP 575 A', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-004', key: 'state_of_formation', value: 'Georgia', confidence: 0.95, confidence_label: 'HIGH', provenance: articlesFile ? { file_id: articlesFile.file_id, original_filename: 'acme_articles_of_incorporation.txt', snippet: 'forming a Georgia limited liability company', location: 'Preamble', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-005', key: 'fiscal_year_end', value: 'December 31', confidence: 0.9, confidence_label: 'HIGH', provenance: einFile ? { file_id: einFile.file_id, original_filename: 'acme_ein_letter.txt', snippet: 'Fiscal Year End: December', location: 'CP 575 A', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-006', key: 'address', value: '1847 Peachtree Road NE, Suite 310, Atlanta, GA 30309', confidence: 0.95, confidence_label: 'HIGH', provenance: articlesFile ? { file_id: articlesFile.file_id, original_filename: 'acme_articles_of_incorporation.txt', snippet: '1847 Peachtree Road NE, Suite 310, Atlanta, Georgia 30309', location: 'Section 2', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-007', key: 'formation_date', value: 'March 15, 2022', confidence: 0.95, confidence_label: 'HIGH', provenance: articlesFile ? { file_id: articlesFile.file_id, original_filename: 'acme_articles_of_incorporation.txt', snippet: 'EFFECTIVE DATE: March 15, 2022', location: 'Section 8', extraction_type: 'direct', extracted_at: now } : null },
          { attribute_id: 'ATTR-008', key: 'purpose', value: 'Management consulting, business advisory services, and technology consulting', confidence: 0.9, confidence_label: 'HIGH', provenance: articlesFile ? { file_id: articlesFile.file_id, original_filename: 'acme_articles_of_incorporation.txt', snippet: 'management consulting, business advisory services, and technology consulting', location: 'Section 6', extraction_type: 'direct', extracted_at: now } : null },
        ],
        relationships: [],
        values: [], key_facts: [], constraints: [], observations: [],
        provenance_chain: {
          created_at: now, created_by: 'demo',
          source_documents: [
            { source: 'demo_ingest:acme_ein_letter.txt', ingested_at: now },
            { source: 'demo_ingest:acme_articles_of_incorporation.txt', ingested_at: now },
          ],
          merge_history: [],
        },
        spoke_id: spokeId,
        source: 'manual',
        source_ref: 'demo_business_entity',
      };

      const newId = getNextCounter(req.graphDir, 'ACL');
      writeEntity(newId, bizEntity, req.graphDir);
      console.log(`[demo] Created business entity: ${newId}`);

      // Set as centered entity for the spoke
      setCenteredEntity(req.graphDir, spokeId, newId);
      console.log(`[demo] Set ${newId} as centered entity`);
    }

    // Step 3c: Confidence boost — bump direct extractions to minimum 0.85
    const postEnts = listEntities(req.graphDir).filter(e => e.data.spoke_id === spokeId);
    for (const { id: entId, data } of postEnts) {
      let changed = false;
      for (const attr of (data.attributes || [])) {
        if (attr.provenance && attr.provenance.extraction_type === 'direct' && attr.confidence != null && attr.confidence < 0.85) {
          attr.confidence = 0.85;
          attr.confidence_label = 'HIGH';
          changed = true;
        }
      }
      if (data.entity?.name?.confidence != null && data.entity.name.confidence < 0.85) {
        data.entity.name.confidence = 0.85;
        changed = true;
      }
      if (changed) writeEntity(entId, data, req.graphDir);
    }

    // Step 4: Run gap analysis
    const report = await analyzeGaps(spokeId, req.graphDir, 'tax_preparation');

    // Cache on spoke
    updateSpoke(req.graphDir, spokeId, { gap_analysis: report });

    res.json({
      status: 'demo_complete',
      spoke_id: spokeId,
      spoke_name: spokeName,
      template_type: 'tax_preparation',
      files_ingested: ingestResults,
      gap_report: report,
      message: `Acme Consulting LLC demo complete. ${files.length} documents ingested, ${report.entity_count} entities extracted. Completeness: ${Math.round(report.overall_score * 100)}%.`
    });
  } catch (err) {
    console.error('[demo] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// ---------------------------------------------------------------------------
// Connector Framework Endpoints (MECE-018)
// ---------------------------------------------------------------------------

// GET /api/connectors — List available providers + active connections
app.get('/api/connectors', apiAuth, (req, res) => {
  const providers = getRegisteredProviders();
  const connections = listConnections(req.graphDir);
  res.json({ providers, connections });
});

// POST /api/connect/:provider — Start OAuth flow, return authorize URL
app.post('/api/connect/:provider', apiAuth, (req, res) => {
  try {
    const { provider } = req.params;
    const providers = getRegisteredProviders();
    const providerInfo = providers.find(p => p.provider === provider);

    if (!providerInfo) return res.status(404).json({ error: `Unknown provider: ${provider}` });
    if (!providerInfo.configured) {
      return res.status(503).json({
        error: `${provider} not configured. Set environment variables: ${providerInfo.provider.toUpperCase()}_CLIENT_ID, ${providerInfo.provider.toUpperCase()}_CLIENT_SECRET`,
      });
    }

    const proto = req.headers['x-forwarded-proto'] || req.protocol;
    const host = req.headers['x-forwarded-host'] || req.get('host');
    const redirectUri = `${proto}://${host}/api/connect/callback`;

    const { url, state } = buildAuthorizeUrl(provider, redirectUri, req.tenantId);

    // Store state in httpOnly cookie (pattern from src/auth.js)
    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https' || process.env.NODE_ENV === 'production';
    res.cookie(OAUTH_STATE_COOKIE, state, {
      httpOnly: true,
      secure: isSecure,
      sameSite: 'lax',
      maxAge: 10 * 60 * 1000, // 10 minutes
    });

    res.json({ authorize_url: url });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// GET /api/connect/callback — OAuth callback (universal for all providers)
// No apiAuth — this is a redirect from the external provider.
// Authentication comes from the HMAC-signed state parameter.
app.get('/api/connect/callback', async (req, res) => {
  try {
    const { code, state: stateParam } = req.query;
    const savedState = req.cookies[OAUTH_STATE_COOKIE];

    if (!stateParam || !savedState || stateParam !== savedState) {
      return res.status(403).send('Invalid OAuth state. <a href="/wiki">Go back</a>');
    }
    res.clearCookie(OAUTH_STATE_COOKIE);

    if (!code) return res.status(400).send('Missing authorization code. <a href="/wiki">Go back</a>');

    // Decode state to get provider + tenant_id
    const { provider, tenant_id } = validateState(stateParam);

    // Resolve tenant graphDir
    const tenantDir = path.join(GRAPH_DIR, `tenant-${tenant_id}`);
    if (!fs.existsSync(tenantDir)) fs.mkdirSync(tenantDir, { recursive: true });

    // Exchange code for tokens
    const proto = req.headers['x-forwarded-proto'] || req.protocol;
    const host = req.headers['x-forwarded-host'] || req.get('host');
    const redirectUri = `${proto}://${host}/api/connect/callback`;

    const tokens = await exchangeCodeForTokens(provider, code, redirectUri);

    // Build config from token response (ShareFile returns subdomain/apicp)
    const config = {};
    if (tokens.subdomain) config.subdomain = tokens.subdomain;
    if (tokens.apicp) config.apicp = tokens.apicp;
    if (provider === 'sharefile' && !config.subdomain) {
      config.subdomain = process.env.SHAREFILE_SUBDOMAIN;
      config.apicp = 'sf-api.com';
    }

    // Create connection record with encrypted tokens
    const connection = createConnection(tenantDir, {
      provider,
      tokens: {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        token_type: tokens.token_type || 'Bearer',
        expires_in: tokens.expires_in,
      },
      display_name: `${provider} connection`,
      config,
    });

    // Validate connection (call "who am I" on the provider)
    const ConnectorClass = getConnectorClass(provider);
    if (ConnectorClass) {
      const connector = new ConnectorClass(tenantDir, connection.id);
      try {
        const info = await connector.connect();
        if (info.user_name) {
          updateConnection(tenantDir, connection.id, { display_name: info.user_name });
        }
      } catch (connectErr) {
        console.warn(`[connector] ${provider} validation warning:`, connectErr.message);
      }
    }

    // Redirect back to wiki with connection info
    res.redirect('/wiki?tab=connectors&connected=' + provider + '&connection_id=' + connection.id);
  } catch (err) {
    console.error('Connector OAuth callback error:', err.message);
    res.status(500).send('Connection failed: ' + err.message + '<br/><a href="/wiki">Go back</a>');
  }
});

// GET /api/connections — List active connections for this tenant
app.get('/api/connections', apiAuth, (req, res) => {
  const connections = listConnections(req.graphDir);
  res.json({ connections });
});

// GET /api/connection/:id/folders — Browse folders for spoke mapping (ShareFile)
app.get('/api/connection/:id/folders', apiAuth, async (req, res) => {
  const conn = getConnection(req.graphDir, req.params.id);
  if (!conn) return res.status(404).json({ error: 'Connection not found' });

  const ConnectorClass = getConnectorClass(conn.provider);
  if (!ConnectorClass) return res.status(400).json({ error: `No connector for: ${conn.provider}` });

  const connector = new ConnectorClass(req.graphDir, conn.id);
  if (typeof connector.browseFolders !== 'function') {
    return res.status(400).json({ error: `${conn.provider} does not support folder browsing` });
  }

  try {
    const parentId = req.query.parent || 'home';
    const folders = await connector.browseFolders(parentId);
    res.json({ folders, parent: parentId });
  } catch (err) {
    console.error(`[connector] Folder browse error:`, err.message);
    res.status(500).json({ error: 'Failed to browse folders: ' + err.message });
  }
});

// POST /api/connection/:id/map-folders — Map selected folders to spokes
app.post('/api/connection/:id/map-folders', apiAuth, (req, res) => {
  const conn = getConnection(req.graphDir, req.params.id);
  if (!conn) return res.status(404).json({ error: 'Connection not found' });

  const ConnectorClass = getConnectorClass(conn.provider);
  if (!ConnectorClass) return res.status(400).json({ error: `No connector for: ${conn.provider}` });

  const connector = new ConnectorClass(req.graphDir, conn.id);
  if (typeof connector.mapFoldersToSpokes !== 'function') {
    return res.status(400).json({ error: `${conn.provider} does not support folder mapping` });
  }

  try {
    const { folders } = req.body || {};
    if (!folders || !Array.isArray(folders) || folders.length === 0) {
      return res.status(400).json({ error: 'Missing folders array in body' });
    }
    const result = connector.mapFoldersToSpokes(folders);
    res.json(result);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// POST /api/sync/:connection_id — Trigger sync with NDJSON streaming
app.post('/api/sync/:connection_id', apiAuth, async (req, res) => {
  const conn = getConnection(req.graphDir, req.params.connection_id);
  if (!conn) return res.status(404).json({ error: 'Connection not found' });

  const ConnectorClass = getConnectorClass(conn.provider);
  if (!ConnectorClass) return res.status(400).json({ error: `No connector for: ${conn.provider}` });

  const connector = new ConnectorClass(req.graphDir, conn.id);

  // Set up NDJSON streaming response
  res.setHeader('Content-Type', 'application/x-ndjson');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no'); // Disable Nginx buffering

  const writeEvent = (event) => {
    try {
      res.write(JSON.stringify(event) + '\n');
    } catch {}
  };

  try {
    const results = await connector.sync(req.body || {}, writeEvent);
    // Final event already written by sync(), just end the stream
    res.end();
  } catch (err) {
    writeEvent({ type: 'error', message: err.message });
    res.end();
  }
});

// DELETE /api/connection/:id — Disconnect and remove a connection
app.delete('/api/connection/:id', apiAuth, async (req, res) => {
  const conn = getConnection(req.graphDir, req.params.id);
  if (!conn) return res.status(404).json({ error: 'Connection not found' });

  const ConnectorClass = getConnectorClass(conn.provider);
  if (ConnectorClass) {
    const connector = new ConnectorClass(req.graphDir, conn.id);
    try {
      await connector.disconnect();
    } catch (err) {
      console.warn(`[connector] Disconnect warning:`, err.message);
      // Still delete the connection even if revoke fails
      deleteConn(req.graphDir, req.params.id);
    }
  } else {
    deleteConn(req.graphDir, req.params.id);
  }

  res.json({ status: 'disconnected', provider: conn.provider });
});

// POST /api/webhook/:provider — Receive webhooks from external providers
// No apiAuth — webhooks come from external systems
app.post('/api/webhook/:provider', async (req, res) => {
  const { provider } = req.params;

  try {
    // Iterate tenant directories to find connections for this provider
    const tenantDirs = fs.readdirSync(GRAPH_DIR)
      .filter(d => d.startsWith('tenant-') && fs.statSync(path.join(GRAPH_DIR, d)).isDirectory());

    for (const dir of tenantDirs) {
      const tenantPath = path.join(GRAPH_DIR, dir);
      const connections = listConnections(tenantPath);
      const providerConns = connections.filter(c => c.provider === provider && c.status === 'connected');

      for (const conn of providerConns) {
        const ConnectorClass = getConnectorClass(provider);
        if (!ConnectorClass) continue;
        const connector = new ConnectorClass(tenantPath, conn.id);
        const result = await connector.handleWebhook(req.headers, req.body);

        // Handle webhook handshake (e.g., Clio X-Hook-Secret)
        if (result && result.handshake && result.hookSecret) {
          res.set('X-Hook-Secret', result.hookSecret);
          return res.status(200).json({ ok: true });
        }
      }
    }

    res.json({ ok: true });
  } catch (err) {
    console.error(`[webhook] ${provider} error:`, err.message);
    res.status(500).json({ error: err.message });
  }
});

// GET /api/search?q=&type=&spoke_id= — Fuzzy search entities with optional type/spoke filter
app.get('/api/search', apiAuth, (req, res) => {
  const q = (req.query.q || '').toLowerCase().trim();
  if (!q) return res.status(400).json({ error: 'Missing query parameter q' });

  const typeFilter = req.query.type
    ? req.query.type.split(',').map(t => t.trim().toLowerCase()).filter(Boolean)
    : null;
  const spokeFilter = req.query.spoke_id || null;

  const { similarity } = require('./merge-engine');
  let entities = listEntities(req.graphDir, spokeFilter ? { spokeId: spokeFilter } : undefined);

  // Apply type filter if specified
  if (typeFilter) {
    entities = entities.filter(({ data }) => {
      const type = (data.entity || {}).entity_type;
      return typeFilter.includes(type);
    });
  }

  // Resolve entity name across all types
  function getEntityName(e) {
    var type = e.entity_type;
    if (type === 'person') return e.name?.full || '';
    if (type === 'business') return e.name?.common || e.name?.legal || '';
    return e.name?.full || e.name?.common || '';
  }

  // Enrich person results with categorization text and trimmed attributes/relationships
  function enrichPersonResult(result, e, data) {
    if (e.entity_type !== 'person') return result;
    result.attributes = (data.attributes || []).map(a => ({ key: a.key, value: a.value }));
    result.relationships = (data.relationships || []).map(r => ({ name: r.name, relationship_type: r.relationship_type, context: r.context }));
    if (data.relationship_dimensions) result.relationship_dimensions = data.relationship_dimensions;
    if (data.descriptor) result.descriptor = data.descriptor;
    if (data.structured_attributes) result.structured_attributes = data.structured_attributes;
    return result;
  }

  // Wildcard: return all entities
  if (q === '*') {
    const all = entities.map(({ data }) => {
      const e = data.entity || {};
      const name = getEntityName(e);
      const r = { entity_id: e.entity_id, entity_type: e.entity_type, name, summary: e.summary?.value || '', match_score: 1.0, observation_count: (data.observations || []).length, relationship_count: (data.relationships || []).length };
      enrichPersonResult(r, e, data);
      if (data.relationship_dimensions) r.relationship_dimensions = data.relationship_dimensions;
      if (data.descriptor) r.descriptor = data.descriptor;
      if (data.org_dimensions) r.org_dimensions = data.org_dimensions;
      // Include attributes for org-type entities (needed for org_category in sidebar)
      if (e.entity_type === 'organization' || e.entity_type === 'business' || e.entity_type === 'institution') {
        r.attributes = (data.attributes || []).map(a => ({ key: a.key, value: a.value }));
      }
      return r;
    });
    return res.json({ query: q, count: all.length, results: all });
  }

  const results = [];

  for (const { data } of entities) {
    const e = data.entity || {};
    const type = e.entity_type;
    let name = getEntityName(e);
    let score = 0;

    // Check name similarity
    score = Math.max(score, similarity(q, name));

    // Check aliases
    const aliases = e.name?.aliases || [];
    for (const alias of aliases) {
      score = Math.max(score, similarity(q, alias));
    }

    // Check attributes for keyword match
    for (const attr of (data.attributes || [])) {
      if ((attr.value || '').toLowerCase().includes(q)) {
        score = Math.max(score, 0.6);
      }
    }

    // Check summary
    if ((e.summary?.value || '').toLowerCase().includes(q)) {
      score = Math.max(score, 0.5);
    }

    if (score > 0.3) {
      const r = {
        entity_id: e.entity_id,
        entity_type: type,
        name,
        summary: e.summary?.value || '',
        match_score: Math.round(score * 100) / 100,
        observation_count: (data.observations || []).length,
        relationship_count: (data.relationships || []).length,
      };
      enrichPersonResult(r, e, data);
      if (data.relationship_dimensions) r.relationship_dimensions = data.relationship_dimensions;
      if (data.descriptor) r.descriptor = data.descriptor;
      if (data.org_dimensions) r.org_dimensions = data.org_dimensions;
      // Include attributes for org-type entities (needed for org_category in sidebar)
      if (type === 'organization' || type === 'business' || type === 'institution') {
        r.attributes = (data.attributes || []).map(a => ({ key: a.key, value: a.value }));
      }
      results.push(r);
    }
  }

  results.sort((a, b) => b.match_score - a.match_score);
  res.json({ query: q, count: results.length, results });
});

// PATCH /api/entity/:id — Merge-update entity fields
app.patch('/api/entity/:id', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const now = new Date().toISOString();
  const updates = req.body;
  const changes = [];

  // Self entity protection: strip name.full, name.preferred, summary from PATCH
  const isSelf = isSelfEntity(req.params.id, req.graphDir);
  if (isSelf && updates.name) {
    delete updates.name.full;
    delete updates.name.preferred;
    if (Object.keys(updates.name).length === 0) delete updates.name;
  }
  if (isSelf && updates.summary != null) {
    delete updates.summary;
  }

  // Merge into entity.entity (name, summary, entity_type)
  if (updates.name && entity.entity) {
    Object.assign(entity.entity.name || {}, updates.name);
    changes.push('updated name');
  }
  if (updates.summary != null && entity.entity) {
    if (typeof entity.entity.summary === 'object') {
      entity.entity.summary.value = updates.summary;
    } else {
      entity.entity.summary = { value: updates.summary, confidence: 0.8 };
    }
    changes.push('updated summary');
  }

  // Merge attributes (append new ones, update existing by key)
  if (updates.attributes && entity.attributes) {
    if (typeof updates.attributes === 'object' && !Array.isArray(updates.attributes)) {
      // Object form: { role: "new value", location: "new value" }
      for (const [key, value] of Object.entries(updates.attributes)) {
        const existing = entity.attributes.find(a => a.key === key);
        if (existing) {
          existing.value = value;
          existing.confidence = 0.8;
          existing.confidence_label = 'STRONG';
          changes.push(`updated attribute ${key}`);
        } else {
          entity.attributes.push({
            attribute_id: `ATTR-${String(entity.attributes.length + 1).padStart(3, '0')}`,
            key, value, confidence: 0.8, confidence_label: 'STRONG',
            time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
            source_attribution: { facts_layer: 2, layer_label: 'group' },
          });
          changes.push(`added attribute ${key}`);
        }
      }
    }
  }

  // Merge relationships (append new, dedup by name)
  if (Array.isArray(updates.relationships)) {
    if (!entity.relationships) entity.relationships = [];
    for (const rel of updates.relationships) {
      const existing = entity.relationships.find(r =>
        (r.name || '').toLowerCase() === (rel.name || '').toLowerCase()
      );
      if (existing) {
        if (rel.relationship) existing.relationship_type = rel.relationship;
        if (rel.context) existing.context = rel.context;
        changes.push(`updated relationship ${rel.name}`);
      } else {
        entity.relationships.push({
          relationship_id: `REL-${String(entity.relationships.length + 1).padStart(3, '0')}`,
          name: rel.name, relationship_type: rel.relationship || '', context: rel.context || '',
          sentiment: 'neutral', confidence: 0.8, confidence_label: 'STRONG',
        });
        changes.push(`added relationship ${rel.name}`);
      }
    }
  }

  // Merge values (append new, dedup by value text)
  if (Array.isArray(updates.values)) {
    if (!entity.values) entity.values = [];
    for (const val of updates.values) {
      const valText = typeof val === 'string' ? val : val.value;
      const existing = entity.values.find(v => (v.value || '').toLowerCase() === valText.toLowerCase());
      if (!existing) {
        entity.values.push({
          value_id: `VAL-${String(entity.values.length + 1).padStart(3, '0')}`,
          value: valText, confidence: 0.8, confidence_label: 'STRONG',
        });
        changes.push(`added value ${valText}`);
      }
    }
  }

  // Update timestamps
  if (!entity.extraction_metadata) entity.extraction_metadata = {};
  entity.extraction_metadata.updated_at = now;

  // Provenance
  if (!entity.provenance_chain) {
    entity.provenance_chain = { created_at: now, created_by: 'api', source_documents: [], merge_history: [] };
  }
  entity.provenance_chain.merge_history = entity.provenance_chain.merge_history || [];
  entity.provenance_chain.merge_history.push({
    merged_at: now, merged_by: req.agentId, changes,
  });

  writeEntity(req.params.id, entity, req.graphDir);

  res.json({
    status: 'updated',
    entity_id: req.params.id,
    changes,
    updated_at: now,
  });
});

// PATCH /api/entity/:id/observation/:index/review — Set review status on a field (Build 8, upgraded Build 9)
app.patch('/api/entity/:id/observation/:index/review', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  // Build 9: action-based logic with backward compat
  const { action, corrected_value, reason, reviewed_by, field_key, status: legacyStatus, notes } = req.body;
  const effectiveAction = action || (legacyStatus === 'approved' ? 'approve' : legacyStatus === 'rejected' ? 'reject' : null);
  if (!effectiveAction || !['approve', 'reject', 'correct'].includes(effectiveAction)) {
    return res.status(400).json({ error: 'Invalid action. Must be approve, reject, or correct.' });
  }

  const now = new Date().toISOString();
  const reviewStatus = effectiveAction === 'approve' ? 'approved' : effectiveAction === 'reject' ? 'rejected' : 'corrected';
  const review = {
    status: reviewStatus,
    reviewed_by: reviewed_by || 'user',
    reviewed_at: now,
    notes: reason || notes || ''
  };

  // Handle correction: update the attribute value on the entity
  if (effectiveAction === 'correct' && corrected_value !== undefined && field_key) {
    const attrs = entity.attributes || [];
    const fieldKeyLower = field_key.toLowerCase().replace(/\s+/g, '_');
    let corrected = false;
    for (let i = 0; i < attrs.length; i++) {
      if ((attrs[i].key || '').toLowerCase().replace(/\s+/g, '_') === fieldKeyLower) {
        review.correction = { original_value: attrs[i].value, corrected_value: corrected_value };
        attrs[i].value = corrected_value;
        attrs[i].confidence = 1.0;
        if (!attrs[i].provenance) attrs[i].provenance = {};
        attrs[i].provenance.extraction_type = 'human_review';
        attrs[i].provenance.corrected_at = now;
        corrected = true;
        break;
      }
    }
    if (!corrected) {
      // Try nested entity fields (entity.entity.*)
      const entObj = entity.entity || {};
      const dotParts = field_key.split('.');
      if (dotParts.length === 2 && entObj[dotParts[0]]) {
        review.correction = { original_value: entObj[dotParts[0]][dotParts[1]], corrected_value: corrected_value };
        entObj[dotParts[0]][dotParts[1]] = corrected_value;
      } else if (dotParts.length === 1 && entObj[dotParts[0]] !== undefined) {
        review.correction = { original_value: entObj[dotParts[0]], corrected_value: corrected_value };
        entObj[dotParts[0]] = corrected_value;
      }
    }
  }

  // Store review in field_reviews map
  if (!entity.field_reviews) entity.field_reviews = {};
  if (field_key) {
    entity.field_reviews[field_key] = review;
  }

  // Also store on observation if index is valid
  const idx = parseInt(req.params.index);
  const obs = entity.observations || [];
  if (idx >= 0 && idx < obs.length) {
    obs[idx].review = review;
  }

  writeEntity(req.params.id, entity, req.graphDir);

  // Check if all fields for this entity's spoke are reviewed — update spoke status
  if (entity.spoke_id) {
    try {
      const spoke = getSpoke(req.graphDir, entity.spoke_id);
      if (spoke) {
        const exportData = buildSpokeExportData(spoke, req.graphDir);
        if (exportData) {
          const summary = computeReviewSummary(exportData);
          const updates = { review_summary: summary };
          if (summary.pending === 0 && summary.total > 0) {
            updates.review_status = 'complete';
          } else {
            updates.review_status = 'in_progress';
          }
          updateSpoke(req.graphDir, entity.spoke_id, updates);
        }
      }
    } catch (e) { /* non-critical */ }
  }

  res.json({ status: 'reviewed', entity_id: req.params.id, field_key, review });
});

// POST /api/spoke/:id/bulk-review — Bulk approve high-confidence non-critical fields (Build 9)
app.post('/api/spoke/:id/bulk-review', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });

  const exportData = buildSpokeExportData(spoke, req.graphDir);
  if (!exportData) return res.status(400).json({ error: 'No export data available' });

  const criticalKeys = ['ssn', 'ein', 'tax_id', 'account_number', 'bank', 'social_security', 'routing_number'];
  const now = new Date().toISOString();
  const reviewer = req.body.reviewed_by || 'user';
  let approvedCount = 0, skippedCount = 0;
  const modifiedEntities = {};

  for (const role of (exportData.roles || [])) {
    for (const ent of (role.entities || [])) {
      if (!ent.entity_id) { skippedCount += (ent.fields || []).length; continue; }
      for (const f of (ent.fields || [])) {
        // Skip already-reviewed fields
        if (f.review && ['approved', 'rejected', 'corrected'].includes(f.review.status)) {
          continue;
        }
        // Skip missing fields
        if (f.status === 'missing' || !f.value) { skippedCount++; continue; }
        // Skip critical fields
        const fieldLower = (f.field || '').toLowerCase();
        const isCritical = criticalKeys.some(k => fieldLower.indexOf(k) >= 0);
        if (isCritical) { skippedCount++; continue; }
        // Skip low-confidence fields
        if (f.confidence != null && f.confidence < 0.85) { skippedCount++; continue; }

        // Approve this field
        if (!modifiedEntities[ent.entity_id]) {
          modifiedEntities[ent.entity_id] = readEntity(ent.entity_id, req.graphDir);
        }
        const entity = modifiedEntities[ent.entity_id];
        if (!entity) { skippedCount++; continue; }
        if (!entity.field_reviews) entity.field_reviews = {};
        entity.field_reviews[f.field] = {
          status: 'approved',
          reviewed_by: reviewer,
          reviewed_at: now,
          notes: 'Bulk approved (high confidence)'
        };
        approvedCount++;
      }
    }
  }

  // Write all modified entities to disk
  for (const [entityId, entity] of Object.entries(modifiedEntities)) {
    writeEntity(entityId, entity, req.graphDir);
  }

  // Recompute review summary and update spoke
  const updatedExport = buildSpokeExportData(spoke, req.graphDir);
  const summary = updatedExport ? computeReviewSummary(updatedExport) : { total: 0, pending: 0, approved: 0, rejected: 0, corrected: 0 };
  const spokeUpdates = { review_summary: summary };
  if (summary.pending === 0 && summary.total > 0) {
    spokeUpdates.review_status = 'complete';
  } else {
    spokeUpdates.review_status = 'in_progress';
  }
  updateSpoke(req.graphDir, req.params.id, spokeUpdates);

  res.json({ approved: approvedCount, skipped: skippedCount, review_summary: summary });
});

// POST /api/observe — Append an observation to an existing entity
const CONFIDENCE_MAP = {
  VERIFIED: 1.0, STRONG: 0.8, MODERATE: 0.6, SPECULATIVE: 0.4, UNCERTAIN: 0.2,
};
const VALID_LAYERS = ['L1_OBJECTIVE', 'L2_GROUP', 'L3_PERSONAL'];

app.post('/api/observe', apiAuth, (req, res) => {
  const { entity_id, observation, confidence_label, facts_layer, source } = req.body;

  // Validate required fields
  if (!entity_id) return res.status(400).json({ error: 'Missing entity_id' });
  if (!observation || typeof observation !== 'string' || !observation.trim()) {
    return res.status(400).json({ error: 'Missing or empty observation string' });
  }
  if (!confidence_label || !CONFIDENCE_MAP.hasOwnProperty(confidence_label)) {
    return res.status(400).json({
      error: 'Invalid confidence_label. Must be one of: ' + Object.keys(CONFIDENCE_MAP).join(', '),
    });
  }
  if (!facts_layer || !VALID_LAYERS.includes(facts_layer)) {
    return res.status(400).json({
      error: 'Invalid facts_layer. Must be one of: ' + VALID_LAYERS.join(', '),
    });
  }

  // Validate entity exists
  const entity = readEntity(entity_id, req.graphDir);
  if (!entity) return res.status(404).json({ error: `Entity ${entity_id} not found` });

  // Build observation
  const now = new Date().toISOString();
  if (!entity.observations) entity.observations = [];
  const seq = String(entity.observations.length + 1).padStart(3, '0');
  const tsCompact = now.replace(/[-:T]/g, '').slice(0, 14);
  const obsId = `OBS-${entity_id}-${tsCompact}-${seq}`;

  const obs = {
    observation_id: obsId,
    observation: observation.trim(),
    confidence: CONFIDENCE_MAP[confidence_label],
    confidence_label,
    facts_layer,
    layer_number: parseInt(facts_layer.charAt(1)),
    observed_at: now,
    observed_by: req.agentId,
    source: source || null,
  };

  entity.observations.push(obs);

  // Log to provenance chain
  if (!entity.provenance_chain) {
    entity.provenance_chain = { created_at: now, created_by: 'api', source_documents: [], merge_history: [] };
  }
  entity.provenance_chain.merge_history = entity.provenance_chain.merge_history || [];
  entity.provenance_chain.merge_history.push({
    merged_at: now,
    merged_by: req.agentId,
    changes: [`added observation ${obsId}`],
  });

  writeEntity(entity_id, entity, req.graphDir);

  res.status(201).json({
    status: 'created',
    entity_id,
    observation: obs,
  });
});

// POST /api/entity — Create a new entity with auto-generated ID
app.post('/api/entity', apiAuth, (req, res) => {
  const { entity_type, name, summary, attributes, relationships, values, source } = req.body;

  // Validate required fields
  if (!entity_type || !['person', 'business', 'institution'].includes(entity_type)) {
    return res.status(400).json({ error: 'entity_type is required and must be "person", "business", or "institution"' });
  }
  if (!name || typeof name !== 'object') {
    return res.status(400).json({ error: 'name is required and must be an object (e.g. { "full": "John Smith" })' });
  }
  const displayName = entity_type === 'person'
    ? (name.full || name.preferred || '')
    : (name.common || name.legal || '');
  if (!displayName) {
    return res.status(400).json({ error: entity_type === 'person' ? 'name.full is required' : 'name.common or name.legal is required' });
  }

  // Check for duplicate names
  const { similarity } = require('./merge-engine');
  const entities = listEntities(req.graphDir);
  for (const { data } of entities) {
    const e = data.entity || {};
    if (e.entity_type !== entity_type) continue;
    const existingName = entity_type === 'person'
      ? (e.name?.full || '')
      : (e.name?.common || e.name?.legal || '');
    if (existingName && similarity(displayName, existingName) > 0.85) {
      return res.status(409).json({
        error: `Entity "${existingName}" (${e.entity_id}) already exists with similar name. Use PATCH to update.`,
        existing_entity_id: e.entity_id,
      });
    }
  }

  // Generate entity_id
  let initials;
  if (entity_type === 'person') {
    initials = displayName.split(/\s+/).map(w => w[0]).join('').toUpperCase();
  } else if (entity_type === 'institution') {
    initials = 'INST-' + displayName.split(/\s+/).map(w => w[0]).join('').toUpperCase();
  } else {
    initials = 'BIZ-' + displayName.split(/\s+/).map(w => w[0]).join('').toUpperCase();
  }
  const seq = getNextCounter(req.graphDir, entity_type);
  const entityId = `ENT-${initials}-${String(seq).padStart(3, '0')}`;

  // Build v2-compatible entity
  const now = new Date().toISOString();
  const entityData = {
    schema_version: '2.0',
    schema_type: 'context_architecture_entity',
    extraction_metadata: {
      extracted_at: now,
      updated_at: now,
      source_description: source || 'API create',
      extraction_model: 'manual',
      extraction_confidence: 0.8,
      schema_version: '2.0',
    },
    entity: {
      entity_type,
      entity_id: entityId,
      name: { ...name, confidence: 0.9, facts_layer: 1 },
      summary: summary
        ? { value: summary, confidence: 0.8, facts_layer: 2 }
        : { value: '', confidence: 0, facts_layer: 2 },
    },
    attributes: [],
    relationships: [],
    values: [],
    key_facts: [],
    constraints: [],
    observations: [],
    ownership: 'owned',
    owner_tenant_id: req.tenantId || null,
    access_rules: { visibility: 'private', shared_with: [] },
    projection_config: { lenses: ['default'] },
    perspectives: [],
    provenance_chain: {
      created_at: now,
      created_by: req.agentId,
      source_documents: source ? [{ source: source, ingested_at: now }] : [],
      merge_history: [],
    },
  };

  // Populate attributes from object
  if (attributes && typeof attributes === 'object') {
    let attrSeq = 1;
    for (const [key, value] of Object.entries(attributes)) {
      const val = Array.isArray(value) ? value.join(', ') : String(value);
      entityData.attributes.push({
        attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`,
        key, value: val, confidence: 0.8, confidence_label: 'STRONG',
        time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
        source_attribution: { facts_layer: 1, layer_label: 'objective' },
      });
    }
  }

  // Populate relationships
  if (Array.isArray(relationships)) {
    let relSeq = 1;
    for (const rel of relationships) {
      entityData.relationships.push({
        relationship_id: `REL-${String(relSeq++).padStart(3, '0')}`,
        name: rel.name || '', relationship_type: rel.relationship || '', context: rel.context || '',
        sentiment: 'neutral', confidence: 0.8, confidence_label: 'STRONG',
      });
    }
  }

  // Populate values
  if (Array.isArray(values)) {
    let valSeq = 1;
    for (const v of values) {
      const valText = typeof v === 'string' ? v : v.value || '';
      entityData.values.push({
        value_id: `VAL-${String(valSeq++).padStart(3, '0')}`,
        value: valText, confidence: 0.8, confidence_label: 'STRONG',
      });
    }
  }

  writeEntity(entityId, entityData, req.graphDir);

  res.status(201).json({
    status: 'created',
    entity_id: entityId,
    entity_type,
    name: displayName,
    entity: entityData,
  });
});

// POST /api/entity/:id/observe — Add observation via entity URL (DXT-friendly)
app.post('/api/entity/:id/observe', apiAuth, (req, res) => {
  const entityId = req.params.id;
  const entity = readEntity(entityId, req.graphDir);
  if (!entity) return res.status(404).json({ error: `Entity ${entityId} not found` });

  const { attribute, value, observation, confidence, confidence_label, facts_layer, source, truth_level, provenance } = req.body;

  // Accept either observation string or attribute+value pair
  const obsText = observation || (attribute && value ? `${attribute}: ${value}` : null);
  if (!obsText) return res.status(400).json({ error: 'Provide observation string or attribute+value pair' });

  const confLabel = confidence_label || (confidence >= 0.8 ? 'STRONG' : confidence >= 0.6 ? 'MODERATE' : 'SPECULATIVE');
  const layer = facts_layer || 'L1_OBJECTIVE';

  const now = new Date().toISOString();
  if (!entity.observations) entity.observations = [];
  const seq = String(entity.observations.length + 1).padStart(3, '0');
  const tsCompact = now.replace(/[-:T]/g, '').slice(0, 14);
  const obsId = `OBS-${entityId}-${tsCompact}-${seq}`;

  const obs = {
    observation_id: obsId,
    observation: obsText.trim(),
    confidence: confidence || CONFIDENCE_MAP[confLabel] || 0.6,
    confidence_label: confLabel,
    facts_layer: layer,
    layer_number: parseInt(layer.charAt(1)) || 1,
    truth_level: truth_level || 'INFERRED',
    observed_at: now,
    observed_by: req.agentId,
    source: source || 'conversation',
    provenance: provenance || null,
  };

  entity.observations.push(obs);
  writeEntity(entityId, entity, req.graphDir);

  res.status(201).json({ status: 'created', entity_id: entityId, observation: obs });
});

// --- Provenance Query Helper ---
function buildProvenanceReport(entity) {
  const fields = {};
  // Gather provenance from attributes
  for (const attr of (entity.attributes || [])) {
    const key = attr.key;
    if (!fields[key]) {
      fields[key] = { value: attr.value, confidence: attr.confidence, sources: [], conflict: false, values: [attr.value] };
    } else {
      if (!fields[key].values.includes(attr.value)) {
        fields[key].values.push(attr.value);
        fields[key].conflict = true;
      }
    }
    if (attr.provenance) {
      fields[key].sources.push({
        file_id: attr.provenance.file_id,
        filename: attr.provenance.original_filename,
        snippet: attr.provenance.snippet,
        location: attr.provenance.location,
        extraction_type: attr.provenance.extraction_type,
        extracted_at: attr.provenance.extracted_at,
      });
    }
  }
  // Gather provenance from observations that match attribute patterns
  for (const obs of (entity.observations || [])) {
    if (obs.provenance) {
      // Try to match observation to attribute key via "key: value" pattern
      const match = (obs.observation || '').match(/^([^:]+):\s*(.+)$/);
      if (match) {
        const key = match[1].trim().toLowerCase();
        const val = match[2].trim();
        if (!fields[key]) {
          fields[key] = { value: val, confidence: obs.confidence, sources: [], conflict: false, values: [val] };
        } else {
          if (!fields[key].values.includes(val)) {
            fields[key].values.push(val);
            fields[key].conflict = true;
          }
        }
        fields[key].sources.push({
          file_id: obs.provenance.file_id,
          filename: obs.provenance.original_filename,
          snippet: obs.provenance.snippet,
          location: obs.provenance.location,
          extraction_type: obs.provenance.extraction_type,
          extracted_at: obs.provenance.extracted_at,
        });
      }
    }
  }
  // Clean up temporary values array
  for (const key of Object.keys(fields)) {
    delete fields[key].values;
  }
  return fields;
}

// GET /api/entity/:id/provenance — Full provenance report for entity
app.get('/api/entity/:id/provenance', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: `Entity ${req.params.id} not found` });
  const eName = entity.entity?.name?.full || entity.entity?.name?.common || req.params.id;
  const fields = buildProvenanceReport(entity);
  res.json({ entity_id: req.params.id, entity_name: eName, fields });
});

// GET /api/entity/:id/provenance/:attribute — Single attribute provenance
app.get('/api/entity/:id/provenance/:attribute', apiAuth, (req, res) => {
  const entity = readEntity(req.params.id, req.graphDir);
  if (!entity) return res.status(404).json({ error: `Entity ${req.params.id} not found` });
  const eName = entity.entity?.name?.full || entity.entity?.name?.common || req.params.id;
  const fields = buildProvenanceReport(entity);
  const attrKey = req.params.attribute.toLowerCase();
  const field = fields[attrKey];
  if (!field) return res.status(404).json({ error: `No provenance found for attribute "${req.params.attribute}"` });
  res.json({ entity_id: req.params.id, entity_name: eName, attribute: attrKey, ...field });
});

// GET /api/spoke/:id/conflicts — Detect conflicting sources across spoke entities
app.get('/api/spoke/:id/conflicts', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });
  const allEnts = listEntities(req.graphDir);
  const conflicts = [];
  for (const { id: entId, data } of allEnts) {
    if (data.spoke_id !== req.params.id) continue;
    const eName = data.entity?.name?.full || data.entity?.name?.common || entId;
    const fields = buildProvenanceReport(data);
    for (const [attrKey, field] of Object.entries(fields)) {
      if (field.conflict) {
        // Rebuild values list for conflict report
        const values = [];
        for (const attr of (data.attributes || [])) {
          if (attr.key === attrKey && attr.provenance) {
            values.push({ value: attr.value, file: attr.provenance.original_filename, snippet: attr.provenance.snippet });
          }
        }
        conflicts.push({ entity: eName, entity_id: entId, attribute: attrKey, values });
      }
    }
  }
  res.json({ spoke_id: req.params.id, conflicts, conflict_count: conflicts.length });
});

// --- Export Helper: match entities to template roles (evidence-based) ---
// Role-specific keyword evidence for positive matching
const _ROLE_EVIDENCE = {
  business_entity: { namePatterns: /\b(llc|inc|corp|lp|llp|partnership|l\.l\.c|incorporated|corporation)\b/i },
  owner_member: { attrKeywords: ['member', 'owner', 'partner', 'shareholder'], attrKeys: ['membership_interest', 'ownership_percentage', 'ownership', 'partner_type'] },
  registered_agent: { attrKeywords: ['registered agent'] },
  tax_preparer: { attrKeywords: ['preparer', 'tax preparer', 'accountant', 'cpa'] },
};

function _exportMatchEntityToRole(role, entities, spokeName) {
  const validTypes = TYPE_ALIASES[role.type] || [role.type];
  const evidence = _ROLE_EVIDENCE[role.role] || {};

  // For business_entity: match by type OR name pattern OR spoke name match
  if (role.role === 'business_entity') {
    const matched = entities.filter(ent => {
      const eType = ent.entity?.entity_type || ent.entity_type || '';
      if (validTypes.includes(eType)) return true;
      const eName = (ent.entity?.name?.full || ent.entity?.name?.common || '').toLowerCase();
      if (spokeName && eName && eName === spokeName.toLowerCase()) return true;
      if (evidence.namePatterns && evidence.namePatterns.test(eName)) return true;
      return false;
    });
    return matched;
  }

  // For person roles: type-match first, then require positive evidence
  const typeCandidates = entities.filter(ent => {
    const eType = ent.entity?.entity_type || ent.entity_type || '';
    return validTypes.includes(eType);
  });
  if (typeCandidates.length === 0) return [];

  const keywords = evidence.attrKeywords || [role.role.replace(/_/g, ' ')];
  const evidenceKeys = evidence.attrKeys || [];

  const matched = typeCandidates.filter(ent => {
    // Check attribute values for role keywords (e.g., role: "Member")
    const attrs = ent.attributes || [];
    for (const attr of attrs) {
      const val = (attr.value || '').toLowerCase();
      const key = (attr.key || '').toLowerCase();
      // Check if any keyword appears in attribute values
      if (keywords.some(kw => val.includes(kw))) return true;
      // Check if entity has a role-specific attribute key (e.g., membership_interest)
      if (evidenceKeys.some(ek => key.includes(ek))) return true;
    }
    // Check observations text
    const obs = ent.observations || [];
    const rels = ent.relationships || [];
    const allText = [
      ...rels.map(r => (r.relationship || '') + ' ' + (r.context || '')),
      ...obs.map(o => (o.observation || '') + ' ' + (o.value || ''))
    ].join(' ').toLowerCase();
    if (keywords.some(kw => allText.includes(kw))) return true;
    return false;
  });

  // Deduplicate by name — keep the entity with the most attributes per unique name
  const byName = {};
  for (const ent of matched) {
    const name = (ent.entity?.name?.full || ent.entity?.name?.common || ent._id || '').toLowerCase().trim();
    if (!byName[name] || (ent.attributes || []).length > (byName[name].attributes || []).length) {
      byName[name] = ent;
    }
  }
  return Object.values(byName);
}

// --- Export Helper: find field value + provenance from report ---
function _exportFindField(provenanceReport, entity, fieldName) {
  const aliases = FIELD_ALIASES[fieldName] || [fieldName];
  // Check provenance report keys (alias match)
  for (const alias of aliases) {
    if (provenanceReport[alias]) return provenanceReport[alias];
  }
  // For name fields, check entity.entity.name
  if (fieldName === 'full_name' || fieldName === 'legal_name') {
    const name = entity.entity?.name || {};
    const nameVal = name.full || name.common || name.preferred;
    if (nameVal) {
      return { value: nameVal, confidence: name.confidence || 0.9, sources: [], conflict: false };
    }
  }
  return null;
}

// --- Review summary computation helper (Build 9) ---
function computeReviewSummary(exportData, graphDir) {
  if (!exportData || !exportData.roles) return { total: 0, pending: 0, approved: 0, rejected: 0, corrected: 0 };
  var total = 0, pending = 0, approved = 0, rejected = 0, corrected = 0;
  for (const role of exportData.roles) {
    for (const ent of (role.entities || [])) {
      for (const f of (ent.fields || [])) {
        if (f.status === 'missing') continue;
        total++;
        if (f.review && f.review.status === 'approved') approved++;
        else if (f.review && f.review.status === 'rejected') rejected++;
        else if (f.review && f.review.status === 'corrected') corrected++;
        else pending++;
      }
    }
  }
  return { total, pending, approved, rejected, corrected };
}

// --- Reusable spoke export data builder ---
function buildSpokeExportData(spoke, graphDir) {
  const templateType = spoke.template_type;
  if (!templateType) return null;
  const template = getTemplate(templateType);
  if (!template) return null;

  const allEnts = listEntities(graphDir);
  const spokeEntities = allEnts
    .filter(e => e.data.spoke_id === spoke.id)
    .map(e => ({ ...e.data, _id: e.id }));

  const roles = [];
  let totalFields = 0, verified = 0, lowConf = 0, missing = 0, conflictCount = 0;

  for (const role of (template.required_entities || [])) {
    const matched = _exportMatchEntityToRole(role, spokeEntities, spoke.name);
    const roleData = { role: role.role, entities: [] };

    if (matched.length === 0 && !role.optional) {
      const fields = (role.required_fields || []).map(f => {
        totalFields++;
        missing++;
        return { field: f, value: null, status: 'missing', confidence: null, provenance: null };
      });
      roleData.entities.push({ entity_id: null, entity_name: '(not found)', fields });
    } else {
      for (const entity of matched) {
        const entityId = entity._id || entity.entity?.entity_id;
        const entityName = entity.entity?.name?.full || entity.entity?.name?.common || entityId || '(unknown)';
        const provenanceReport = buildProvenanceReport(entity);
        const fields = [];

        for (const fieldName of (role.required_fields || [])) {
          totalFields++;
          const fieldData = _exportFindField(provenanceReport, entity, fieldName);

          if (!fieldData) {
            missing++;
            fields.push({ field: fieldName, value: null, status: 'missing', confidence: null, provenance: null });
          } else if (fieldData.conflict) {
            conflictCount++;
            const src = fieldData.sources && fieldData.sources[0];
            fields.push({
              field: fieldName,
              value: fieldData.value,
              status: 'conflict',
              confidence: fieldData.confidence,
              provenance: src ? { file_id: src.file_id, filename: src.filename, snippet: src.snippet, location: src.location } : null,
              all_sources: fieldData.sources
            });
          } else if (fieldData.confidence != null && fieldData.confidence < 0.8) {
            lowConf++;
            const src = fieldData.sources && fieldData.sources[0];
            fields.push({
              field: fieldName,
              value: fieldData.value,
              status: 'low_confidence',
              confidence: fieldData.confidence,
              provenance: src ? { file_id: src.file_id, filename: src.filename, snippet: src.snippet, location: src.location } : null
            });
          } else {
            verified++;
            const src = fieldData.sources && fieldData.sources[0];
            fields.push({
              field: fieldName,
              value: fieldData.value,
              status: 'verified',
              confidence: fieldData.confidence,
              provenance: src ? { file_id: src.file_id, filename: src.filename, snippet: src.snippet, location: src.location } : null
            });
          }
        }

        // Attach persisted review state from entity.field_reviews (Build 9 — critical page-refresh fix)
        const reviews = entity.field_reviews || {};
        for (const fd of fields) {
          if (reviews[fd.field]) {
            fd.review = reviews[fd.field];
          }
        }

        roleData.entities.push({ entity_id: entityId, entity_name: entityName, fields });
      }
    }

    roles.push(roleData);
  }

  const exportResult = {
    spoke_id: spoke.id,
    spoke_name: spoke.name,
    template_type: templateType,
    exported_at: new Date().toISOString(),
    roles,
    summary: { total_fields: totalFields, verified, low_confidence: lowConf, missing, conflicts: conflictCount }
  };

  // Compute review summary (Build 9)
  exportResult.review_summary = computeReviewSummary(exportResult);

  return exportResult;
}

// GET /api/spoke/:id/export — Structured data export with provenance table
app.get('/api/spoke/:id/export', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });

  if (!spoke.template_type) {
    return res.status(400).json({
      error: 'No template assigned to this spoke. Assign one with PUT /api/spoke/:id/template first.',
      available_templates: Object.keys(loadTemplates())
    });
  }

  const exportData = buildSpokeExportData(spoke, req.graphDir);
  if (!exportData) return res.status(404).json({ error: `Template "${spoke.template_type}" not found` });

  // CSV format
  if (req.query.format === 'csv') {
    const csvRows = [['Role', 'Entity', 'Field', 'Value', 'Confidence', 'Status', 'Source File', 'Source Location', 'Snippet']];
    for (const role of exportData.roles) {
      for (const ent of role.entities) {
        for (const f of ent.fields) {
          csvRows.push([
            role.role,
            ent.entity_name,
            f.field,
            f.value || '',
            f.confidence != null ? String(f.confidence) : '',
            f.status,
            f.provenance?.filename || '',
            f.provenance?.location || '',
            f.provenance?.snippet || ''
          ]);
        }
      }
    }
    const csv = csvRows.map(row => row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(',')).join('\n');
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${(spoke.name || 'export').replace(/[^a-zA-Z0-9 ]/g, '')}-export.csv"`);
    return res.send(csv);
  }

  res.json(exportData);
});

// POST /api/entity/:id/relationship — Add relationship to entity (DXT-friendly)
app.post('/api/entity/:id/relationship', apiAuth, (req, res) => {
  const entityId = req.params.id;
  const entity = readEntity(entityId, req.graphDir);
  if (!entity) return res.status(404).json({ error: `Entity ${entityId} not found` });

  const { target_id, target_name, relationship, context, confidence, source } = req.body;
  if (!relationship) return res.status(400).json({ error: 'Missing relationship type' });
  if (!target_id && !target_name) return res.status(400).json({ error: 'Provide target_id or target_name' });

  // Resolve target entity
  let resolvedTargetId = target_id;
  let resolvedTargetName = target_name || '';
  if (!resolvedTargetId && target_name) {
    const { similarity } = require('./merge-engine');
    const entities = listEntities(req.graphDir);
    for (const { data } of entities) {
      const e = data.entity || {};
      const eName = e.name?.full || e.name?.common || e.name?.preferred || '';
      if (eName && similarity(target_name, eName) > 0.8) {
        resolvedTargetId = e.entity_id;
        resolvedTargetName = eName;
        break;
      }
    }
  }
  if (!resolvedTargetId) return res.status(404).json({ error: `Target entity "${target_name}" not found` });

  // Verify target exists
  const targetEntity = readEntity(resolvedTargetId, req.graphDir);
  if (!targetEntity) return res.status(404).json({ error: `Target entity ${resolvedTargetId} not found` });

  if (!entity.relationships) entity.relationships = [];
  const relSeq = String(entity.relationships.length + 1).padStart(3, '0');
  const relId = `REL-${relSeq}`;

  const rel = {
    relationship_id: relId,
    name: resolvedTargetName,
    entity_id: resolvedTargetId,
    relationship_type: relationship,
    context: context || '',
    sentiment: 'neutral',
    confidence: confidence || 0.8,
    confidence_label: confidence >= 0.8 ? 'STRONG' : 'MODERATE',
    source: source || 'conversation',
  };

  entity.relationships.push(rel);
  writeEntity(entityId, entity, req.graphDir);

  res.status(201).json({ status: 'created', entity_id: entityId, relationship: rel });
});

// DELETE /api/observe/:id — Delete a specific observation
app.delete('/api/observe/:id', apiAuth, (req, res) => {
  const obsId = req.params.id;
  const entities = listEntities(req.graphDir);

  for (const { file, data } of entities) {
    const observations = data.observations || [];
    const idx = observations.findIndex(o => o.observation_id === obsId);
    if (idx !== -1) {
      const removed = observations.splice(idx, 1)[0];
      const entityId = data.entity?.entity_id || file.replace('.json', '');

      // Log to provenance
      if (!data.provenance_chain) {
        data.provenance_chain = { created_at: new Date().toISOString(), created_by: 'api', source_documents: [], merge_history: [] };
      }
      data.provenance_chain.merge_history = data.provenance_chain.merge_history || [];
      data.provenance_chain.merge_history.push({
        merged_at: new Date().toISOString(),
        merged_by: req.agentId,
        changes: [`deleted observation ${obsId}`],
      });

      writeEntity(entityId, data, req.graphDir);

      return res.json({
        status: 'deleted',
        observation_id: obsId,
        entity_id: entityId,
        deleted_observation: removed,
      });
    }
  }

  res.status(404).json({ error: `Observation ${obsId} not found` });
});

// POST /api/extract — Extract from raw text (v2 schema)
app.post('/api/extract', apiAuth, async (req, res) => {
  const { text, type } = req.body;
  if (!text || !type) return res.status(400).json({ error: 'Missing text or type' });
  if (!['person', 'business'].includes(type)) return res.status(400).json({ error: 'Type must be person or business' });

  try {
    // Use v2 extraction via context-engine
    const { execFile } = require('child_process');
    const tmpIn = path.join(__dirname, 'watch-folder', 'output', `_api_input_${Date.now()}.txt`);
    const tmpOut = path.join(__dirname, 'watch-folder', 'output', `_api_output_${Date.now()}.json`);

    fs.writeFileSync(tmpIn, text);

    await new Promise((resolve, reject) => {
      execFile('node', [
        path.join(__dirname, 'context-engine.js'),
        '--input', tmpIn, '--output', tmpOut, '--type', type, '--schema-version', '2.0',
      ], {
        env: { ...process.env, PATH: `/opt/homebrew/bin:${process.env.PATH}` },
        timeout: 180000,
      }, (err) => err ? reject(err) : resolve());
    });

    const result = JSON.parse(fs.readFileSync(tmpOut, 'utf-8'));

    // Clean up temp input
    fs.unlinkSync(tmpIn);

    // Auto-add to graph if entity_id present
    const entityId = result.entity?.entity_id;
    if (entityId) {
      const existing = readEntity(entityId, req.graphDir);
      if (existing) {
        const { merged } = merge(existing, result);
        if (merged) writeEntity(entityId, merged, req.graphDir);
      } else {
        writeEntity(entityId, result, req.graphDir);
      }
    }

    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// --- Social profile URL parsing helpers ---
function detectSocialPlatform(url) {
  if (/x\.com\/\w+|twitter\.com\/\w+/i.test(url)) return 'x';
  if (/instagram\.com\/\w+/i.test(url)) return 'instagram';
  return null;
}

function parseSocialMeta(html, url, platform) {
  const ogTitle = html.match(/<meta\s+(?:property|name)="og:title"\s+content="([^"]*?)"/i)?.[1]
    || html.match(/<meta\s+content="([^"]*?)"\s+(?:property|name)="og:title"/i)?.[1] || '';
  const ogDesc = html.match(/<meta\s+(?:property|name)="og:description"\s+content="([^"]*?)"/i)?.[1]
    || html.match(/<meta\s+content="([^"]*?)"\s+(?:property|name)="og:description"/i)?.[1] || '';
  const ogImage = html.match(/<meta\s+(?:property|name)="og:image"\s+content="([^"]*?)"/i)?.[1]
    || html.match(/<meta\s+content="([^"]*?)"\s+(?:property|name)="og:image"/i)?.[1] || '';
  const title = html.match(/<title>([^<]*?)<\/title>/i)?.[1] || '';

  let handle = '';
  if (platform === 'x') {
    handle = url.match(/(?:x\.com|twitter\.com)\/(@?\w+)/i)?.[1] || '';
    if (handle && !handle.startsWith('@')) handle = '@' + handle;
  } else if (platform === 'instagram') {
    handle = url.match(/instagram\.com\/(@?\w+)/i)?.[1] || '';
    if (handle && !handle.startsWith('@')) handle = '@' + handle;
  }

  // Extract follower count from description (common pattern: "X Followers")
  let followerCount = null;
  const followerMatch = ogDesc.match(/([\d,.]+[KMB]?)\s*(?:Followers|followers)/i);
  if (followerMatch) {
    let raw = followerMatch[1].replace(/,/g, '');
    if (/K$/i.test(raw)) followerCount = Math.round(parseFloat(raw) * 1000);
    else if (/M$/i.test(raw)) followerCount = Math.round(parseFloat(raw) * 1000000);
    else if (/B$/i.test(raw)) followerCount = Math.round(parseFloat(raw) * 1000000000);
    else followerCount = parseInt(raw, 10);
  }

  // Clean name from og:title (remove trailing " on X" or " (@handle)" etc.)
  let name = ogTitle
    .replace(/\s*\(@?\w+\)\s*/g, '')
    .replace(/\s*on\s+(?:X|Twitter|Instagram)\s*$/i, '')
    .replace(/\s*\|\s*.*$/, '')
    .replace(/\s*[-–]\s*.*$/, '')
    .trim();

  // Bio: og:description minus the follower/following stats prefix
  let bio = ogDesc
    .replace(/^[\d,.]+[KMB]?\s*Followers?,?\s*[\d,.]+[KMB]?\s*Following,?\s*[\d,.]+[KMB]?\s*Posts?\s*[-–]?\s*/i, '')
    .trim();

  return { name, bio, handle, followerCount, profileImage: ogImage, platform, title };
}

function socialMetaToEntity(meta, url, agentId) {
  if (!meta.name && !meta.handle) return null;
  const now = new Date().toISOString();
  const displayName = meta.name || meta.handle.replace(/^@/, '');
  const sourceAttribution = { type: meta.platform, url: url, extracted_at: now };

  const attributes = [];
  let attrSeq = 1;
  if (meta.handle) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: `${meta.platform}_handle`, value: meta.handle, confidence: 1.0, confidence_label: 'VERIFIED', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 1, layer_label: 'self' } });
  if (meta.bio) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: `${meta.platform}_bio`, value: meta.bio, confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'volatile', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
  if (meta.followerCount) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: `${meta.platform}_followers`, value: String(meta.followerCount), confidence: 0.7, confidence_label: 'MODERATE', time_decay: { stability: 'volatile', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
  attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: `${meta.platform}_url`, value: url, confidence: 1.0, confidence_label: 'VERIFIED', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 1, layer_label: 'self' } });

  const observations = [];
  if (meta.bio) observations.push({ observation: `${meta.platform === 'x' ? 'X (Twitter)' : 'Instagram'} bio: ${meta.bio}`, observed_at: now, source: `${meta.platform}_profile`, source_url: url, confidence: 0.8, confidence_label: 'HIGH', truth_level: 'STRONG', facts_layer: 'L2_GROUP', layer_number: 2, observed_by: agentId });
  observations.push({ observation: `Social profile imported from ${url}`, observed_at: now, source: `${meta.platform}_profile`, source_url: url, confidence: 1.0, confidence_label: 'VERIFIED', truth_level: 'STRONG', facts_layer: 'L1_SELF', layer_number: 1, observed_by: agentId });

  return {
    schema_version: '2.0', schema_type: 'context_architecture_entity',
    extraction_metadata: { extracted_at: now, updated_at: now, source_description: `${meta.platform}_profile:${url}`, extraction_model: 'meta-tag-parser', extraction_confidence: 0.7, schema_version: '2.0' },
    entity: {
      entity_type: 'person',
      name: { full: displayName, preferred: '', aliases: meta.handle ? [meta.handle] : [], confidence: 0.7, facts_layer: 2 },
      summary: meta.bio ? { value: meta.bio, confidence: 0.7, facts_layer: 2 } : { value: '', confidence: 0, facts_layer: 2 },
    },
    attributes, relationships: [], values: [], key_facts: [], constraints: [], observations,
    provenance_chain: { created_at: now, created_by: agentId, source_documents: [{ source: `${meta.platform}_profile:${url}`, url, ingested_at: now }], merge_history: [] },
  };
}

// POST /api/extract-url — Extract entities from any public URL
app.post('/api/extract-url', apiAuth, async (req, res) => {
  const { url } = req.body;
  if (!url || typeof url !== 'string') {
    return res.status(400).json({ error: 'Missing "url" field' });
  }
  if (!/^https?:\/\//i.test(url)) {
    return res.status(400).json({ error: 'URL must start with http:// or https://' });
  }

  try {
    // --- Smart URL Router ---
    // LinkedIn URLs → ScrapingDog API (structured data, higher confidence)
    if (/linkedin\.com\/in\//i.test(url)) {
      console.log(`[extract-url] LinkedIn URL detected, routing to ScrapingDog: ${url}`);
      const rawProfile = await scrapeLinkedInProfile(url);

      if (rawProfile) {
        // ScrapingDog succeeded — transform and stage through signal staging
        const parsed = transformScrapingDogProfile(rawProfile, url);
        const personEntity = linkedInResponseToEntity(parsed, url, req.agentId);
        const personName = parsed.name?.full || '';
        const orgEntities = linkedInExperienceToOrgs(parsed, personName, url, req.agentId);
        const allEntities = [personEntity, ...orgEntities];

        // Stage with linkedin_api source type (0.9 confidence — higher than linkedin_pdf 0.85)
        const scoredClusters = stageAndScoreExtraction(allEntities, {
          type: 'linkedin_api',
          url: url,
          description: `linkedin_api:${url}`,
        }, req.graphDir);

        const previewList = allEntities.map(e => {
          const ent = e.entity || {};
          const type = ent.entity_type || '';
          return {
            entity_type: type,
            name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
            summary: ent.summary?.value || '',
            attribute_count: (e.attributes || []).length,
            relationship_count: (e.relationships || []).length,
            observation_count: (e.observations || []).length,
          };
        });

        return res.json({
          entities: allEntities,
          preview: previewList,
          scored_clusters: scoredClusters,
          source_url: url,
          source_type: 'linkedin_api',
          entity_count: allEntities.length,
        });
      }

      // ScrapingDog failed — fall through to generic web extraction
      console.log(`[extract-url] ScrapingDog failed for ${url}, falling back to generic web extraction`);
    }
    // X/Twitter and Instagram URLs → existing social meta scraper (handled below)
    // All other URLs → generic web extraction (handled below)

    // Fetch the page
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      },
      redirect: 'follow',
      signal: AbortSignal.timeout(15000),
    });

    if (!response.ok) {
      // LinkedIn blocks direct web fetches — give a specific error
      if (/linkedin\.com/i.test(url)) {
        return res.status(502).json({ error: 'LinkedIn blocks direct web access. ScrapingDog API failed — the profile may be loading for the first time. Please try again in 2-3 minutes.' });
      }
      return res.status(502).json({ error: `Failed to fetch URL: HTTP ${response.status}` });
    }

    const html = await response.text();

    // Social profile detection — parse meta tags before stripping HTML
    const socialPlatform = detectSocialPlatform(url);
    let socialEntity = null;
    if (socialPlatform) {
      const meta = parseSocialMeta(html, url, socialPlatform);
      socialEntity = socialMetaToEntity(meta, url, req.agentId);
    }

    // Strip HTML to clean text
    let text = html
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
      .replace(/<nav[^>]*>[\s\S]*?<\/nav>/gi, '')
      .replace(/<footer[^>]*>[\s\S]*?<\/footer>/gi, '')
      .replace(/<header[^>]*>[\s\S]*?<\/header>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/\s+/g, ' ')
      .trim();

    // For social profiles with JS-heavy pages, return meta-tag entity even if body is sparse
    if (socialEntity && (!text || text.length < 200)) {
      const previewList = [{ entity_type: 'person', name: socialEntity.entity.name.full, summary: socialEntity.entity.summary?.value || '', attribute_count: socialEntity.attributes.length, relationship_count: 0, observation_count: socialEntity.observations.length }];
      const scoredClusters = stageAndScoreExtraction([socialEntity], { type: socialPlatform, url: url, description: `${socialPlatform}_profile:${url}` }, req.graphDir);
      return res.json({ entities: [socialEntity], preview: previewList, scored_clusters: scoredClusters, source_url: url, source_type: socialPlatform, entity_count: 1 });
    }

    if (!text || text.length < 50) {
      return res.status(422).json({ error: 'Could not extract meaningful text from this URL. The page may require JavaScript or be empty.' });
    }

    // Truncate if extremely large (keep first 30KB for extraction)
    if (text.length > 30000) {
      text = text.substring(0, 30000);
    }

    const primaryUserName = getPrimaryUserName(req.graphDir);
    const now = new Date().toISOString();
    const sourceAttribution = { type: 'web', url: url, extracted_at: now };

    // Use existing chunking + extraction pipeline
    const chunks = chunkText(text);
    const client = new Anthropic();
    const allExtracted = [];

    for (let ci = 0; ci < chunks.length; ci++) {
      const prompt = buildGenericTextPrompt(chunks[ci], url, ci + 1, chunks.length, primaryUserName);
      const message = await client.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 16384,
        messages: [{ role: 'user', content: prompt }],
      });
      const rawResponse = message.content[0].text;
      const parsed = safeParseExtraction(rawResponse, 'url-extract chunk ' + (ci + 1));
      allExtracted.push(...(parsed.entities || []));
    }

    // Convert to v2 entities with source attribution
    const v2Entities = allExtracted.map(extracted => {
      let entityType = extracted.entity_type;
      if (entityType === 'organization') entityType = 'business';
      if (!entityType || !['person', 'business', 'institution'].includes(entityType)) return null;

      const observations = (extracted.observations || []).map(obs => ({
        observation: (obs.text || '').trim(),
        observed_at: now,
        source: 'url_extract',
        source_url: url,
        confidence: 0.6,
        confidence_label: 'MODERATE',
        facts_layer: 'L2_GROUP',
        layer_number: 2,
        observed_by: req.agentId,
        truth_level: 'INFERRED',
      })).filter(o => o.observation);

      const attributes = [];
      if (extracted.attributes && typeof extracted.attributes === 'object') {
        let attrSeq = 1;
        for (const [key, value] of Object.entries(extracted.attributes)) {
          const val = Array.isArray(value) ? value.join(', ') : String(value);
          if (!val) continue;
          attributes.push({
            attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`,
            key, value: val, confidence: 0.6, confidence_label: 'MODERATE',
            time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
            source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' },
          });
        }
      }

      const relationships = [];
      if (Array.isArray(extracted.relationships)) {
        let relSeq = 1;
        for (const rel of extracted.relationships) {
          relationships.push({
            relationship_id: `REL-${String(relSeq++).padStart(3, '0')}`,
            name: rel.name || '', relationship_type: rel.relationship || '', context: rel.context || '',
            sentiment: 'neutral', confidence: 0.6, confidence_label: 'MODERATE',
          });
        }
      }

      const v2Entity = {
        schema_version: '2.0',
        schema_type: 'context_architecture_entity',
        extraction_metadata: {
          extracted_at: now, updated_at: now,
          source_description: `url_extract:${url}`,
          extraction_model: 'claude-sonnet-4-5-20250929',
          extraction_confidence: 0.6, schema_version: '2.0',
        },
        entity: {
          entity_type: entityType,
          name: { ...extracted.name, confidence: 0.6, facts_layer: 2 },
          summary: extracted.summary
            ? { value: extracted.summary, confidence: 0.6, facts_layer: 2 }
            : { value: '', confidence: 0, facts_layer: 2 },
        },
        attributes, relationships,
        values: [], key_facts: [], constraints: [],
        observations,
        provenance_chain: {
          created_at: now, created_by: req.agentId,
          source_documents: [{ source: `url_extract:${url}`, url, ingested_at: now }],
          merge_history: [],
        },
      };
      if (extracted.relationship_dimensions) {
        if (typeof extracted.relationship_dimensions.strength === 'number') {
          extracted.relationship_dimensions.visual_tier = computeVisualTier(extracted.relationship_dimensions.strength);
        }
        v2Entity.relationship_dimensions = extracted.relationship_dimensions;
        var wp = computeWikiPage(extracted.relationship_dimensions);
        v2Entity.wiki_page = wp;
        v2Entity.wiki_section = computeWikiSection(extracted.relationship_dimensions, wp);
      }
      if (extracted.descriptor) v2Entity.descriptor = extracted.descriptor;
      if (extracted.org_dimensions) {
        v2Entity.org_dimensions = extracted.org_dimensions;
        if (extracted.org_dimensions.org_category) {
          v2Entity.attributes.push({
            attribute_id: 'ATTR-ORG-CAT',
            key: 'org_category', value: extracted.org_dimensions.org_category,
            confidence: 0.8, confidence_label: 'HIGH',
            time_decay: { stability: 'stable', captured_date: now.slice(0, 10) },
            source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' },
          });
        }
      }
      return v2Entity;
    }).filter(Boolean);

    // Return entities for preview/approval (same pattern as file upload preview)
    const previewList = v2Entities.map(e => {
      const ent = e.entity || {};
      const type = ent.entity_type || '';
      return {
        entity_type: type,
        name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
        summary: ent.summary?.value || '',
        attribute_count: (e.attributes || []).length,
        relationship_count: (e.relationships || []).length,
        observation_count: (e.observations || []).length,
      };
    });

    // If we have a social entity from meta tags, prepend it (or merge if LLM found the same person)
    if (socialEntity) {
      const socialName = (socialEntity.entity.name.full || '').toLowerCase();
      const matchIdx = v2Entities.findIndex(e => {
        const n = (e.entity?.name?.full || '').toLowerCase();
        return n && socialName && (n === socialName || n.includes(socialName) || socialName.includes(n));
      });
      if (matchIdx >= 0) {
        // Merge social attributes into the LLM-found entity
        v2Entities[matchIdx].attributes = [...(v2Entities[matchIdx].attributes || []), ...socialEntity.attributes];
        v2Entities[matchIdx].observations = [...(v2Entities[matchIdx].observations || []), ...socialEntity.observations];
        if (socialEntity.entity.name.aliases?.length) {
          v2Entities[matchIdx].entity.name.aliases = [...(v2Entities[matchIdx].entity.name.aliases || []), ...socialEntity.entity.name.aliases];
        }
      } else {
        v2Entities.unshift(socialEntity);
      }
    }

    // Refresh preview after potential social merge
    const finalPreview = v2Entities.map(e => {
      const ent = e.entity || {};
      const type = ent.entity_type || '';
      return {
        entity_type: type,
        name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
        summary: ent.summary?.value || '',
        attribute_count: (e.attributes || []).length,
        relationship_count: (e.relationships || []).length,
        observation_count: (e.observations || []).length,
      };
    });

    // Stage and score through signal staging layer
    const scoredClusters = stageAndScoreExtraction(v2Entities, {
      type: socialPlatform || 'web',
      url: url,
      description: `url_extract:${url}`,
    }, req.graphDir);

    res.json({
      entities: v2Entities,
      preview: finalPreview,
      scored_clusters: scoredClusters,
      source_url: url,
      source_type: socialPlatform || 'web',
      entity_count: v2Entities.length,
    });

  } catch (err) {
    if (err.name === 'TimeoutError' || err.code === 'UND_ERR_CONNECT_TIMEOUT') {
      return res.status(504).json({ error: 'URL fetch timed out after 15 seconds' });
    }
    console.error('[extract-url] Error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// POST /api/discover-entity — Name-and-Learn: Point Agent v1 (MECE-005/006 DIRECTED mode)
// Accepts a name + optional context, predicts LinkedIn URL, extracts career data, stages clusters
app.post('/api/discover-entity', apiAuth, async (req, res) => {
  const { name, context } = req.body;
  if (!name || typeof name !== 'string' || name.trim().length < 2) {
    return res.status(400).json({ error: 'Missing or too short "name" field (min 2 chars)' });
  }

  const personName = name.trim();
  const hints = (context || '').trim();
  const steps = [];

  try {
    steps.push({ step: 'generating_slugs', message: `Searching for ${personName}...` });

    // Step 1: Use Anthropic to predict likely LinkedIn profile slugs
    const client = new Anthropic();
    const slugPrompt = `Given the person's name "${personName}"${hints ? ` and these hints: "${hints}"` : ''}, generate 3-5 likely LinkedIn profile URL slugs (the part after linkedin.com/in/).

LinkedIn slugs are typically:
- firstname-lastname (most common)
- firstnamelastname
- firstname-lastname-location
- firstname-lastname-numbers

Return ONLY a JSON array of strings, no explanation. Example: ["john-doe", "johndoe", "john-doe-atlanta", "john-doe-52b3a1"]`;

    const slugResponse = await client.messages.create({
      model: 'claude-haiku-4-5-20251001',
      max_tokens: 200,
      messages: [{ role: 'user', content: slugPrompt }],
    });

    let slugs = [];
    try {
      const raw = slugResponse.content[0].text.trim();
      slugs = JSON.parse(raw);
      if (!Array.isArray(slugs)) slugs = [slugs];
    } catch (e) {
      // Fallback: generate basic slug from name
      const basic = personName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      const nospace = personName.toLowerCase().replace(/[^a-z0-9]/g, '');
      slugs = [basic, nospace];
    }

    console.log(`[discover] Generated ${slugs.length} candidate slugs for "${personName}":`, slugs);
    steps.push({ step: 'trying_linkedin', message: `Trying ${slugs.length} LinkedIn profiles...` });

    // Step 2: Try each slug with ScrapingDog
    const candidates = [];
    for (const slug of slugs.slice(0, 5)) {
      try {
        const linkedinUrl = `https://www.linkedin.com/in/${slug}/`;
        console.log(`[discover] Trying ScrapingDog for slug: ${slug}`);
        const rawProfile = await scrapeLinkedInProfile(linkedinUrl);

        if (rawProfile && rawProfile.fullName) {
          const parsed = transformScrapingDogProfile(rawProfile, linkedinUrl);
          const profileName = parsed.name?.full || rawProfile.fullName || '';
          const profileHeadline = rawProfile.headline || parsed.headline || '';
          const profileLocation = rawProfile.location || parsed.location || '';
          const profileCompany = (rawProfile.experience && rawProfile.experience[0]) ?
            (rawProfile.experience[0].company_name || '') : '';

          candidates.push({
            slug: slug,
            linkedin_url: linkedinUrl,
            name: profileName,
            headline: profileHeadline,
            location: profileLocation,
            company: profileCompany,
            parsed: parsed,
            raw: rawProfile,
          });
          console.log(`[discover] Found profile: ${profileName} (${profileHeadline})`);
        }
      } catch (slugErr) {
        console.log(`[discover] Slug ${slug} failed:`, slugErr.message);
      }
    }

    if (candidates.length === 0) {
      steps.push({ step: 'not_found', message: `No LinkedIn profiles found for "${personName}"` });
      return res.json({
        status: 'not_found',
        name: personName,
        context: hints,
        candidates: [],
        steps: steps,
        message: `Could not find a LinkedIn profile for "${personName}". Try adding context like company name or location.`,
      });
    }

    // Step 3: Context-aware candidate ranking (MECE-006 Signal Filter: Relevance)
    // Score each candidate against user's context hints
    const contextTokens = hints ? hints.toLowerCase().split(/[\s,;]+/).filter(t => t.length > 1) : [];

    function scoreContextMatch(candidate) {
      if (contextTokens.length === 0) return { score: 0, matches: {} };
      const fields = {
        location: (candidate.location || '').toLowerCase(),
        company: (candidate.company || '').toLowerCase(),
        headline: (candidate.headline || '').toLowerCase(),
        name: (candidate.name || '').toLowerCase(),
      };
      let score = 0;
      const matches = {};
      for (const token of contextTokens) {
        if (fields.location.indexOf(token) !== -1) { score += 3; matches.location = true; }
        if (fields.company.indexOf(token) !== -1) { score += 3; matches.company = true; }
        if (fields.headline.indexOf(token) !== -1) { score += 2; matches.headline = true; }
      }
      return { score, matches };
    }

    // Score and sort all candidates
    for (const c of candidates) {
      const result = scoreContextMatch(c);
      c.context_score = result.score;
      c.context_matches = result.matches;
    }
    candidates.sort((a, b) => b.context_score - a.context_score);

    console.log(`[discover] Candidate context scores:`, candidates.map(c => `${c.name}: ${c.context_score} (${JSON.stringify(c.context_matches)})`));

    // Determine: auto-select, disambiguate, or warn
    const topScore = candidates[0].context_score;
    const secondScore = candidates.length > 1 ? candidates[1].context_score : -1;
    const hasContext = contextTokens.length > 0;
    const noContextMatch = hasContext && topScore === 0;

    // Auto-select only if: clear winner with context match AND significant gap over second
    const autoSelect = hasContext && topScore >= 3 && (candidates.length === 1 || topScore > secondScore);

    if (!autoSelect) {
      // Show disambiguation — either multiple candidates, no context, or no clear winner
      const warningMsg = noContextMatch
        ? `Found ${candidates.length} profile(s) but none match your context "${hints}". Try adding more details or paste the LinkedIn URL directly.`
        : `Found ${candidates.length} possible matches. Please select the correct person.`;
      steps.push({ step: 'disambiguation', message: warningMsg });
      return res.json({
        status: 'disambiguation',
        name: personName,
        context: hints,
        context_warning: noContextMatch,
        candidates: candidates.map(c => ({
          slug: c.slug,
          linkedin_url: c.linkedin_url,
          name: c.name,
          headline: c.headline,
          location: c.location,
          company: c.company,
          context_score: c.context_score,
          context_matches: c.context_matches,
        })),
        steps: steps,
        message: warningMsg,
      });
    }

    // Auto-select: clear context-matched winner
    const match = candidates[0];
    steps.push({ step: 'extracting', message: `Found ${match.name} (context match: ${Object.keys(match.context_matches).join(', ')}) — extracting career data...` });

    const personEntity = linkedInResponseToEntity(match.parsed, match.linkedin_url, req.agentId);
    const pName = match.parsed.name?.full || '';
    const orgEntities = linkedInExperienceToOrgs(match.parsed, pName, match.linkedin_url, req.agentId);
    const allEntities = [personEntity, ...orgEntities];

    // Stage through signal staging (same as extract-url LinkedIn path)
    const scoredClusters = stageAndScoreExtraction(allEntities, {
      type: 'linkedin_api',
      url: match.linkedin_url,
      description: `linkedin_api:${match.linkedin_url}`,
    }, req.graphDir);

    steps.push({ step: 'done', message: `Done — ${scoredClusters.length} clusters created for review` });

    const previewList = allEntities.map(e => {
      const ent = e.entity || {};
      const type = ent.entity_type || '';
      return {
        entity_type: type,
        name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
        summary: ent.summary?.value || '',
      };
    });

    return res.json({
      status: 'found',
      name: personName,
      context: hints,
      match: {
        name: match.name,
        headline: match.headline,
        location: match.location,
        company: match.company,
        linkedin_url: match.linkedin_url,
      },
      entities: previewList,
      scored_clusters: scoredClusters,
      cluster_count: scoredClusters.length,
      steps: steps,
      message: `Found ${match.name}. ${scoredClusters.length} clusters staged for review.`,
    });

  } catch (err) {
    console.error('[discover] Error:', err.message);
    steps.push({ step: 'error', message: err.message });
    res.status(500).json({ error: err.message, steps: steps });
  }
});

// POST /api/discover-entity/select — Resolve disambiguation by selecting a candidate
app.post('/api/discover-entity/select', apiAuth, async (req, res) => {
  const { slug, linkedin_url } = req.body;
  if (!slug && !linkedin_url) {
    return res.status(400).json({ error: 'Missing "slug" or "linkedin_url"' });
  }

  const url = linkedin_url || `https://www.linkedin.com/in/${slug}/`;
  const steps = [{ step: 'extracting', message: 'Extracting career data from selected profile...' }];

  try {
    const rawProfile = await scrapeLinkedInProfile(url);
    if (!rawProfile) {
      return res.status(404).json({ error: 'Could not fetch profile', steps: steps });
    }

    const parsed = transformScrapingDogProfile(rawProfile, url);
    const personEntity = linkedInResponseToEntity(parsed, url, req.agentId);
    const personName = parsed.name?.full || '';
    const orgEntities = linkedInExperienceToOrgs(parsed, personName, url, req.agentId);
    const allEntities = [personEntity, ...orgEntities];

    const scoredClusters = stageAndScoreExtraction(allEntities, {
      type: 'linkedin_api',
      url: url,
      description: `linkedin_api:${url}`,
    }, req.graphDir);

    steps.push({ step: 'done', message: `Done — ${scoredClusters.length} clusters created for review` });

    const previewList = allEntities.map(e => {
      const ent = e.entity || {};
      const type = ent.entity_type || '';
      return {
        entity_type: type,
        name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
        summary: ent.summary?.value || '',
      };
    });

    return res.json({
      status: 'found',
      match: {
        name: personName,
        linkedin_url: url,
      },
      entities: previewList,
      scored_clusters: scoredClusters,
      cluster_count: scoredClusters.length,
      steps: steps,
      message: `Extracted ${personName}. ${scoredClusters.length} clusters staged for review.`,
    });
  } catch (err) {
    console.error('[discover/select] Error:', err.message);
    steps.push({ step: 'error', message: err.message });
    res.status(500).json({ error: err.message, steps: steps });
  }
});

// POST /api/enrich-org — Enrich an organization entity from web data
app.post('/api/enrich-org', apiAuth, async (req, res) => {
  const { entity_id } = req.body;
  if (!entity_id) return res.status(400).json({ error: 'Missing entity_id' });

  const entity = readEntity(entity_id, req.graphDir);
  if (!entity) return res.status(404).json({ error: 'Entity not found' });

  const entityType = entity.entity?.entity_type;
  if (!['business', 'organization', 'institution'].includes(entityType)) {
    return res.status(400).json({ error: 'Entity is not an organization' });
  }

  const orgName = entity.entity?.name?.common || entity.entity?.name?.legal || '';
  if (!orgName) return res.status(400).json({ error: 'Organization has no name' });

  try {
    const now = new Date().toISOString();

    // Strategy 1: Try to find and fetch the company website
    // Construct likely URL from name (e.g., "Google" → "google.com")
    const cleanName = orgName.toLowerCase().replace(/[^a-z0-9]/g, '');
    const guessUrls = [
      `https://www.${cleanName}.com`,
      `https://${cleanName}.com`,
    ];

    let webText = '';
    let fetchedUrl = '';
    for (const tryUrl of guessUrls) {
      try {
        const resp = await fetch(tryUrl + '/about', {
          headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
          redirect: 'follow', signal: AbortSignal.timeout(10000),
        });
        if (resp.ok) {
          const html = await resp.text();
          webText = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<[^>]+>/g, ' ').replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ').trim();
          fetchedUrl = tryUrl + '/about';
          break;
        }
        // Try root page
        const resp2 = await fetch(tryUrl, {
          headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
          redirect: 'follow', signal: AbortSignal.timeout(10000),
        });
        if (resp2.ok) {
          const html = await resp2.text();
          webText = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<[^>]+>/g, ' ').replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ').trim();
          fetchedUrl = tryUrl;
          break;
        }
      } catch { /* next guess */ }
    }

    if (!webText || webText.length < 100) {
      return res.json({ enriched: false, message: `Could not find website for "${orgName}". Try providing a direct URL.` });
    }

    // Truncate
    if (webText.length > 20000) webText = webText.substring(0, 20000);

    // Use Claude to extract org-specific data
    const client = new Anthropic();
    const prompt = `You are extracting structured information about the organization "${orgName}" from their website.

Output ONLY valid JSON with this structure:
{
  "description": "2-3 sentence description of what this organization does",
  "industry": "primary industry or sector",
  "headquarters": "city, state/country",
  "website": "${fetchedUrl}",
  "employee_count": "approximate number or range, or empty string",
  "founded_year": "year or empty string",
  "specialties": ["specialty1", "specialty2"],
  "key_people": [{ "name": "", "title": "" }],
  "mission": "mission statement or core purpose, 1-2 sentences"
}

Website text:
---
${webText}
---`;

    const message = await client.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 4096,
      messages: [{ role: 'user', content: prompt }],
    });
    const rawResp = message.content[0].text;
    const cleaned = rawResp.replace(/^```(?:json)?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
    let enrichment;
    try { enrichment = JSON.parse(cleaned); } catch { return res.json({ enriched: false, message: 'Could not parse enrichment data' }); }

    // Merge enrichment into entity
    if (!entity.structured_attributes) entity.structured_attributes = {};
    const sa = entity.structured_attributes;
    if (enrichment.industry && !sa.industry) sa.industry = enrichment.industry;
    if (enrichment.headquarters && !sa.headquarters) sa.headquarters = enrichment.headquarters;
    if (enrichment.website && !sa.website) sa.website = enrichment.website || fetchedUrl;
    if (enrichment.employee_count && !sa.employee_count) sa.employee_count = enrichment.employee_count;
    if (enrichment.founded_year && !sa.founded_year) sa.founded_year = enrichment.founded_year;
    if (enrichment.specialties?.length && !sa.specialties) sa.specialties = enrichment.specialties;
    if (enrichment.mission && !sa.mission) sa.mission = enrichment.mission;

    // Update summary if we got a better description
    if (enrichment.description && (!entity.entity.summary?.value || entity.entity.summary.value.includes('employer of'))) {
      entity.entity.summary = { value: enrichment.description, confidence: 0.7, facts_layer: 2 };
    }

    // Add enrichment attributes
    const existingKeys = new Set((entity.attributes || []).map(a => a.key));
    const newAttrs = [];
    let attrSeq = (entity.attributes || []).length + 1;
    if (enrichment.industry && !existingKeys.has('industry')) newAttrs.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'industry', value: enrichment.industry, confidence: 0.7, confidence_label: 'MODERATE', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { type: 'web', url: fetchedUrl, facts_layer: 2, layer_label: 'group' } });
    if (enrichment.headquarters && !existingKeys.has('headquarters')) newAttrs.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'headquarters', value: enrichment.headquarters, confidence: 0.7, confidence_label: 'MODERATE', time_decay: { stability: 'semi_stable', captured_date: now.slice(0, 10) }, source_attribution: { type: 'web', url: fetchedUrl, facts_layer: 2, layer_label: 'group' } });
    if (enrichment.website && !existingKeys.has('website')) newAttrs.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'website', value: enrichment.website || fetchedUrl, confidence: 0.9, confidence_label: 'HIGH', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { type: 'web', url: fetchedUrl, facts_layer: 1, layer_label: 'self' } });
    if (enrichment.employee_count && !existingKeys.has('employee_count')) newAttrs.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'employee_count', value: enrichment.employee_count, confidence: 0.6, confidence_label: 'MODERATE', time_decay: { stability: 'volatile', captured_date: now.slice(0, 10) }, source_attribution: { type: 'web', url: fetchedUrl, facts_layer: 2, layer_label: 'group' } });
    entity.attributes = [...(entity.attributes || []), ...newAttrs];

    // Add observation
    if (!entity.observations) entity.observations = [];
    entity.observations.push({
      observation: `Organization enriched from website: ${enrichment.description || 'Web data fetched'}`,
      observed_at: now, source: 'web_enrichment', source_url: fetchedUrl,
      confidence: 0.7, confidence_label: 'MODERATE', truth_level: 'INFERRED',
      facts_layer: 'L2_GROUP', layer_number: 2, observed_by: req.agentId,
    });

    // Save
    writeEntity(entity_id, entity, req.graphDir);

    res.json({
      enriched: true,
      entity_id,
      source_url: fetchedUrl,
      enrichment: {
        description: enrichment.description,
        industry: enrichment.industry,
        headquarters: enrichment.headquarters,
        website: enrichment.website || fetchedUrl,
        employee_count: enrichment.employee_count,
        new_attributes: newAttrs.length,
      },
    });

  } catch (err) {
    console.error('[enrich-org] Error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// POST /api/extract-linkedin — Extract person entity from LinkedIn profile via Proxycurl
app.post('/api/extract-linkedin', apiAuth, async (req, res) => {
  const { linkedin_url } = req.body;
  if (!linkedin_url || typeof linkedin_url !== 'string') {
    return res.status(400).json({ error: 'Missing "linkedin_url" field' });
  }
  if (!linkedin_url.includes('linkedin.com/in/')) {
    return res.status(400).json({ error: 'URL must be a LinkedIn profile URL (linkedin.com/in/...)' });
  }
  if (!process.env.PROXYCURL_API_KEY) {
    return res.status(503).json({ error: 'Proxycurl API key not configured. Add PROXYCURL_API_KEY to .env' });
  }

  try {
    const proxycurlResp = await fetch(
      `https://nubela.co/proxycurl/api/v2/linkedin?url=${encodeURIComponent(linkedin_url)}`,
      { headers: { 'Authorization': `Bearer ${process.env.PROXYCURL_API_KEY}` }, signal: AbortSignal.timeout(20000) }
    );

    if (!proxycurlResp.ok) {
      const errText = await proxycurlResp.text();
      return res.status(502).json({ error: `Proxycurl API error (${proxycurlResp.status}): ${errText}` });
    }

    const profile = await proxycurlResp.json();
    const now = new Date().toISOString();
    const sourceAttribution = { type: 'linkedin', url: linkedin_url, extracted_at: now };
    const fullName = [profile.first_name, profile.last_name].filter(Boolean).join(' ');

    // Build Career
    const careerLite = {
      interface: 'career-lite',
      implements: ['Contactable', 'Identifiable', 'Experienceable'],
      headline: profile.headline || '',
      summary: profile.summary || '',
      current_role: profile.experiences?.[0]?.title || '',
      current_company: profile.experiences?.[0]?.company || '',
      location: [profile.city, profile.state, profile.country_full_name].filter(Boolean).join(', '),
      linkedin_url: linkedin_url,
      profile_photo: profile.profile_pic_url || '',
      follower_count: profile.follower_count || 0,
      experience: (profile.experiences || []).map(e => ({
        title: e.title || '',
        company: e.company || '',
        start_date: e.starts_at ? `${e.starts_at.year}-${String(e.starts_at.month || 1).padStart(2, '0')}` : '',
        end_date: e.ends_at ? `${e.ends_at.year}-${String(e.ends_at.month || 1).padStart(2, '0')}` : 'Present',
        description: e.description || '',
      })),
      education: (profile.education || []).map(e => ({
        institution: e.school || '',
        degree: e.degree_name || '',
        field: e.field_of_study || '',
        start_year: e.starts_at?.year ? String(e.starts_at.year) : '',
        end_year: e.ends_at?.year ? String(e.ends_at.year) : '',
      })),
      skills: (profile.skills || []),
    };

    // Build attributes
    const attributes = [];
    let attrSeq = 1;
    if (profile.headline) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'headline', value: profile.headline, confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
    if (careerLite.location) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'location', value: careerLite.location, confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'semi_stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
    if (careerLite.current_role) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'role', value: careerLite.current_role, confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'semi_stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
    if (careerLite.current_company) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'company', value: careerLite.current_company, confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'semi_stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
    if (careerLite.skills.length > 0) attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'skills', value: careerLite.skills.join(', '), confidence: 0.8, confidence_label: 'HIGH', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 2, layer_label: 'group' } });
    attributes.push({ attribute_id: `ATTR-${String(attrSeq++).padStart(3, '0')}`, key: 'linkedin_url', value: linkedin_url, confidence: 1.0, confidence_label: 'VERIFIED', time_decay: { stability: 'stable', captured_date: now.slice(0, 10) }, source_attribution: { ...sourceAttribution, facts_layer: 1, layer_label: 'self' } });

    // Build key facts from experience
    const keyFacts = [];
    let factSeq = 1;
    for (const exp of (profile.experiences || [])) {
      const dateRange = [];
      if (exp.starts_at) dateRange.push(`${exp.starts_at.year}`);
      if (exp.ends_at) dateRange.push(`${exp.ends_at.year}`);
      else if (dateRange.length) dateRange.push('Present');
      const fact = [exp.title, exp.company, dateRange.join(' - ')].filter(Boolean).join(' at ');
      if (fact) keyFacts.push({ fact_id: `FACT-${String(factSeq++).padStart(3, '0')}`, fact, confidence: 0.8, confidence_label: 'HIGH', source: linkedin_url });
    }
    for (const edu of (profile.education || [])) {
      const parts = [edu.degree_name, edu.field_of_study, edu.school].filter(Boolean);
      if (parts.length) keyFacts.push({ fact_id: `FACT-${String(factSeq++).padStart(3, '0')}`, fact: parts.join(', '), confidence: 0.8, confidence_label: 'HIGH', source: linkedin_url });
    }

    // Build observations
    const observations = [];
    if (profile.summary) observations.push({ observation: profile.summary, observed_at: now, source: 'linkedin_proxycurl', source_url: linkedin_url, confidence: 0.8, confidence_label: 'HIGH', truth_level: 'STRONG', facts_layer: 'L2_GROUP', layer_number: 2, observed_by: req.agentId });
    if (profile.headline) observations.push({ observation: `LinkedIn headline: ${profile.headline}`, observed_at: now, source: 'linkedin_proxycurl', source_url: linkedin_url, confidence: 0.8, confidence_label: 'HIGH', truth_level: 'STRONG', facts_layer: 'L2_GROUP', layer_number: 2, observed_by: req.agentId });
    observations.push({ observation: `LinkedIn profile imported via Proxycurl from ${linkedin_url}`, observed_at: now, source: 'linkedin_proxycurl', source_url: linkedin_url, confidence: 1.0, confidence_label: 'VERIFIED', truth_level: 'STRONG', facts_layer: 'L1_SELF', layer_number: 1, observed_by: req.agentId });

    // Build person entity
    const personEntity = {
      schema_version: '2.0', schema_type: 'context_architecture_entity',
      extraction_metadata: { extracted_at: now, updated_at: now, source_description: `linkedin_proxycurl:${linkedin_url}`, extraction_model: 'proxycurl-api', extraction_confidence: 0.8, schema_version: '2.0' },
      entity: {
        entity_type: 'person',
        name: { full: fullName, preferred: profile.first_name || '', aliases: [], confidence: 0.8, facts_layer: 2 },
        summary: profile.summary ? { value: profile.summary, confidence: 0.8, facts_layer: 2 } : { value: profile.headline || '', confidence: 0.6, facts_layer: 2 },
      },
      career_lite: careerLite,
      attributes, relationships: [], values: [], key_facts: keyFacts, constraints: [],
      observations,
      provenance_chain: { created_at: now, created_by: req.agentId, source_documents: [{ source: `linkedin_proxycurl:${linkedin_url}`, url: linkedin_url, ingested_at: now }], merge_history: [] },
    };

    // Build org entities for each unique employer
    const seenOrgs = new Set();
    const orgEntities = [];
    for (const exp of (profile.experiences || [])) {
      const company = (exp.company || '').trim();
      if (!company || seenOrgs.has(company.toLowerCase())) continue;
      seenOrgs.add(company.toLowerCase());
      const isCurrentRole = !exp.ends_at;
      orgEntities.push({
        schema_version: '2.0', schema_type: 'context_architecture_entity',
        extraction_metadata: { extracted_at: now, updated_at: now, source_description: `linkedin_proxycurl:${linkedin_url}`, extraction_model: 'proxycurl-api', extraction_confidence: 0.6, schema_version: '2.0' },
        entity: {
          entity_type: 'business',
          name: { common: company, legal: company, aliases: [], confidence: 0.6, facts_layer: 2 },
          summary: { value: `${company} — employer of ${fullName}`, confidence: 0.5, facts_layer: 2 },
        },
        attributes: [], relationships: [{ relationship_id: 'REL-001', name: fullName, relationship_type: 'employed', context: `${fullName} worked at ${company} as ${exp.title || 'employee'}`, sentiment: 'neutral', confidence: 0.8, confidence_label: 'HIGH' }],
        values: [], key_facts: [], constraints: [],
        observations: [{ observation: `${fullName} worked here as ${exp.title || 'employee'}`, observed_at: now, source: 'linkedin_proxycurl', source_url: linkedin_url, confidence: 0.8, confidence_label: 'HIGH', truth_level: 'STRONG', facts_layer: 'L2_GROUP', layer_number: 2, observed_by: req.agentId }],
        org_dimensions: { relationship_to_primary: 'employer', org_category: 'career', org_status: isCurrentRole ? 'current' : 'former', primary_user_role: exp.title || '' },
        provenance_chain: { created_at: now, created_by: req.agentId, source_documents: [{ source: `linkedin_proxycurl:${linkedin_url}`, url: linkedin_url, ingested_at: now }], merge_history: [] },
      });
    }

    const allEntities = [personEntity, ...orgEntities];

    // Return preview
    const previewList = allEntities.map(e => {
      const ent = e.entity || {};
      const type = ent.entity_type || '';
      return {
        entity_type: type,
        name: type === 'person' ? (ent.name?.full || '') : (ent.name?.common || ent.name?.legal || ''),
        summary: ent.summary?.value || '',
        attribute_count: (e.attributes || []).length,
        relationship_count: (e.relationships || []).length,
        observation_count: (e.observations || []).length,
      };
    });

    // Stage and score through signal staging layer
    const scoredClusters = stageAndScoreExtraction(allEntities, {
      type: 'linkedin',
      url: linkedin_url,
      description: `linkedin_proxycurl:${linkedin_url}`,
    }, req.graphDir);

    res.json({ entities: allEntities, preview: previewList, scored_clusters: scoredClusters, source_url: linkedin_url, source_type: 'linkedin', entity_count: allEntities.length });

  } catch (err) {
    if (err.name === 'TimeoutError') return res.status(504).json({ error: 'Proxycurl API timed out' });
    console.error('[extract-linkedin] Error:', err.message);
    res.status(500).json({ error: err.message });
  }
});

// GET /api/entities/category/:category?spoke_id= — List entities by wiki category
app.get('/api/entities/category/:category', apiAuth, (req, res) => {
  const category = req.params.category.toLowerCase();
  const validCategories = ['family', 'friends', 'professional', 'other', 'career', 'education', 'affiliations', 'services'];
  if (!validCategories.includes(category)) {
    return res.status(400).json({ error: `Invalid category. Valid: ${validCategories.join(', ')}` });
  }

  const spokeFilter = req.query.spoke_id || null;
  const entities = listEntities(req.graphDir, spokeFilter ? { spokeId: spokeFilter } : undefined);
  const results = [];

  for (const { data } of entities) {
    const e = data.entity || {};
    const type = e.entity_type;
    const name = type === 'person' ? (e.name?.full || '') : (e.name?.common || e.name?.legal || e.name?.full || '');

    // Person categories: family, friends, professional, other
    if (type === 'person') {
      const page = computeWikiPage(data.relationship_dimensions);
      if (page === category) {
        const r = { entity_id: e.entity_id, entity_type: type, name, summary: e.summary?.value || '', observation_count: (data.observations || []).length, relationship_count: (data.relationships || []).length };
        if (data.relationship_dimensions) r.relationship_dimensions = data.relationship_dimensions;
        if (data.descriptor) r.descriptor = data.descriptor;
        r.attributes = (data.attributes || []).map(a => ({ key: a.key, value: a.value }));
        r.relationships = (data.relationships || []).map(rel => ({ name: rel.name, relationship_type: rel.relationship_type, context: rel.context }));
        results.push(r);
      }
    }

    // Org categories: career, education, affiliations, services
    if (type === 'organization' || type === 'business' || type === 'institution') {
      const orgCat = (data.org_dimensions?.org_category || '').toLowerCase();
      const attrs = data.attributes || [];
      const attrCat = (attrs.find(a => a.key === 'org_category') || {}).value || '';
      if (orgCat === category || attrCat.toLowerCase() === category) {
        results.push({ entity_id: e.entity_id, entity_type: type, name, summary: e.summary?.value || '', attributes: attrs.map(a => ({ key: a.key, value: a.value })), org_dimensions: data.org_dimensions || null });
      }
    }
  }

  res.json({ category, count: results.length, results });
});

// GET /api/graph/stats — Knowledge graph health check
app.get('/api/graph/stats', apiAuth, (req, res) => {
  const entities = listEntities(req.graphDir);
  let lastUpdated = null;
  let totalMerges = 0;
  const typeCounts = { person: 0, business: 0, institution: 0 };

  for (const { data } of entities) {
    const type = data.entity?.entity_type;
    if (type && typeCounts[type] !== undefined) typeCounts[type]++;

    const extractedAt = data.extraction_metadata?.extracted_at;
    if (extractedAt && (!lastUpdated || extractedAt > lastUpdated)) {
      lastUpdated = extractedAt;
    }

    totalMerges += (data.provenance_chain?.merge_history || []).length;
  }

  res.json({
    status: 'healthy',
    entity_count: entities.length,
    type_counts: typeCounts,
    total_merges: totalMerges,
    last_updated: lastUpdated,
    graph_directory: GRAPH_DIR,
  });
});

// --- Share API routes ---

// POST /api/share — Create a new share link for a Career entity
app.post('/api/share', apiAuth, shareLimiter, (req, res) => {
  const { entityId, sections, expiresInDays } = req.body;

  // Validate entityId
  if (!entityId || typeof entityId !== 'string') {
    return res.status(400).json({ error: 'Missing or invalid entityId' });
  }
  if (!/^[\w-]+$/.test(entityId)) {
    return res.status(400).json({ error: 'Invalid entityId format' });
  }

  // Validate sections
  const allowedSections = ['summary', 'experience', 'education', 'skills', 'connections'];
  if (sections !== undefined && !Array.isArray(sections)) {
    return res.status(400).json({ error: 'sections must be an array of strings' });
  }
  if (sections && !sections.every(s => typeof s === 'string' && allowedSections.includes(s))) {
    return res.status(400).json({ error: 'Invalid section. Allowed: ' + allowedSections.join(', ') });
  }

  // Validate expiresInDays
  const validExpiries = [7, 30, 90, 365];
  if (expiresInDays !== undefined && !validExpiries.includes(expiresInDays)) {
    return res.status(400).json({ error: 'expiresInDays must be one of: ' + validExpiries.join(', ') });
  }

  const entityPath = path.join(req.graphDir, entityId + '.json');
  if (!fs.existsSync(entityPath)) return res.status(404).json({ error: 'Entity not found' });

  const entityData = JSON.parse(fs.readFileSync(entityPath, 'utf-8'));
  if (!entityData.career_lite || entityData.career_lite.interface !== 'career-lite') {
    return res.status(400).json({ error: 'Entity is not a Career profile' });
  }

  const shareId = crypto.randomBytes(9).toString('base64url');
  const now = new Date();
  const days = expiresInDays || 30;
  const expiresAt = new Date(now.getTime() + days * 86400000).toISOString();

  const selectedSections = (sections || ['summary', 'experience', 'education', 'skills'])
    .filter(s => allowedSections.includes(s));

  const share = {
    shareId,
    tenantId: req.tenantId,
    entityId,
    sections: selectedSections,
    createdAt: now.toISOString(),
    expiresAt,
  };

  const shares = loadShares(req.graphDir);
  shares.push(share);
  saveShares(req.graphDir, shares);

  const protocol = req.headers['x-forwarded-proto'] || req.protocol;
  const host = req.headers['x-forwarded-host'] || req.get('host');
  const shareUrl = `${protocol}://${host}/shared/${shareId}`;

  res.json({ shareId, shareUrl, sections: selectedSections, expiresAt });
});

// GET /api/shares/:entityId — List non-expired shares for an entity
app.get('/api/shares/:entityId', apiAuth, (req, res) => {
  const shares = loadShares(req.graphDir);
  const now = new Date().toISOString();
  const active = shares.filter(s => s.entityId === req.params.entityId && s.expiresAt > now);
  res.json(active);
});

// DELETE /api/share/:shareId — Revoke a share
app.delete('/api/share/:shareId', apiAuth, (req, res) => {
  const shares = loadShares(req.graphDir);
  const idx = shares.findIndex(s => s.shareId === req.params.shareId);
  if (idx === -1) return res.status(404).json({ error: 'Share not found' });
  shares.splice(idx, 1);
  saveShares(req.graphDir, shares);
  res.json({ ok: true });
});

// --- Spoke Share endpoints (Build 7 — Client Portal) ---

// POST /api/spoke/:id/share — Create a spoke share link
app.post('/api/spoke/:id/share', apiAuth, shareLimiter, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });

  const token = crypto.randomBytes(12).toString('base64url');
  const includes = Array.isArray(req.body.includes) ? req.body.includes.filter(s => ['gaps', 'export', 'files'].includes(s)) : ['gaps', 'export', 'files'];
  const label = (req.body.label || '').trim() || null;
  const now = new Date().toISOString();

  const share = { token, label, includes, created_at: now };
  const shares = spoke.shares || [];
  shares.push(share);
  updateSpoke(req.graphDir, req.params.id, { shares });

  const protocol = req.headers['x-forwarded-proto'] || req.protocol;
  const host = req.headers['x-forwarded-host'] || req.get('host');
  res.json({ share_url: `${protocol}://${host}/shared/${token}`, token, created_at: now, includes });
});

// GET /api/spoke/:id/shares — List spoke shares
app.get('/api/spoke/:id/shares', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });
  res.json({ spoke_id: req.params.id, shares: spoke.shares || [] });
});

// DELETE /api/spoke/:id/share/:token — Revoke a spoke share
app.delete('/api/spoke/:id/share/:token', apiAuth, (req, res) => {
  const spoke = getSpoke(req.graphDir, req.params.id);
  if (!spoke) return res.status(404).json({ error: `Spoke ${req.params.id} not found` });
  const shares = (spoke.shares || []).filter(s => s.token !== req.params.token);
  if (shares.length === (spoke.shares || []).length) return res.status(404).json({ error: 'Share token not found' });
  updateSpoke(req.graphDir, req.params.id, { shares });
  res.json({ ok: true });
});

// --- Serve the UI ---

// Admin migration page
app.get('/admin/migrate', (req, res) => {
  res.send(`<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dimension Migration</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f5f5; color: #333; padding: 40px; }
  .container { max-width: 720px; margin: 0 auto; }
  h1 { font-size: 1.5rem; margin-bottom: 24px; }
  .card { background: white; border-radius: 8px; padding: 20px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
  .card h2 { font-size: 1.1rem; margin-bottom: 12px; }
  .stat { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #eee; }
  .stat:last-child { border-bottom: none; }
  .stat-label { color: #666; }
  .stat-value { font-weight: 600; }
  .btn { display: inline-block; padding: 10px 24px; border-radius: 6px; border: none; font-size: 0.95rem; font-weight: 600; cursor: pointer; }
  .btn-primary { background: #6366f1; color: white; }
  .btn-primary:hover { background: #5558e6; }
  .btn-primary:disabled { background: #ccc; cursor: not-allowed; }
  .progress { margin-top: 16px; display: none; }
  .progress-bar { height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; }
  .progress-fill { height: 100%; background: #6366f1; transition: width 0.3s; width: 0%; }
  .progress-text { font-size: 0.85rem; color: #666; margin-top: 8px; }
  .results { margin-top: 16px; display: none; }
  .results pre { background: #f8f8f8; padding: 12px; border-radius: 6px; font-size: 0.82rem; overflow-x: auto; white-space: pre-wrap; }
  .tier-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; margin-right: 4px; }
  .tier-gold { background: #FFFDF5; border: 1px solid #D4A017; color: #8B6914; }
  .tier-green { background: #E8F5E9; border: 1px solid #4CAF50; color: #2E7D32; }
  .tier-neutral { background: #F5F5F5; border: 1px solid #999; color: #666; }
  .tier-muted { background: #FAFAFA; border: 1px solid #ddd; color: #999; }
  .error { color: #d32f2f; font-size: 0.85rem; margin-top: 8px; }
</style>
</head>
<body>
<div class="container">
  <h1>Dimension Migration</h1>

  <div class="card" id="countsCard">
    <h2>Entity Counts</h2>
    <div id="counts"><div style="color:#999">Loading...</div></div>
  </div>

  <div class="card">
    <h2>Run Migration</h2>
    <p style="color:#666;font-size:0.9rem;margin-bottom:12px;">Sends each entity to the LLM for dimension analysis. This will overwrite existing dimensions.</p>
    <button class="btn btn-primary" id="runBtn" onclick="runMigration()">Run Migration</button>
    <div class="progress" id="progress">
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText">Starting...</div>
    </div>
    <div class="error" id="errorText"></div>
  </div>

  <div class="card results" id="resultsCard">
    <h2>Results</h2>
    <div id="resultsContent"></div>
  </div>
</div>

<script>
var API_KEY = '';

function getApiKey() {
  if (API_KEY) return API_KEY;
  API_KEY = prompt('Enter API key (x-context-api-key):');
  return API_KEY;
}

function fetchCounts() {
  var key = getApiKey();
  if (!key) return;
  fetch('/api/search?q=*', { headers: { 'x-context-api-key': key } })
    .then(function(r) { return r.json(); })
    .then(function(data) {
      var people = 0, orgs = 0, withDims = 0;
      var results = data.results || [];
      for (var i = 0; i < results.length; i++) {
        if (results[i].entity_type === 'person') {
          people++;
          if (results[i].relationship_dimensions) withDims++;
        }
        if (results[i].entity_type === 'organization' || results[i].entity_type === 'business' || results[i].entity_type === 'institution') orgs++;
      }
      var html = '';
      html += '<div class="stat"><span class="stat-label">People</span><span class="stat-value">' + people + '</span></div>';
      html += '<div class="stat"><span class="stat-label">Affiliations</span><span class="stat-value">' + orgs + '</span></div>';
      html += '<div class="stat"><span class="stat-label">With dimensions</span><span class="stat-value">' + withDims + ' / ' + people + '</span></div>';
      document.getElementById('counts').innerHTML = html;
    });
}

function runMigration() {
  var key = getApiKey();
  if (!key) return;
  var btn = document.getElementById('runBtn');
  btn.disabled = true;
  btn.textContent = 'Running...';
  document.getElementById('progress').style.display = 'block';
  document.getElementById('resultsCard').style.display = 'none';
  document.getElementById('errorText').textContent = '';

  // Poll progress
  var pollId = setInterval(function() {
    fetch('/api/generate-dimensions/status', { headers: { 'x-context-api-key': key } })
      .then(function(r) { return r.json(); })
      .then(function(status) {
        if (status.running) {
          var pct = status.total > 0 ? Math.round((status.current / status.total) * 100) : 0;
          document.getElementById('progressFill').style.width = pct + '%';
          document.getElementById('progressText').textContent = status.phase + ': ' + status.current + ' / ' + status.total + ' (' + pct + '%)';
        }
      });
  }, 2000);

  fetch('/api/generate-dimensions', {
    method: 'POST',
    headers: { 'x-context-api-key': key, 'Content-Type': 'application/json' },
    body: '{}'
  })
    .then(function(r) { return r.json(); })
    .then(function(data) {
      clearInterval(pollId);
      document.getElementById('progressFill').style.width = '100%';
      document.getElementById('progressText').textContent = 'Complete!';
      btn.disabled = false;
      btn.textContent = 'Run Migration';
      showResults(data);
      fetchCounts();
    })
    .catch(function(err) {
      clearInterval(pollId);
      document.getElementById('errorText').textContent = 'Error: ' + err.message;
      btn.disabled = false;
      btn.textContent = 'Run Migration';
    });
}

function showResults(data) {
  var card = document.getElementById('resultsCard');
  card.style.display = 'block';
  var html = '<p style="font-weight:600;margin-bottom:12px;">' + (data.summary || '') + '</p>';

  // People breakdown
  if (data.people) {
    html += '<h3 style="font-size:0.95rem;margin:12px 0 6px;">People</h3>';
    var cats = ['family', 'friends', 'professional', 'other'];
    for (var i = 0; i < cats.length; i++) {
      var arr = data.people[cats[i]] || [];
      if (arr.length > 0) html += '<div class="stat"><span class="stat-label">' + cats[i].charAt(0).toUpperCase() + cats[i].slice(1) + '</span><span class="stat-value">' + arr.length + '</span></div>';
    }
  }

  // Orgs breakdown
  if (data.orgs) {
    html += '<h3 style="font-size:0.95rem;margin:12px 0 6px;">Affiliations</h3>';
    var orgCats = ['career', 'education', 'affiliations', 'services', 'deleted'];
    for (var i = 0; i < orgCats.length; i++) {
      var arr = data.orgs[orgCats[i]] || [];
      if (arr.length > 0) html += '<div class="stat"><span class="stat-label">' + orgCats[i].charAt(0).toUpperCase() + orgCats[i].slice(1) + (orgCats[i] === 'deleted' ? ' (flagged)' : '') + '</span><span class="stat-value">' + arr.length + '</span></div>';
    }
  }

  // Tiers
  if (data.tiers) {
    html += '<h3 style="font-size:0.95rem;margin:12px 0 6px;">Visual Tiers</h3>';
    html += '<div style="margin:4px 0;">';
    html += '<span class="tier-badge tier-gold">Gold: ' + (data.tiers.gold || 0) + '</span>';
    html += '<span class="tier-badge tier-green">Green: ' + (data.tiers.green || 0) + '</span>';
    html += '<span class="tier-badge tier-neutral">Neutral: ' + (data.tiers.neutral || 0) + '</span>';
    html += '<span class="tier-badge tier-muted">Muted: ' + (data.tiers.muted || 0) + '</span>';
    html += '</div>';
  }

  // Errors
  if (data.errors && data.errors.length > 0) {
    html += '<h3 style="font-size:0.95rem;margin:12px 0 6px;color:#d32f2f;">Errors (' + data.errors.length + ')</h3>';
    html += '<pre>' + data.errors.join('\\n') + '</pre>';
  }

  document.getElementById('resultsContent').innerHTML = html;
}

fetchCounts();
</script>
</body>
</html>`);
});

app.get('/openai-actions-spec.yaml', (req, res) => {
  res.setHeader('Content-Type', 'text/yaml');
  res.sendFile(path.join(__dirname, 'openai-actions-spec.yaml'));
});

app.get('/', (req, res) => {
  res.send(HTML);
});

const HTML = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Engine v2</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f;
    color: #e0e0e0;
    min-height: 100vh;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 24px;
  }

  header {
    text-align: center;
    margin-bottom: 48px;
  }

  h1 {
    font-size: 2.4rem;
    font-weight: 700;
    color: #ffffff;
    letter-spacing: -0.02em;
  }

  h1 span {
    background: linear-gradient(135deg, #6366f1, #8b5cf6, #a78bfa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .subtitle {
    font-size: 1.1rem;
    color: #6b7280;
    margin-top: 8px;
  }

  .workspace {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    min-height: 500px;
  }

  .panel {
    background: #12121a;
    border: 1px solid #1e1e2e;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .panel-header {
    padding: 16px 20px;
    border-bottom: 1px solid #1e1e2e;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .panel-label {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #6b7280;
  }

  textarea {
    flex: 1;
    background: transparent;
    border: none;
    color: #e0e0e0;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.9rem;
    line-height: 1.6;
    padding: 20px;
    resize: none;
    outline: none;
  }

  textarea::placeholder { color: #3a3a4a; }

  .buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin: 24px 0;
  }

  button {
    padding: 12px 28px;
    border: none;
    border-radius: 8px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .btn-person {
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
  }

  .btn-person:hover:not(:disabled) {
    background: linear-gradient(135deg, #4f46e5, #7c3aed);
    transform: translateY(-1px);
    box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
  }

  .btn-business {
    background: linear-gradient(135deg, #0ea5e9, #06b6d4);
    color: white;
  }

  .btn-business:hover:not(:disabled) {
    background: linear-gradient(135deg, #0284c7, #0891b2);
    transform: translateY(-1px);
    box-shadow: 0 4px 20px rgba(14, 165, 233, 0.3);
  }

  .result-area {
    flex: 1;
    padding: 20px;
    overflow: auto;
  }

  pre {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.85rem;
    line-height: 1.7;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .empty-state {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #3a3a4a;
    font-size: 0.95rem;
    text-align: center;
    padding: 40px;
    line-height: 1.6;
  }

  .loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    flex-direction: column;
    gap: 16px;
  }

  .spinner {
    width: 32px;
    height: 32px;
    border: 3px solid #1e1e2e;
    border-top-color: #8b5cf6;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text { color: #6b7280; font-size: 0.9rem; }

  .stats {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin-bottom: 16px;
  }

  .stat {
    background: #1a1a2e;
    border: 1px solid #2a2a3e;
    border-radius: 8px;
    padding: 8px 14px;
    font-size: 0.8rem;
  }

  .stat-value {
    color: #a78bfa;
    font-weight: 700;
    margin-right: 4px;
  }

  .stat-label { color: #6b7280; }

  /* JSON syntax highlighting */
  .json-key { color: #8b5cf6; }
  .json-string { color: #34d399; }
  .json-number { color: #f59e0b; }
  .json-bool { color: #f472b6; }
  .json-null { color: #6b7280; }
  .json-bracket { color: #6b7280; }

  .timer {
    font-size: 0.8rem;
    color: #4b5563;
  }

  /* v2 structured view */
  .entity-card {
    background: #1a1a2e;
    border: 1px solid #2a2a3e;
    border-radius: 10px;
    padding: 16px;
    margin-bottom: 16px;
  }

  .entity-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  .entity-name {
    font-size: 1.1rem;
    font-weight: 700;
    color: #fff;
  }

  .entity-id {
    font-size: 0.7rem;
    color: #6366f1;
    font-family: monospace;
    background: rgba(99,102,241,0.1);
    padding: 2px 8px;
    border-radius: 4px;
  }

  .entity-summary {
    font-size: 0.85rem;
    color: #9ca3af;
    line-height: 1.5;
    margin-top: 6px;
  }

  .section {
    margin-bottom: 12px;
  }

  .section-title {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #6b7280;
    margin-bottom: 6px;
    padding-bottom: 4px;
    border-bottom: 1px solid #1e1e2e;
  }

  .item-row {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 5px 0;
    font-size: 0.82rem;
    flex-wrap: wrap;
  }

  .item-key {
    color: #8b5cf6;
    font-weight: 600;
    min-width: 70px;
  }

  .item-value {
    color: #e0e0e0;
    flex: 1;
  }

  .badge {
    display: inline-block;
    font-size: 0.65rem;
    font-weight: 600;
    padding: 1px 6px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    flex-shrink: 0;
  }

  .badge-verified { background: rgba(52,211,153,0.15); color: #34d399; }
  .badge-strong { background: rgba(96,165,250,0.15); color: #60a5fa; }
  .badge-moderate { background: rgba(251,191,36,0.15); color: #fbbf24; }
  .badge-speculative { background: rgba(251,146,60,0.15); color: #fb923c; }
  .badge-uncertain { background: rgba(239,68,68,0.15); color: #ef4444; }

  .badge-time {
    background: rgba(139,92,246,0.1);
    color: #a78bfa;
    font-size: 0.6rem;
  }

  .badge-layer {
    font-size: 0.6rem;
  }

  .badge-layer-1 { background: rgba(52,211,153,0.1); color: #6ee7b7; }
  .badge-layer-2 { background: rgba(96,165,250,0.1); color: #93c5fd; }
  .badge-layer-3 { background: rgba(244,114,182,0.1); color: #f9a8d4; }

  .rel-sentiment {
    font-size: 0.65rem;
    padding: 1px 6px;
    border-radius: 4px;
  }

  .sentiment-positive { background: rgba(52,211,153,0.12); color: #34d399; }
  .sentiment-neutral { background: rgba(156,163,175,0.12); color: #9ca3af; }
  .sentiment-strained { background: rgba(239,68,68,0.12); color: #ef4444; }
  .sentiment-complex { background: rgba(251,191,36,0.12); color: #fbbf24; }
  .sentiment-unknown { background: rgba(107,114,128,0.12); color: #6b7280; }

  .constraint-card {
    background: rgba(239,68,68,0.05);
    border: 1px solid rgba(239,68,68,0.15);
    border-radius: 6px;
    padding: 8px 10px;
    margin-bottom: 6px;
    font-size: 0.8rem;
  }

  .constraint-name { color: #fca5a5; font-weight: 600; }
  .constraint-desc { color: #9ca3af; margin-top: 3px; }

  .view-toggle {
    display: flex;
    gap: 4px;
  }

  .view-btn {
    background: transparent;
    border: 1px solid #2a2a3e;
    color: #6b7280;
    padding: 3px 10px;
    font-size: 0.7rem;
    border-radius: 4px;
    cursor: pointer;
  }

  .view-btn.active {
    border-color: #8b5cf6;
    color: #a78bfa;
  }

  .json-view { display: none; }
  .json-view.active { display: block; }
  .structured-view { display: none; }
  .structured-view.active { display: block; }

  .provenance {
    font-size: 0.75rem;
    color: #4b5563;
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #1e1e2e;
  }

  .provenance code {
    color: #6366f1;
    font-size: 0.7rem;
  }

  .btn-sample {
    background: transparent;
    border: 1px solid #2a2a3e;
    color: #6b7280;
    padding: 6px 14px;
    font-size: 0.8rem;
  }

  .btn-sample:hover:not(:disabled) {
    border-color: #8b5cf6;
    color: #a78bfa;
  }

  .output-actions {
    display: flex;
    gap: 8px;
  }

  .btn-action {
    background: transparent;
    border: 1px solid #2a2a3e;
    color: #6b7280;
    padding: 6px 14px;
    font-size: 0.75rem;
    display: none;
  }

  .btn-action:hover:not(:disabled) {
    border-color: #8b5cf6;
    color: #a78bfa;
  }

  .btn-action.visible { display: inline-block; }

  .btn-action.copied {
    border-color: #34d399;
    color: #34d399;
  }

  footer {
    text-align: center;
    padding: 40px 24px 24px;
    color: #3a3a4a;
    font-size: 0.8rem;
  }

  footer a {
    color: #6b7280;
    text-decoration: none;
  }

  footer a:hover { color: #a78bfa; }

  @media (max-width: 768px) {
    .workspace { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><span>Context Engine</span></h1>
    <p class="subtitle">Turn messy text into structured intelligence</p>
  </header>

  <div class="workspace">
    <div class="panel">
      <div class="panel-header">
        <span class="panel-label">Input</span>
        <button class="btn-sample" onclick="loadSample()">Load Sample</button>
      </div>
      <textarea id="input" placeholder="Paste unstructured text about a person or business here..."></textarea>
    </div>

    <div class="panel">
      <div class="panel-header">
        <span class="panel-label">Structured Output</span>
        <div class="output-actions">
          <div class="view-toggle" id="view-toggle" style="display:none;">
            <button class="view-btn active" data-view="structured" onclick="toggleView('structured')">Structured</button>
            <button class="view-btn" data-view="json" onclick="toggleView('json')">JSON</button>
          </div>
          <button class="btn-action" id="btn-copy" onclick="copyJSON()">Copy JSON</button>
          <button class="btn-action" id="btn-download" onclick="downloadJSON()">Download JSON</button>
          <span class="timer" id="timer"></span>
        </div>
      </div>
      <div class="result-area" id="result">
        <div class="empty-state">
          Paste text on the left and click<br>Extract Person or Extract Business
        </div>
      </div>
    </div>
  </div>

  <div class="buttons">
    <button class="btn-person" id="btn-person" onclick="extract('person')">Extract Person</button>
    <button class="btn-business" id="btn-business" onclick="extract('business')">Extract Business</button>
  </div>
</div>

<footer>
  Built by CJ Mitchell | Context Architecture | <a href="https://github.com/flawlesstracks/context-engine" target="_blank">github.com/flawlesstracks/context-engine</a>
</footer>

<script>
var lastResult = null;
var currentView = 'structured';

var SAMPLE_TEXT = "Dr. Sarah Chen is a 38-year-old AI research lead at Meridian Labs in San Francisco. She previously spent six years at DeepMind working on reinforcement learning before joining Meridian in 2023 to build their applied AI division. Sarah holds a PhD from MIT in computational neuroscience and a BS from Stanford in computer science. She is known for her work on multi-agent systems and has published over 40 papers. Her close collaborators include Dr. James Park, CTO of Meridian Labs, and Professor Ana Ruiz at UC Berkeley who co-authored several papers with her. Sarah values rigorous experimentation and open science. She prefers written communication over meetings and is known for detailed technical memos. Outside of work she mentors undergrad researchers through a program called NextGen AI and is an avid rock climber.";

function loadSample() {
  document.getElementById('input').value = SAMPLE_TEXT;
}

function showActionButtons() {
  document.getElementById('btn-copy').classList.add('visible');
  document.getElementById('btn-download').classList.add('visible');
  document.getElementById('view-toggle').style.display = 'flex';
}

function hideActionButtons() {
  document.getElementById('btn-copy').classList.remove('visible');
  document.getElementById('btn-download').classList.remove('visible');
  document.getElementById('view-toggle').style.display = 'none';
}

async function copyJSON() {
  if (!lastResult) return;
  var btn = document.getElementById('btn-copy');
  await navigator.clipboard.writeText(JSON.stringify(lastResult, null, 2));
  btn.textContent = 'Copied!';
  btn.classList.add('copied');
  setTimeout(function() {
    btn.textContent = 'Copy JSON';
    btn.classList.remove('copied');
  }, 2000);
}

function downloadJSON() {
  if (!lastResult) return;
  var e = lastResult.entity || {};
  var name = e.name?.full || e.name?.common || e.name?.legal || 'context';
  var filename = name.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '-context.json';
  var blob = new Blob([JSON.stringify(lastResult, null, 2)], { type: 'application/json' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function toggleView(view) {
  currentView = view;
  document.querySelectorAll('.view-btn').forEach(function(b) {
    b.classList.toggle('active', b.dataset.view === view);
  });
  var sv = document.querySelector('.structured-view');
  var jv = document.querySelector('.json-view');
  if (sv) sv.classList.toggle('active', view === 'structured');
  if (jv) jv.classList.toggle('active', view === 'json');
}

function esc(str) {
  var d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function confidenceBadge(conf, label) {
  if (conf == null) return '';
  var cls = 'badge-moderate';
  var lbl = label || '';
  if (conf >= 0.90) { cls = 'badge-verified'; lbl = lbl || 'VERIFIED'; }
  else if (conf >= 0.75) { cls = 'badge-strong'; lbl = lbl || 'STRONG'; }
  else if (conf >= 0.50) { cls = 'badge-moderate'; lbl = lbl || 'MODERATE'; }
  else if (conf >= 0.25) { cls = 'badge-speculative'; lbl = lbl || 'SPECULATIVE'; }
  else { cls = 'badge-uncertain'; lbl = lbl || 'UNCERTAIN'; }
  return '<span class="badge ' + cls + '">' + esc(lbl) + ' ' + conf.toFixed(2) + '</span>';
}

function timeBadge(decay) {
  if (!decay) return '';
  return '<span class="badge badge-time">' + esc(decay) + '</span>';
}

function layerBadge(layer) {
  if (!layer) return '';
  var labels = { 1: 'Objective', 2: 'Group', 3: 'Personal' };
  return '<span class="badge badge-layer badge-layer-' + layer + '">L' + layer + ' ' + esc(labels[layer] || '') + '</span>';
}

function sentimentBadge(sentiment) {
  if (!sentiment) return '';
  var cls = 'sentiment-' + sentiment.toLowerCase().replace(/[^a-z]/g, '');
  if (!['positive','neutral','strained','complex','unknown'].some(function(s) { return cls === 'sentiment-' + s; })) {
    cls = 'sentiment-neutral';
  }
  return '<span class="rel-sentiment ' + cls + '">' + esc(sentiment) + '</span>';
}

function syntaxHighlight(json) {
  var str = JSON.stringify(json, null, 2);
  return str.replace(
    /("(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\"])*"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g,
    function(match) {
      var cls = 'json-number';
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = 'json-key';
        } else {
          cls = 'json-string';
        }
      } else if (/true|false/.test(match)) {
        cls = 'json-bool';
      } else if (/null/.test(match)) {
        cls = 'json-null';
      }
      return '<span class="' + cls + '">' + match + '</span>';
    }
  );
}

function buildStructuredView(data) {
  var html = '';
  var e = data.entity || {};
  var meta = data.extraction_metadata || {};
  var type = e.entity_type || 'person';

  // Entity card
  var name = type === 'person' ? (e.name?.full || '') : (e.name?.common || e.name?.legal || '');
  html += '<div class="entity-card">';
  html += '<div class="entity-card-header">';
  html += '<span class="entity-name">' + esc(name) + '</span>';
  if (e.entity_id) html += '<span class="entity-id">' + esc(e.entity_id) + '</span>';
  html += confidenceBadge(meta.extraction_confidence);
  html += '</div>';
  if (e.summary?.value) {
    html += '<div class="entity-summary">' + esc(e.summary.value) + '</div>';
  }
  html += '</div>';

  // Stats bar
  var stats = [];
  stats.push({ v: (data.attributes || []).length, l: 'attributes' });
  stats.push({ v: (data.relationships || []).length, l: 'relationships' });
  stats.push({ v: (data.values || []).length, l: 'values' });
  stats.push({ v: (data.key_facts || []).length, l: 'key facts' });
  if ((data.constraints || []).length > 0) stats.push({ v: data.constraints.length, l: 'constraints' });
  if ((data.action_suggestions || []).length > 0) stats.push({ v: data.action_suggestions.length, l: 'actions' });
  html += '<div class="stats">' + stats.map(function(s) {
    return '<div class="stat"><span class="stat-value">' + s.v + '</span><span class="stat-label">' + s.l + '</span></div>';
  }).join('') + '</div>';

  // Attributes
  var attrs = data.attributes || [];
  if (attrs.length > 0) {
    html += '<div class="section"><div class="section-title">Attributes</div>';
    attrs.forEach(function(a) {
      html += '<div class="item-row">';
      html += '<span class="item-key">' + esc(a.key || '') + '</span>';
      html += '<span class="item-value">' + esc(String(a.value || '')) + '</span>';
      html += confidenceBadge(a.confidence, a.confidence_label);
      html += timeBadge(a.time_decay);
      html += layerBadge(a.facts_layer);
      html += '</div>';
    });
    html += '</div>';
  }

  // Relationships
  var rels = data.relationships || [];
  if (rels.length > 0) {
    html += '<div class="section"><div class="section-title">Relationships</div>';
    rels.forEach(function(r) {
      html += '<div class="item-row">';
      html += '<span class="item-key">' + esc(r.name || '') + '</span>';
      html += '<span class="item-value">' + esc(r.relationship_type || '') + (r.context ? ' — ' + esc(r.context) : '') + '</span>';
      html += sentimentBadge(r.sentiment);
      html += confidenceBadge(r.confidence, r.confidence_label);
      html += '</div>';
    });
    html += '</div>';
  }

  // Values
  var vals = data.values || [];
  if (vals.length > 0) {
    html += '<div class="section"><div class="section-title">Values</div>';
    vals.forEach(function(v) {
      html += '<div class="item-row">';
      html += '<span class="item-key">' + esc(v.value || '') + '</span>';
      html += '<span class="item-value">' + esc(v.interpretation || '') + '</span>';
      html += confidenceBadge(v.confidence, v.confidence_label);
      html += timeBadge(v.time_decay);
      html += '</div>';
    });
    html += '</div>';
  }

  // Key Facts
  var facts = data.key_facts || [];
  if (facts.length > 0) {
    html += '<div class="section"><div class="section-title">Key Facts</div>';
    facts.forEach(function(f) {
      html += '<div class="item-row">';
      html += '<span class="item-value">' + esc(f.fact || '') + '</span>';
      html += confidenceBadge(f.confidence, f.confidence_label);
      html += timeBadge(f.time_decay);
      html += layerBadge(f.facts_layer);
      if (f.category) html += '<span class="badge badge-time">' + esc(f.category) + '</span>';
      html += '</div>';
    });
    html += '</div>';
  }

  // Constraints
  var constraints = data.constraints || [];
  if (constraints.length > 0) {
    html += '<div class="section"><div class="section-title">Constraints</div>';
    constraints.forEach(function(c) {
      html += '<div class="constraint-card">';
      html += '<div class="constraint-name">' + esc(c.type || c.constraint_id || '') + '</div>';
      html += '<div class="constraint-desc">' + esc(c.description || '') + '</div>';
      if (c.linked_entities && c.linked_entities.length > 0) {
        html += '<div class="constraint-desc" style="margin-top:4px;color:#6366f1;">Linked: ' + c.linked_entities.map(function(le) { return esc(le); }).join(', ') + '</div>';
      }
      html += '</div>';
    });
    html += '</div>';
  }

  // Action Suggestions
  var actions = data.action_suggestions || [];
  if (actions.length > 0) {
    html += '<div class="section"><div class="section-title">Action Suggestions</div>';
    actions.forEach(function(a) {
      html += '<div class="item-row">';
      html += '<span class="item-key" style="color:#34d399;">' + esc(a.priority || '') + '</span>';
      html += '<span class="item-value">' + esc(a.action || a.suggestion || '') + '</span>';
      if (a.rationale) html += '<span class="badge badge-time">' + esc(a.rationale) + '</span>';
      html += '</div>';
    });
    html += '</div>';
  }

  // Provenance
  var prov = data.provenance_chain || {};
  if (prov.created_at || prov.source_documents?.length > 0) {
    html += '<div class="provenance">';
    if (prov.created_at) html += 'Created: <code>' + esc(prov.created_at) + '</code>';
    if (prov.source_documents?.length > 0) {
      html += ' | Sources: <code>' + prov.source_documents.length + '</code>';
    }
    if (meta.schema_version) html += ' | Schema: <code>v' + esc(meta.schema_version) + '</code>';
    if (meta.source_hash) html += ' | Hash: <code>' + esc(meta.source_hash.slice(0, 12)) + '...</code>';
    html += '</div>';
  }

  return html;
}

async function extract(type) {
  var text = document.getElementById('input').value.trim();
  if (!text) return;

  var btnP = document.getElementById('btn-person');
  var btnB = document.getElementById('btn-business');
  var result = document.getElementById('result');
  var timer = document.getElementById('timer');

  btnP.disabled = true;
  btnB.disabled = true;
  lastResult = null;
  hideActionButtons();
  result.innerHTML = '<div class="loading"><div class="spinner"></div><div class="loading-text">Extracting ' + type + ' context (v2)...</div></div>';

  var start = Date.now();
  var interval = setInterval(function() {
    timer.textContent = ((Date.now() - start) / 1000).toFixed(1) + 's';
  }, 100);

  try {
    var res = await fetch('/extract', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: text, type: type })
    });
    var data = await res.json();
    clearInterval(interval);
    timer.textContent = ((Date.now() - start) / 1000).toFixed(1) + 's';

    if (data.error) {
      result.innerHTML = '<div class="empty-state" style="color:#ef4444;">Error: ' + data.error + '</div>';
    } else {
      lastResult = data;
      showActionButtons();
      var structuredHtml = buildStructuredView(data);
      var jsonHtml = '<pre>' + syntaxHighlight(data) + '</pre>';
      result.innerHTML = '<div class="structured-view active">' + structuredHtml + '</div>' +
                         '<div class="json-view">' + jsonHtml + '</div>';
      currentView = 'structured';
      document.querySelectorAll('.view-btn').forEach(function(b) {
        b.classList.toggle('active', b.dataset.view === 'structured');
      });
    }
  } catch (err) {
    clearInterval(interval);
    result.innerHTML = '<div class="empty-state" style="color:#ef4444;">Request failed: ' + err.message + '</div>';
  }

  btnP.disabled = false;
  btnB.disabled = false;
}
</script>
</body>
</html>`;

// --- Ingest UI ---

app.get('/ingest', (req, res) => {
  res.send(INGEST_HTML);
});

const INGEST_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChatGPT Import — Context Engine</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0a0a0f;
    color: #e0e0e0;
    min-height: 100vh;
  }
  .container { max-width: 720px; margin: 0 auto; padding: 40px 24px; }
  header { text-align: center; margin-bottom: 48px; }
  h1 { font-size: 2.2rem; font-weight: 700; color: #fff; letter-spacing: -0.02em; }
  h1 span {
    background: linear-gradient(135deg, #6366f1, #8b5cf6, #a78bfa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .subtitle { font-size: 1rem; color: #6b7280; margin-top: 8px; }
  .steps {
    font-size: 0.8rem; color: #4b5563; margin-top: 16px; line-height: 1.7;
    text-align: left; max-width: 480px; margin-left: auto; margin-right: auto;
  }
  .steps strong { color: #6b7280; }

  .field { margin-bottom: 20px; }
  .field label {
    display: block; font-size: 0.8rem; font-weight: 600; color: #6b7280;
    text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
  }
  .field input {
    width: 100%; padding: 10px 14px; background: #12121a;
    border: 1px solid #1e1e2e; border-radius: 8px; color: #e0e0e0;
    font-size: 0.9rem; outline: none; font-family: 'SF Mono', 'Fira Code', monospace;
  }
  .field input:focus { border-color: #6366f1; }

  .drop-zone {
    border: 2px dashed #2a2a3e; border-radius: 12px;
    padding: 48px 24px; text-align: center; cursor: pointer;
    transition: all 0.2s; background: #12121a; margin-bottom: 24px;
  }
  .drop-zone:hover, .drop-zone.dragover {
    border-color: #6366f1; background: rgba(99, 102, 241, 0.05);
  }
  .drop-zone.has-file {
    border-color: #34d399; background: rgba(52, 211, 153, 0.05);
  }
  .drop-icon { font-size: 1.6rem; margin-bottom: 10px; color: #3a3a4a; }
  .drop-text { color: #6b7280; font-size: 0.9rem; }
  .drop-text strong { color: #a78bfa; }
  .file-info {
    color: #34d399; font-size: 0.85rem; margin-top: 10px;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .btn {
    width: 100%; padding: 14px; border: none; border-radius: 8px;
    font-size: 1rem; font-weight: 600; cursor: pointer;
    background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white;
    transition: all 0.2s;
  }
  .btn:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
  }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; }

  .progress-section { display: none; margin: 24px 0; }
  .progress-section.active { display: block; }
  .progress-bar-bg {
    width: 100%; height: 8px; background: #1e1e2e;
    border-radius: 4px; overflow: hidden; margin-bottom: 12px;
  }
  .progress-bar {
    height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6);
    border-radius: 4px; transition: width 0.3s; width: 0%;
  }
  .progress-text { font-size: 0.85rem; color: #9ca3af; }
  .progress-stats {
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.8rem; color: #6b7280; margin-top: 8px;
  }

  .summary { display: none; margin: 24px 0; }
  .summary.active { display: block; }
  .summary-card {
    background: #12121a; border: 1px solid #1e1e2e;
    border-radius: 12px; padding: 24px;
  }
  .summary-title { font-size: 1.1rem; font-weight: 700; color: #34d399; margin-bottom: 16px; }
  .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .summary-stat {
    background: #1a1a2e; border: 1px solid #2a2a3e;
    border-radius: 8px; padding: 14px; text-align: center;
  }
  .summary-stat-value { font-size: 1.5rem; font-weight: 700; color: #a78bfa; }
  .summary-stat-label {
    font-size: 0.7rem; color: #6b7280;
    text-transform: uppercase; letter-spacing: 0.05em; margin-top: 4px;
  }

  .error-msg { color: #ef4444; font-size: 0.85rem; margin-top: 12px; display: none; }
  .error-msg.active { display: block; }

  footer {
    text-align: center; padding: 40px 24px 24px;
    color: #3a3a4a; font-size: 0.8rem;
  }
  footer a { color: #6b7280; text-decoration: none; }
  footer a:hover { color: #a78bfa; }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><span>ChatGPT Import</span></h1>
    <p class="subtitle">Import your ChatGPT conversation history into the knowledge graph</p>
    <div class="steps">
      <strong>How it works:</strong> Go to ChatGPT Settings &rarr; Data Controls &rarr; Export Data.
      You will receive a zip file containing <strong>conversations.json</strong>.
      Drop that file below. The engine extracts every person and business
      you mentioned, deduplicates across conversations, and builds your graph.
    </div>
  </header>

  <div class="field">
    <label>API Key</label>
    <input type="password" id="apiKey" placeholder="ctx-..." />
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-icon">&#8593;</div>
    <div class="drop-text">Drag &amp; drop <strong>conversations.json</strong> here, or click to browse</div>
    <div class="file-info" id="fileInfo"></div>
  </div>
  <input type="file" id="fileInput" accept=".json" style="display:none" />

  <button class="btn" id="btnImport" onclick="startImport()" disabled>Import Conversations</button>
  <div class="error-msg" id="errorMsg"></div>

  <div class="progress-section" id="progress">
    <div class="progress-bar-bg"><div class="progress-bar" id="progressBar"></div></div>
    <div class="progress-text" id="progressText">Starting import...</div>
    <div class="progress-stats" id="progressStats"></div>
  </div>

  <div class="summary" id="summary">
    <div class="summary-card">
      <div class="summary-title">Import Complete</div>
      <div class="summary-grid" id="summaryGrid"></div>
    </div>
  </div>
</div>

<footer>
  <a href="/">&larr; Back to Context Engine</a>
</footer>

<script>
var fileData = null;

var dropZone = document.getElementById('dropZone');
var fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', function() { fileInput.click(); });
dropZone.addEventListener('dragover', function(e) {
  e.preventDefault(); dropZone.classList.add('dragover');
});
dropZone.addEventListener('dragleave', function() {
  dropZone.classList.remove('dragover');
});
dropZone.addEventListener('drop', function(e) {
  e.preventDefault(); dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', function() {
  if (fileInput.files.length) handleFile(fileInput.files[0]);
});

function handleFile(file) {
  if (!file) return;
  showError('');
  var reader = new FileReader();
  reader.onload = function(e) {
    try {
      var data = JSON.parse(e.target.result);
      if (!Array.isArray(data)) throw new Error('Expected a JSON array of conversations');
      fileData = data;
      dropZone.classList.add('has-file');
      document.getElementById('fileInfo').textContent =
        file.name + ' \\u2014 ' + data.length + ' conversations (' + (file.size / 1048576).toFixed(1) + ' MB)';
      document.getElementById('btnImport').disabled = false;
    } catch (err) {
      showError('Invalid file: ' + err.message);
      fileData = null;
    }
  };
  reader.readAsText(file);
}

function showError(msg) {
  var el = document.getElementById('errorMsg');
  el.textContent = msg;
  if (msg) { el.classList.add('active'); } else { el.classList.remove('active'); }
}

async function startImport() {
  var apiKey = document.getElementById('apiKey').value.trim();
  if (!apiKey) return showError('API key is required');
  if (!fileData) return showError('No file selected');

  document.getElementById('btnImport').disabled = true;
  showError('');
  document.getElementById('progress').classList.add('active');
  document.getElementById('summary').classList.remove('active');
  document.getElementById('progressBar').style.width = '0%';
  document.getElementById('progressText').textContent = 'Starting import...';
  document.getElementById('progressStats').textContent = '';

  try {
    var response = await fetch('/api/ingest/chatgpt', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Context-API-Key': apiKey },
      body: JSON.stringify({ conversations: fileData }),
    });

    if (!response.ok && !response.headers.get('content-type').includes('ndjson')) {
      var errBody = await response.json();
      throw new Error(errBody.error || 'Request failed with status ' + response.status);
    }

    var reader = response.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';

    while (true) {
      var chunk = await reader.read();
      if (chunk.done) break;
      buffer += decoder.decode(chunk.value, { stream: true });
      var lines = buffer.split('\\n');
      buffer = lines.pop();
      for (var i = 0; i < lines.length; i++) {
        if (!lines[i].trim()) continue;
        try { handleEvent(JSON.parse(lines[i])); } catch (e) {}
      }
    }
    if (buffer.trim()) {
      try { handleEvent(JSON.parse(buffer)); } catch (e) {}
    }
  } catch (err) {
    showError(err.message);
  }

  document.getElementById('btnImport').disabled = false;
}

function handleEvent(event) {
  if (event.type === 'started') {
    document.getElementById('progressText').textContent =
      'Processing ' + event.total_conversations + ' conversations in ' + event.total_batches + ' batches...';
  } else if (event.type === 'progress') {
    var pct = Math.round((event.batch / event.total_batches) * 100);
    document.getElementById('progressBar').style.width = pct + '%';
    document.getElementById('progressText').textContent =
      'Batch ' + event.batch + ' / ' + event.total_batches +
      ' \\u2014 ' + event.conversations_processed + ' of ' + event.total_conversations + ' conversations';
    document.getElementById('progressStats').textContent =
      event.entities_created + ' created, ' +
      event.entities_updated + ' updated, ' +
      event.observations_added + ' observations';
  } else if (event.type === 'complete') {
    document.getElementById('progressBar').style.width = '100%';
    document.getElementById('progressText').textContent = 'Done!';
    showSummary(event.summary);
  } else if (event.type === 'batch_error') {
    var stats = document.getElementById('progressStats');
    stats.textContent += ' [batch ' + event.batch + ' error: ' + event.error + ']';
  }
}

function showSummary(s) {
  document.getElementById('summary').classList.add('active');
  var items = [
    { value: s.entities_created, label: 'Entities Created' },
    { value: s.entities_updated, label: 'Entities Updated' },
    { value: s.observations_added, label: 'Observations Added' },
    { value: s.conversations_processed, label: 'Conversations' },
    { value: s.processing_time_seconds + 's', label: 'Processing Time' },
  ];
  document.getElementById('summaryGrid').innerHTML = items.map(function(it) {
    return '<div class="summary-stat"><div class="summary-stat-value">' +
      it.value + '</div><div class="summary-stat-label">' + it.label + '</div></div>';
  }).join('');
}
</script>
</body>
</html>`;

// --- Wiki Dashboard ---

app.get('/wiki', (req, res) => {
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.set('Pragma', 'no-cache');
  res.removeHeader('ETag');
  res.send(WIKI_HTML);
});

// Catch-all for SPA routes (entity detail, connections page, etc.)
app.get('/wiki/entity/:id/connections', (req, res) => {
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.set('Pragma', 'no-cache');
  res.removeHeader('ETag');
  res.send(WIKI_HTML);
});

// --- Public shared profile view (NO auth) ---

function escHtml(str) {
  return String(str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function renderSharedErrorPage(title, message) {
  return `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${escHtml(title)}</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8f9fa; min-height: 100vh; display: flex; align-items: center; justify-content: center; }
  .error-card { background: #fff; border-radius: 12px; padding: 48px; max-width: 420px; text-align: center; box-shadow: 0 2px 12px rgba(0,0,0,0.08); }
  .error-card h1 { font-size: 1.4rem; color: #1a1a2e; margin-bottom: 12px; }
  .error-card p { font-size: 0.95rem; color: #64748b; line-height: 1.6; }
  .footer { margin-top: 32px; font-size: 0.75rem; color: #94a3b8; }
</style></head><body>
<div class="error-card">
  <h1>${escHtml(title)}</h1>
  <p>${escHtml(message)}</p>
  <div class="footer">Shared via Context Architecture</div>
</div></body></html>`;
}

function renderSharedProfilePage(entity, share) {
  const e = entity.entity || {};
  const cl = entity.career_lite || {};
  const name = e.name?.full || 'Unknown';
  const initials = name.split(/\s+/).map(w => w[0] || '').join('').toUpperCase();
  const sections = share.sections || [];

  let body = '';

  // Summary
  if (sections.includes('summary') && e.summary?.value) {
    body += '<div class="sp-section"><h2>Summary</h2><p>' + escHtml(e.summary.value) + '</p></div>';
  }

  // Experience
  if (sections.includes('experience') && cl.experience?.length) {
    body += '<div class="sp-section"><h2>Experience</h2>';
    for (const x of cl.experience) {
      body += '<div class="sp-card">';
      if (x.company) body += '<div class="sp-card-title">' + escHtml(x.company) + '</div>';
      if (x.title) body += '<div class="sp-card-subtitle">' + escHtml(x.title) + '</div>';
      const dates = [x.start_date, x.end_date].filter(Boolean).join(' — ');
      if (dates) body += '<div class="sp-card-meta">' + escHtml(dates) + '</div>';
      if (x.description) body += '<div class="sp-card-desc">' + escHtml(x.description) + '</div>';
      body += '</div>';
    }
    body += '</div>';
  }

  // Education
  if (sections.includes('education') && cl.education?.length) {
    body += '<div class="sp-section"><h2>Education</h2>';
    for (const ed of cl.education) {
      body += '<div class="sp-card">';
      if (ed.institution) body += '<div class="sp-card-title">' + escHtml(ed.institution) + '</div>';
      const degree = [ed.degree, ed.field].filter(Boolean).join(', ');
      if (degree) body += '<div class="sp-card-subtitle">' + escHtml(degree) + '</div>';
      if (ed.years) body += '<div class="sp-card-meta">' + escHtml(ed.years) + '</div>';
      body += '</div>';
    }
    body += '</div>';
  }

  // Skills
  if (sections.includes('skills') && cl.skills?.length) {
    body += '<div class="sp-section"><h2>Skills</h2><div class="sp-skills">';
    for (const s of cl.skills) {
      body += '<span class="sp-skill-tag">' + escHtml(s) + '</span>';
    }
    body += '</div></div>';
  }

  // Connections
  if (sections.includes('connections') && e.relationships?.length) {
    body += '<div class="sp-section"><h2>Connections</h2>';
    for (const r of e.relationships) {
      body += '<div class="sp-card">';
      if (r.name) body += '<div class="sp-card-title">' + escHtml(r.name) + '</div>';
      const detail = [r.relationship, r.context].filter(Boolean).join(' — ');
      if (detail) body += '<div class="sp-card-subtitle">' + escHtml(detail) + '</div>';
      body += '</div>';
    }
    body += '</div>';
  }

  // Role / Location
  let subtitle = '';
  if (e.attributes?.role) subtitle += escHtml(e.attributes.role);
  if (e.attributes?.location) subtitle += (subtitle ? ' &middot; ' : '') + escHtml(e.attributes.location);

  return `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${escHtml(name)} — Shared Profile</title>
<meta property="og:title" content="${escHtml(name)} — Shared Profile">
<meta property="og:description" content="${escHtml(subtitle || 'Career profile shared via Context Architecture')}">
<meta property="og:type" content="profile">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8f9fa; color: #1a1a2e; min-height: 100vh; }
  .sp-header { background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 48px 24px 36px; text-align: center; color: #fff; }
  .sp-avatar { width: 80px; height: 80px; border-radius: 50%; background: rgba(255,255,255,0.2); display: inline-flex; align-items: center; justify-content: center; font-size: 1.8rem; font-weight: 700; margin-bottom: 16px; border: 3px solid rgba(255,255,255,0.3); }
  .sp-name { font-size: 1.6rem; font-weight: 700; margin-bottom: 4px; }
  .sp-subtitle { font-size: 0.95rem; opacity: 0.85; }
  .sp-body { max-width: 640px; margin: -20px auto 40px; padding: 0 16px; }
  .sp-section { background: #fff; border-radius: 10px; padding: 24px; margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); }
  .sp-section h2 { font-size: 1rem; font-weight: 600; color: #6366f1; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px; font-size: 0.8rem; }
  .sp-section > p { font-size: 0.92rem; line-height: 1.7; color: #475569; }
  .sp-card { padding: 12px 0; border-bottom: 1px solid #f1f5f9; }
  .sp-card:last-child { border-bottom: none; padding-bottom: 0; }
  .sp-card:first-of-type { padding-top: 0; }
  .sp-card-title { font-size: 0.92rem; font-weight: 600; color: #1a1a2e; }
  .sp-card-subtitle { font-size: 0.85rem; color: #475569; margin-top: 2px; }
  .sp-card-meta { font-size: 0.78rem; color: #94a3b8; margin-top: 2px; }
  .sp-card-desc { font-size: 0.85rem; color: #64748b; margin-top: 6px; line-height: 1.5; }
  .sp-skills { display: flex; flex-wrap: wrap; gap: 8px; }
  .sp-skill-tag { display: inline-block; padding: 6px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 500; background: #ede9fe; color: #6366f1; }
  .sp-footer { text-align: center; padding: 24px; font-size: 0.75rem; color: #94a3b8; }
  @media (max-width: 600px) {
    .sp-header { padding: 32px 16px 28px; }
    .sp-name { font-size: 1.3rem; }
    .sp-body { margin-top: -12px; }
    .sp-section { padding: 18px; }
  }
</style></head><body>
<div class="sp-header">
  <div class="sp-avatar">${escHtml(initials)}</div>
  <div class="sp-name">${escHtml(name)}</div>
  ${subtitle ? '<div class="sp-subtitle">' + subtitle + '</div>' : ''}
</div>
<div class="sp-body">${body}</div>
<div class="sp-footer">Shared via Context Architecture</div>
</body></html>`;
}

// --- Shared Client Portal renderer (Build 7) ---

function _portalFormatLabel(s) {
  return (s || '').replace(/_/g, ' ').replace(/\b[a-z]/g, function(l) { return l.toUpperCase(); });
}

function _portalScoreColor(score) {
  if (score >= 0.8) return '#16A34A';
  if (score >= 0.5) return '#CA8A04';
  return '#DC2626';
}

function _portalBadgeHtml(status) {
  const colors = { verified: '#16A34A', low_confidence: '#CA8A04', conflict: '#DC2626', missing: '#6B7280' };
  const labels = { verified: 'Verified', low_confidence: 'Low Confidence', conflict: 'Conflict', missing: 'Missing' };
  const c = colors[status] || '#6B7280';
  return `<span style="display:inline-block;padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;background:${c}18;color:${c};">${labels[status] || status}</span>`;
}

function renderPortalCompleteness(gapData) {
  const pct = Math.round((gapData.overall_score || 0) * 100);
  const color = _portalScoreColor(gapData.overall_score || 0);
  const deg = Math.round(pct * 3.6);

  let h = '<div style="background:#fff;border-radius:12px;padding:28px;margin-bottom:20px;box-shadow:0 1px 4px rgba(0,0,0,0.06);">';
  h += '<h2 style="font-size:1rem;font-weight:700;color:#1a1a2e;margin:0 0 20px;">Completeness Analysis</h2>';

  // Ring + bars container
  h += '<div style="display:flex;gap:32px;align-items:flex-start;flex-wrap:wrap;">';

  // Conic ring
  h += `<div style="width:150px;height:150px;border-radius:50%;background:conic-gradient(${color} 0deg, ${color} ${deg}deg, #e8e8e8 ${deg}deg);display:flex;align-items:center;justify-content:center;flex-shrink:0;">`;
  h += `<div style="width:120px;height:120px;border-radius:50%;background:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;">`;
  h += `<div style="font-size:2rem;font-weight:700;color:${color};">${pct}%</div>`;
  h += '<div style="font-size:0.75rem;color:#6B7280;">Complete</div>';
  h += '</div></div>';

  // Score bars
  h += '<div style="flex:1;min-width:200px;">';
  const bars = [
    { label: 'Documents', score: gapData.document_score || 0, weight: '40%' },
    { label: 'Entities', score: gapData.entity_score || 0, weight: '40%' },
    { label: 'Relationships', score: gapData.relationship_score || 0, weight: '20%' }
  ];
  for (const bar of bars) {
    const bPct = Math.round(bar.score * 100);
    const bColor = _portalScoreColor(bar.score);
    h += '<div style="margin-bottom:12px;">';
    h += `<div style="display:flex;justify-content:space-between;font-size:0.82rem;margin-bottom:4px;"><span>${bar.label} <span style="color:#94a3b8;font-size:11px;">(${bar.weight})</span></span><span style="font-weight:600;color:${bColor};">${bPct}%</span></div>`;
    h += `<div style="height:8px;background:#e8e8e8;border-radius:4px;overflow:hidden;"><div style="height:100%;width:${bPct}%;background:${bColor};border-radius:4px;transition:width 0.3s;"></div></div>`;
    h += '</div>';
  }
  h += '</div></div>';

  // Missing Documents
  const missingDocs = gapData.missing_documents || [];
  if (missingDocs.length > 0) {
    h += '<div style="margin-top:24px;">';
    h += `<h3 style="font-size:0.85rem;font-weight:600;color:#DC2626;margin:0 0 12px;">Missing Documents (${missingDocs.length})</h3>`;
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px;">';
    for (const doc of missingDocs) {
      h += '<div style="display:flex;align-items:center;gap:10px;padding:10px 12px;background:#fef2f2;border:1px solid #fecaca;border-radius:8px;font-size:0.82rem;">';
      h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      h += `<span>${escHtml(_portalFormatLabel(doc.item))}</span></div>`;
    }
    h += '</div></div>';
  }

  // Missing Fields
  const missingFields = gapData.missing_entity_fields || [];
  if (missingFields.length > 0) {
    h += '<div style="margin-top:20px;">';
    h += `<h3 style="font-size:0.85rem;font-weight:600;color:#CA8A04;margin:0 0 12px;">Missing Entity Fields (${missingFields.length})</h3>`;
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px;">';
    for (const field of missingFields) {
      h += '<div style="display:flex;align-items:center;gap:10px;padding:10px 12px;background:#fffbeb;border:1px solid #fde68a;border-radius:8px;font-size:0.82rem;">';
      h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#CA8A04" stroke-width="1.5"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
      h += `<span>${escHtml(_portalFormatLabel(field.missing))} <span style="color:#94a3b8;">— ${escHtml(_portalFormatLabel(field.role))}</span></span></div>`;
    }
    h += '</div></div>';
  }

  // Missing Relationships
  const missingRels = gapData.missing_relationships || [];
  if (missingRels.length > 0) {
    h += '<div style="margin-top:20px;">';
    h += `<h3 style="font-size:0.85rem;font-weight:600;color:#7C3AED;margin:0 0 12px;">Missing Relationships (${missingRels.length})</h3>`;
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px;">';
    for (const rel of missingRels) {
      h += '<div style="display:flex;align-items:center;gap:10px;padding:10px 12px;background:#f5f3ff;border:1px solid #ddd6fe;border-radius:8px;font-size:0.82rem;">';
      h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#7C3AED" stroke-width="1.5"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg>';
      h += `<span>${escHtml(_portalFormatLabel(rel.expected))}</span></div>`;
    }
    h += '</div></div>';
  }

  // Found Documents
  const foundDocs = gapData.found_documents || [];
  if (foundDocs.length > 0) {
    h += '<div style="margin-top:20px;">';
    h += `<h3 style="font-size:0.85rem;font-weight:600;color:#065F46;margin:0 0 12px;">Found Documents (${foundDocs.length})</h3>`;
    h += '<div style="display:flex;flex-wrap:wrap;gap:6px;">';
    for (const fd of foundDocs) {
      h += `<span style="display:inline-flex;align-items:center;gap:4px;padding:4px 10px;background:#dcfce7;border-radius:12px;font-size:0.78rem;color:#166534;"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>${escHtml(_portalFormatLabel(fd.item))}</span>`;
    }
    h += '</div></div>';
  }

  // Suggestions
  const suggestions = gapData.suggestions || [];
  if (suggestions.length > 0) {
    h += '<div style="margin-top:20px;padding:16px;background:#eff6ff;border-radius:8px;">';
    h += '<h3 style="font-size:0.85rem;font-weight:600;color:#1e40af;margin:0 0 8px;">Suggested Next Steps</h3>';
    h += '<ul style="margin:0;padding:0 0 0 20px;font-size:0.82rem;color:#1e40af;line-height:1.7;">';
    for (const s of suggestions) h += `<li>${escHtml(s)}</li>`;
    h += '</ul></div>';
  }

  h += '</div>';
  return h;
}

function renderPortalExport(exportData, spoke, token) {
  const s = exportData.summary || {};
  let h = '<div style="background:#fff;border-radius:12px;padding:28px;margin-bottom:20px;box-shadow:0 1px 4px rgba(0,0,0,0.06);">';
  h += '<h2 style="font-size:1rem;font-weight:700;color:#1a1a2e;margin:0 0 20px;">Extracted Data</h2>';

  // Summary stats
  h += '<div style="display:flex;gap:20px;flex-wrap:wrap;margin-bottom:24px;">';
  h += `<div style="text-align:center;"><div style="font-size:1.5rem;font-weight:700;color:#191919;">${s.total_fields || 0}</div><div style="font-size:0.75rem;color:#6B7280;">Total</div></div>`;
  h += `<div style="text-align:center;"><div style="font-size:1.5rem;font-weight:700;color:#16A34A;">${s.verified || 0}</div><div style="font-size:0.75rem;color:#6B7280;">Verified</div></div>`;
  if (s.low_confidence) h += `<div style="text-align:center;"><div style="font-size:1.5rem;font-weight:700;color:#CA8A04;">${s.low_confidence}</div><div style="font-size:0.75rem;color:#6B7280;">Low Conf</div></div>`;
  if (s.conflicts) h += `<div style="text-align:center;"><div style="font-size:1.5rem;font-weight:700;color:#DC2626;">${s.conflicts}</div><div style="font-size:0.75rem;color:#6B7280;">Conflicts</div></div>`;
  h += `<div style="text-align:center;"><div style="font-size:1.5rem;font-weight:700;color:#6B7280;">${s.missing || 0}</div><div style="font-size:0.75rem;color:#6B7280;">Missing</div></div>`;
  h += '</div>';

  // Role cards
  const roles = exportData.roles || [];
  for (let ri = 0; ri < roles.length; ri++) {
    const role = roles[ri];
    let roleVerified = 0, roleTotal = 0;
    for (const ent of (role.entities || [])) {
      for (const f of (ent.fields || [])) { roleTotal++; if (f.status === 'verified') roleVerified++; }
    }
    const allComplete = (roleVerified === roleTotal && roleTotal > 0);
    const isOrg = role.role === 'business_entity';

    h += `<div style="border:1px solid #e5e5ea;border-radius:10px;margin-bottom:12px;overflow:hidden;">`;
    // Header
    h += `<div onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'" style="display:flex;align-items:center;gap:10px;padding:14px 16px;background:#fafafa;cursor:pointer;user-select:none;">`;
    if (isOrg) {
      h += '<div style="width:28px;height:28px;border-radius:6px;background:#dbeafe;display:flex;align-items:center;justify-content:center;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#2563eb" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></div>';
    } else {
      h += '<div style="width:28px;height:28px;border-radius:6px;background:#ede9fe;display:flex;align-items:center;justify-content:center;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg></div>';
    }
    h += `<span style="font-weight:600;font-size:0.9rem;flex:1;">${escHtml(_portalFormatLabel(role.role))}</span>`;
    h += `<span style="font-size:0.78rem;color:${allComplete ? '#16A34A' : '#6B7280'};font-weight:600;">${roleVerified}/${roleTotal} fields</span>`;
    h += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#94a3b8" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
    h += '</div>';

    // Body
    h += '<div style="padding:0 16px 16px;">';
    const hasEntities = role.entities && role.entities.length > 0 && !(role.entities.length === 1 && !role.entities[0].entity_id);

    if (!hasEntities) {
      h += '<div style="padding:12px 0;font-size:0.82rem;color:#94a3b8;font-style:italic;">No matching entity found</div>';
      if (role.entities && role.entities[0]) {
        for (const f of (role.entities[0].fields || [])) {
          h += `<div style="display:flex;align-items:center;gap:12px;padding:8px 0;border-bottom:1px solid #f3f4f6;font-size:0.82rem;opacity:0.6;">`;
          h += `<span style="min-width:140px;color:#6B7280;">${escHtml(_portalFormatLabel(f.field))}</span>`;
          h += `<span style="color:#d1d5db;">—</span>`;
          h += `<span style="margin-left:auto;">${_portalBadgeHtml('missing')}</span></div>`;
        }
      }
    } else {
      for (const ent of role.entities) {
        if (role.entities.length > 1) {
          h += `<div style="font-size:0.82rem;font-weight:600;color:#4b5563;padding:10px 0 6px;border-bottom:1px solid #f3f4f6;">${escHtml(ent.entity_name)}</div>`;
        }
        for (const f of (ent.fields || [])) {
          const isMissing = f.status === 'missing';
          h += `<div style="display:flex;align-items:center;gap:12px;padding:8px 0;border-bottom:1px solid #f3f4f6;font-size:0.82rem;${isMissing ? 'opacity:0.6;' : ''}">`;
          h += `<span style="min-width:140px;color:#6B7280;">${escHtml(_portalFormatLabel(f.field))}</span>`;
          h += f.value ? `<span style="flex:1;color:#1a1a2e;font-weight:500;">${escHtml(String(f.value))}</span>` : '<span style="flex:1;color:#d1d5db;">—</span>';
          h += `<span style="display:flex;align-items:center;gap:6px;margin-left:auto;">${_portalBadgeHtml(f.status)}`;
          if (f.provenance && f.provenance.filename) {
            h += `<span style="display:inline-flex;align-items:center;gap:3px;padding:2px 8px;background:#f3f4f6;border-radius:10px;font-size:10px;color:#6B7280;cursor:pointer;" onclick="var el=this.parentElement.parentElement.nextElementSibling;if(el)el.style.display=el.style.display==='none'?'block':'none';">`;
            h += `<svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>`;
            h += `${escHtml(f.provenance.filename)}</span>`;
          }
          h += '</span></div>';
          // Evidence expansion area
          if (f.provenance && f.provenance.snippet) {
            h += '<div style="display:none;padding:8px 12px;margin:4px 0 4px 140px;background:#f8f9fa;border-radius:6px;font-size:0.78rem;border-left:3px solid #6366f1;">';
            h += `<div style="color:#475569;font-style:italic;">&ldquo;${escHtml(f.provenance.snippet)}&rdquo;</div>`;
            if (f.provenance.location) h += `<div style="color:#94a3b8;margin-top:4px;">Location: ${escHtml(f.provenance.location)}</div>`;
            h += '</div>';
          }
        }
      }
    }
    h += '</div></div>';
  }

  h += '</div>';
  return h;
}

function renderPortalFiles(files, spokeId, token) {
  let h = '<div style="background:#fff;border-radius:12px;padding:28px;margin-bottom:20px;box-shadow:0 1px 4px rgba(0,0,0,0.06);">';
  h += `<h2 style="font-size:1rem;font-weight:700;color:#1a1a2e;margin:0 0 20px;">Source Files (${files.length})</h2>`;

  if (files.length === 0) {
    h += '<div style="text-align:center;padding:32px;color:#94a3b8;font-size:0.9rem;">No files uploaded yet</div>';
  } else {
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px;">';
    for (const file of files) {
      const size = file.size ? (file.size > 1024 * 1024 ? (file.size / (1024 * 1024)).toFixed(1) + ' MB' : (file.size / 1024).toFixed(1) + ' KB') : '';
      const date = file.uploaded_at ? new Date(file.uploaded_at).toLocaleDateString() : '';
      const downloadUrl = `/api/spoke/${encodeURIComponent(spokeId)}/file/${encodeURIComponent(file.file_id)}?token=${encodeURIComponent(token)}`;

      h += '<div style="display:flex;align-items:center;gap:12px;padding:14px 16px;border:1px solid #e5e5ea;border-radius:10px;transition:border-color 0.15s;">';
      h += '<div style="width:36px;height:36px;border-radius:8px;background:#ede9fe;display:flex;align-items:center;justify-content:center;flex-shrink:0;">';
      h += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg></div>';
      h += '<div style="flex:1;min-width:0;">';
      h += `<div style="font-size:0.85rem;font-weight:600;color:#1a1a2e;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escHtml(file.original_name || file.file_id)}</div>`;
      const meta = [size, date].filter(Boolean).join(' · ');
      if (meta) h += `<div style="font-size:0.75rem;color:#94a3b8;margin-top:2px;">${escHtml(meta)}</div>`;
      h += '</div>';
      h += `<a href="${downloadUrl}" target="_blank" style="display:inline-flex;align-items:center;gap:4px;padding:6px 12px;background:#6366f1;color:#fff;border-radius:6px;font-size:0.78rem;font-weight:600;text-decoration:none;white-space:nowrap;">`;
      h += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
      h += ' Download</a>';
      h += '</div>';
    }
    h += '</div>';
  }

  h += '</div>';
  return h;
}

// Build 13: Client upload zone for shared portal
function renderPortalUploadZone(clientName, token) {
  return `<div style="background:#fff;border-radius:12px;padding:28px;margin-bottom:20px;box-shadow:0 1px 4px rgba(0,0,0,0.06);">
  <h2 style="font-size:1rem;font-weight:700;color:#1a1a2e;margin:0 0 6px;">Upload Documents</h2>
  <p style="font-size:0.85rem;color:#6B7280;margin:0 0 20px;">Upload documents for ${escHtml(clientName)}. Supported formats: PDF, DOCX, XLSX, CSV, TXT, JSON.</p>
  <div id="portalDropzone" style="border:2px dashed #d1d5db;border-radius:12px;padding:40px 24px;text-align:center;cursor:pointer;transition:all 0.2s;background:#fafafe;"
    ondragover="event.preventDefault();this.style.borderColor='#6366f1';this.style.background='#f0f0ff';"
    ondragleave="this.style.borderColor='#d1d5db';this.style.background='#fafafe';"
    ondrop="event.preventDefault();this.style.borderColor='#d1d5db';this.style.background='#fafafe';portalUploadFiles(event.dataTransfer.files);"
    onclick="document.getElementById('portalFileInput').click();">
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="1.5" style="margin-bottom:12px;"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
    <div style="font-size:0.95rem;font-weight:600;color:#333;margin-bottom:4px;">Drop files here or click to browse</div>
    <div style="font-size:0.8rem;color:#94a3b8;">Up to 20 files, 50MB each</div>
    <input type="file" id="portalFileInput" multiple accept=".pdf,.docx,.doc,.xlsx,.xls,.csv,.txt,.md,.json" style="display:none;" onchange="portalUploadFiles(this.files);">
  </div>
  <div id="portalUploadStatus" style="margin-top:12px;"></div>
</div>
<script>
function portalUploadFiles(files) {
  if (!files || files.length === 0) return;
  var status = document.getElementById('portalUploadStatus');
  status.innerHTML = '<div style="padding:12px;background:#eff6ff;border-radius:8px;font-size:0.85rem;color:#1e40af;">Uploading ' + files.length + ' file(s)...</div>';
  var fd = new FormData();
  for (var i = 0; i < files.length; i++) fd.append('files', files[i]);
  fetch('/shared/${escHtml(token)}/upload', { method: 'POST', body: fd })
    .then(function(r) { return r.json(); })
    .then(function(data) {
      if (data.error) {
        status.innerHTML = '<div style="padding:12px;background:#fef2f2;border-radius:8px;font-size:0.85rem;color:#991B1B;">Error: ' + data.error + '</div>';
      } else {
        status.innerHTML = '<div style="padding:12px;background:#f0fdf4;border-radius:8px;font-size:0.85rem;color:#065F46;">Upload complete! ' + (data.files_processed || 0) + ' file(s) processed. ' + (data.entities_created || 0) + ' entities extracted.</div>';
        // Refresh page after brief delay to show updated completeness
        setTimeout(function() { window.location.reload(); }, 2000);
      }
    })
    .catch(function(err) {
      status.innerHTML = '<div style="padding:12px;background:#fef2f2;border-radius:8px;font-size:0.85rem;color:#991B1B;">Upload failed: ' + (err.message || 'Network error') + '</div>';
    });
}
</script>`;
}

function renderSharedClientPortal(spoke, gapData, exportData, files, share) {
  const includes = share.includes || ['gaps', 'export', 'files'];
  const templateLabel = gapData ? _portalFormatLabel(gapData.template_name || gapData.template_type || '') : '';
  const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
  const canUpload = includes.includes('upload');

  let body = '';
  // Upload zone at top if enabled (Build 13)
  if (canUpload) body += renderPortalUploadZone(spoke.name, share.token);
  if (includes.includes('gaps') && gapData) body += renderPortalCompleteness(gapData);
  if (includes.includes('export') && exportData) body += renderPortalExport(exportData, spoke, share.token);
  if (includes.includes('files')) body += renderPortalFiles(files || [], spoke.id, share.token);

  return `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${escHtml(spoke.name)} — Client File Review | Context Architecture</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%236366f1'/><text x='16' y='22' font-size='16' font-weight='bold' fill='white' text-anchor='middle' font-family='system-ui'>CA</text></svg>">
<meta property="og:title" content="${escHtml(spoke.name)} — Client File Review">
<meta property="og:description" content="Shared client matter portal via Context Architecture">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8f9fa; color: #1a1a2e; min-height: 100vh; }
  .portal-header { background: linear-gradient(135deg, #6366f1, #8b5cf6); padding: 48px 24px 36px; text-align: center; color: #fff; }
  .portal-logo { width: 44px; height: 44px; border-radius: 10px; background: rgba(255,255,255,0.2); display: inline-flex; align-items: center; justify-content: center; font-size: 1.1rem; font-weight: 800; margin-bottom: 14px; border: 2px solid rgba(255,255,255,0.3); letter-spacing: -0.5px; }
  .portal-name { font-size: 1.6rem; font-weight: 700; margin-bottom: 8px; }
  .portal-meta { display: flex; align-items: center; justify-content: center; gap: 12px; font-size: 0.85rem; opacity: 0.85; flex-wrap: wrap; }
  .portal-badge { display: inline-block; padding: 3px 10px; background: rgba(255,255,255,0.2); border-radius: 12px; font-size: 0.78rem; font-weight: 600; }
  .portal-body { max-width: 800px; margin: -20px auto 40px; padding: 0 16px; }
  .portal-footer { text-align: center; padding: 32px 24px; font-size: 0.75rem; color: #94a3b8; }
  .portal-footer a { color: #6366f1; text-decoration: none; }
  @media (max-width: 600px) {
    .portal-header { padding: 32px 16px 28px; }
    .portal-name { font-size: 1.3rem; }
    .portal-body { margin-top: -12px; }
  }
</style></head><body>
<div class="portal-header">
  <div class="portal-logo">CA</div>
  <div class="portal-name">${escHtml(spoke.name)}</div>
  <div class="portal-meta">
    ${templateLabel ? '<span class="portal-badge">' + escHtml(templateLabel) + '</span>' : ''}
    <span>${escHtml(dateStr)}</span>
  </div>
</div>
<div class="portal-body">${body}</div>
<div class="portal-footer">Powered by <a href="https://contextarchitecture.com">Context Architecture</a> &mdash; contextarchitecture.com</div>
</body></html>`;
}

app.get('/shared/:shareId', sharedViewLimiter, async (req, res) => {
  const { shareId } = req.params;

  // Phase 1: Check entity shares (shares.json)
  let matchedShare = null;
  let tenantDir = null;

  try {
    const entries = fs.readdirSync(GRAPH_DIR).filter(f => f.startsWith('tenant-'));
    for (const dir of entries) {
      const fullDir = path.join(GRAPH_DIR, dir);
      const shares = loadShares(fullDir);
      const found = shares.find(s => s.shareId === shareId);
      if (found) {
        matchedShare = found;
        tenantDir = fullDir;
        break;
      }
    }
  } catch (err) {
    // GRAPH_DIR might not exist yet
  }

  if (matchedShare) {
    // Check expiry
    if (new Date(matchedShare.expiresAt) < new Date()) {
      return res.status(410).send(renderSharedErrorPage(
        'Link Expired',
        'This shared profile link has expired. Please ask the profile owner to generate a new link.'
      ));
    }

    // Load entity
    const entityPath = path.join(tenantDir, matchedShare.entityId + '.json');
    if (!fs.existsSync(entityPath)) {
      return res.status(404).send(renderSharedErrorPage(
        'Profile Not Found',
        'The profile could not be loaded. It may have been deleted.'
      ));
    }

    const entity = JSON.parse(fs.readFileSync(entityPath, 'utf-8'));
    return res.send(renderSharedProfilePage(entity, matchedShare));
  }

  // Phase 2: Check spoke shares (token on spoke objects)
  const spokeResult = findSpokeByShareToken(GRAPH_DIR, shareId);
  if (spokeResult) {
    const { spoke, graphDir: spokeGraphDir, share } = spokeResult;
    const includes = share.includes || ['gaps', 'export', 'files'];

    // Build gap data if needed
    let gapData = null;
    if (includes.includes('gaps') && spoke.template_type) {
      try {
        if (spoke.gap_analysis) {
          gapData = spoke.gap_analysis;
        } else {
          gapData = await analyzeGaps(spoke.id, spokeGraphDir, spoke.template_type);
        }
      } catch {}
    }

    // Build export data if needed
    let exportData = null;
    if (includes.includes('export') && spoke.template_type) {
      try {
        exportData = buildSpokeExportData(spoke, spokeGraphDir);
      } catch {}
    }

    // Get files
    const files = (includes.includes('files') ? (spoke.files || []) : []);

    return res.send(renderSharedClientPortal(spoke, gapData, exportData, files, share));
  }

  // Phase 3: Not found
  res.status(404).send(renderSharedErrorPage(
    'Link Not Found',
    'This link is invalid or has been revoked. Please ask the owner for a new link.'
  ));
});

// Build 13: Client upload portal — unauthenticated file upload via share token
const sharedUpload = multer({ storage: multer.memoryStorage(), limits: { files: 20, fileSize: 50 * 1024 * 1024 } });
app.post('/shared/:token/upload', sharedViewLimiter, sharedUpload.array('files', 20), async (req, res) => {
  try {
    const spokeResult = findSpokeByShareToken(GRAPH_DIR, req.params.token);
    if (!spokeResult) return res.status(404).json({ error: 'Invalid or expired upload link' });

    const { spoke, graphDir: spokeGraphDir, share } = spokeResult;
    const includes = share.includes || [];
    if (!includes.includes('upload')) return res.status(403).json({ error: 'This link does not allow uploads' });

    const files = req.files || [];
    if (files.length === 0) return res.status(400).json({ error: 'No files provided' });

    // Validate extensions
    for (const file of files) {
      const ext = path.extname(file.originalname).toLowerCase();
      if (!ALLOWED_EXTENSIONS.has(ext)) {
        return res.status(400).json({ error: `Unsupported file type: ${ext}` });
      }
    }

    // Save file records to spoke and write buffer to spoke_files directory
    const spokeFilesDir = path.join(spokeGraphDir, 'spoke_files', spoke.id);
    if (!fs.existsSync(spokeFilesDir)) fs.mkdirSync(spokeFilesDir, { recursive: true });

    const processedFiles = [];
    for (const file of files) {
      const fileId = 'FILE-' + Date.now() + '-' + Math.random().toString(36).substr(2, 4);
      const ext = path.extname(file.originalname).toLowerCase();
      const savedName = fileId + ext;

      // Write file to disk
      fs.writeFileSync(path.join(spokeFilesDir, savedName), file.buffer);

      processedFiles.push({
        id: fileId,
        original_name: file.originalname,
        saved_name: savedName,
        mime_type: file.mimetype,
        size: file.size,
        uploaded_at: new Date().toISOString(),
        uploaded_via: 'client_portal',
        share_token: req.params.token,
        status: 'pending_review'
      });
    }

    // Update spoke with file records and activity log
    const existingFiles = spoke.files || [];
    const activity = spoke.recent_activity || [];
    activity.unshift({
      type: 'client_upload',
      description: files.length + ' file(s) uploaded via client portal: ' + files.map(f => f.originalname).join(', '),
      timestamp: new Date().toISOString(),
      uploaded_via: 'client_portal'
    });

    updateSpoke(spokeGraphDir, spoke.id, {
      files: existingFiles.concat(processedFiles),
      recent_activity: activity.slice(0, 50),
      gap_analysis: null  // Invalidate cached analysis so it re-runs
    });

    res.json({
      ok: true,
      files_processed: processedFiles.length,
      entities_created: 0,
      message: 'Files uploaded successfully. Your documents will be reviewed shortly.'
    });
  } catch (err) {
    res.status(500).json({ error: 'Upload failed: ' + err.message });
  }
});

const WIKI_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Architecture</title>
<style>
  :root {
    /* Backgrounds */
    --bg-primary: #f5f5f7;
    --bg-secondary: #ffffff;
    --bg-card: #ffffff;
    --bg-elevated: #ffffff;
    --bg-hover: rgba(99,102,241,0.05);
    --bg-active: rgba(99,102,241,0.08);
    --bg-input: #f5f5f7;
    --bg-tertiary: #eeeef0;

    /* Borders */
    --border-primary: #e5e5ea;
    --border-subtle: #f0f0f2;
    --border-focus: #6366f1;

    /* Text */
    --text-primary: #1a1a1a;
    --text-secondary: #4b5563;
    --text-tertiary: #6b7280;
    --text-muted: #9ca3af;
    --text-faint: #d1d5db;

    /* Accents */
    --accent-primary: #6366f1;
    --accent-secondary: #7c3aed;
    --accent-tertiary: #8b5cf6;
    --accent-light: #6366f1;
    --accent-gradient: linear-gradient(135deg, #6366f1, #8b5cf6);

    /* Status */
    --success: #059669;
    --success-bg: rgba(5,150,105,0.08);
    --warning: #d97706;
    --warning-bg: rgba(217,119,6,0.08);
    --error: #dc2626;
    --error-bg: rgba(220,38,38,0.06);
    --info: #2563eb;
    --info-bg: rgba(37,99,235,0.06);

    /* Layout */
    --sidebar-width: 380px;
    --radius-sm: 6px;
    --radius-md: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
    --shadow-md: 0 2px 8px rgba(0,0,0,0.06);
    --shadow-lg: 0 4px 16px rgba(0,0,0,0.08);

    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-normal: 0.2s ease;

    /* Typography */
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --font-mono: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font-sans);
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100vh;
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* --- Scrollbar --- */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

  /* --- Login --- */
  #login-screen {
    display: flex; align-items: center; justify-content: center;
    height: 100vh; flex-direction: column; gap: 20px;
    background: var(--bg-primary);
  }
  .login-card {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-xl);
    padding: 48px 40px;
    width: 400px;
    text-align: center;
    box-shadow: var(--shadow-lg);
  }
  .login-brand {
    display: flex; align-items: center; justify-content: center;
    gap: 10px; margin-bottom: 8px;
  }
  .login-card h1 { font-size: 1.6rem; font-weight: 700; margin-bottom: 4px; }
  .login-card h1 span {
    background: var(--accent-gradient);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .login-card .subtitle { color: var(--text-tertiary); font-size: 0.88rem; margin-bottom: 28px; }
  .login-card input {
    width: 100%; padding: 11px 14px;
    background: var(--bg-input);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-family: var(--font-mono);
    font-size: 0.88rem;
    outline: none; margin-bottom: 14px;
    transition: border-color var(--transition-fast);
  }
  .login-card input:focus { border-color: var(--border-focus); }
  .login-card input::placeholder { color: var(--text-muted); }
  .login-error { color: var(--error); font-size: 0.8rem; margin-bottom: 10px; display: none; }
  .login-error.active { display: block; }
  .btn {
    width: 100%; padding: 12px;
    border: none; border-radius: var(--radius-md);
    font-size: 0.92rem; font-weight: 600; cursor: pointer;
    background: var(--accent-gradient); color: white;
    transition: all var(--transition-normal);
    font-family: var(--font-sans);
  }
  .btn:hover { transform: translateY(-1px); box-shadow: 0 4px 20px rgba(99,102,241,0.3); }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
  .google-btn {
    display: flex; align-items: center; justify-content: center;
    background: #fff; color: #333; text-decoration: none; margin-bottom: 16px;
    font-size: 0.88rem; font-weight: 600;
    border: 1px solid var(--border-primary);
  }
  .google-btn:hover { background: #f9f9fb; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
  .login-divider {
    display: flex; align-items: center; margin-bottom: 14px;
    color: var(--text-muted); font-size: 0.72rem;
  }
  .login-divider::before, .login-divider::after {
    content: ''; flex: 1; border-bottom: 1px solid var(--border-primary);
  }
  .login-divider span { padding: 0 12px; }

  /* --- App Layout --- */
  #app { display: none; height: 100vh; }
  #sidebar {
    width: var(--sidebar-width); min-width: var(--sidebar-width);
    border: 0; outline: 0; box-shadow: none;
    display: flex; flex-direction: column;
    background: #fafafa;
  }

  /* --- Sidebar Brand --- */
  .sidebar-brand {
    display: flex; align-items: center; gap: 10px;
    padding: 18px 20px 16px;
    border-bottom: 1px solid var(--border-primary);
  }
  .brand-icon {
    width: 32px; height: 32px; border-radius: var(--radius-md);
    background: var(--accent-gradient);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.72rem; font-weight: 800; color: white;
    letter-spacing: -0.02em; flex-shrink: 0;
  }
  .brand-text {
    font-size: 0.88rem; font-weight: 700; color: var(--text-primary);
    letter-spacing: -0.01em;
  }

  /* --- Sidebar Utility Bar --- */
  .sidebar-utility-bar {
    display: flex; align-items: center; justify-content: center;
    gap: 4px; padding: 10px 16px;
    border-bottom: 1px solid var(--border-primary);
  }
  .sidebar-utility-link {
    display: flex; flex-direction: column; align-items: center;
    padding: 8px; border-radius: 8px; cursor: pointer;
    color: #666; font-size: 10px; gap: 3px;
    transition: background 0.15s;
  }
  .sidebar-utility-link:hover { background: #f0f0f0; }
  .sidebar-utility-link svg { width: 20px; height: 20px; }

  /* --- Sidebar Search (togglable) --- */
  .sidebar-search { padding: 12px 16px 8px; }
  .search-wrapper { position: relative; display: flex; align-items: center; }
  .search-icon {
    position: absolute; left: 10px;
    color: var(--text-muted); pointer-events: none;
  }
  #searchInput {
    width: 100%; padding: 8px 12px 8px 32px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 14px; outline: none;
    font-family: var(--font-sans);
    transition: border-color var(--transition-fast);
  }
  #searchInput:focus { border-color: var(--border-focus); }
  #searchInput::placeholder { color: var(--text-muted); }

  /* --- Flat Nav Styles --- */
  .sb-section-label {
    font-size: 12px; text-transform: uppercase; color: #999;
    letter-spacing: 0.5px; padding: 24px 16px 8px 16px;
    font-weight: 600;
  }
  .sb-nav-item {
    display: flex; align-items: center; padding: 8px 16px;
    cursor: pointer; color: #333; font-size: 14px;
    border-left: 3px solid transparent;
    transition: background 0.15s;
  }
  .sb-nav-item:hover { background: #f0f0f0; }
  .sb-nav-item.active {
    font-weight: 600; border-left-color: #0a66c2; color: #0a66c2;
  }
  .sb-nav-item svg {
    width: 16px; height: 16px; color: #666;
    margin-right: 8px; flex-shrink: 0;
  }
  .sb-nav-item.active svg { color: #0a66c2; }
  .sb-nav-item.add-item { color: #0a66c2; }
  .sb-see-more {
    padding: 6px 16px 6px 40px; font-size: 13px; color: #999;
    cursor: pointer; transition: color 0.15s;
  }
  .sb-see-more:hover { color: #333; }
  .sb-recent-item {
    display: flex; align-items: center; gap: 8px;
    padding: 6px 16px; cursor: pointer; font-size: 13px;
    transition: background 0.15s;
  }
  .sb-recent-item:hover { background: #f0f0f0; }
  .sb-recent-avatar {
    width: 24px; height: 24px; border-radius: 50%; flex-shrink: 0;
    background: #e0e0e0; font-size: 10px; font-weight: 600;
    display: flex; align-items: center; justify-content: center;
    color: #666;
  }

  /* --- Spoke Selector (legacy — hidden) --- */
  .spoke-selector-wrap { display: none; }

  /* --- Client List Items --- */
  .sb-client-item {
    display: flex; align-items: center; padding: 9px 16px;
    cursor: pointer; color: #333; font-size: 14px;
    border-left: 3px solid transparent;
    transition: background 0.15s, border-color 0.15s;
    gap: 8px;
  }
  .sb-client-item:hover { background: #f0f0f0; }
  .sb-client-item.active {
    font-weight: 600; border-left-color: #0a66c2; color: #0a66c2;
    background: rgba(10,102,194,0.04);
  }
  .sb-client-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .sb-client-meta {
    display: flex; align-items: center; gap: 6px; flex-shrink: 0;
  }
  .sb-client-count {
    font-size: 11px; color: var(--text-muted); font-weight: 400;
  }
  .sb-client-dot {
    width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
  }
  .sb-client-dot.red { background: #DC2626; }
  .sb-client-dot.yellow { background: #CA8A04; }
  .sb-client-dot.green { background: #16A34A; }
  .sb-client-dot.gray { background: #d1d5db; }

  /* --- Template List Items --- */
  .sb-template-item {
    display: flex; align-items: center; padding: 8px 16px;
    cursor: pointer; color: #555; font-size: 13px;
    border-left: 3px solid transparent;
    transition: background 0.15s;
    gap: 8px;
  }
  .sb-template-item:hover { background: #f0f0f0; }
  .sb-template-item.active {
    font-weight: 600; border-left-color: #7c3aed; color: #7c3aed;
  }
  .sb-template-item svg { width: 14px; height: 14px; color: #999; flex-shrink: 0; }
  .sb-template-item.active svg { color: #7c3aed; }

  /* --- Add Item Button (shared) --- */
  .sb-add-btn {
    display: flex; align-items: center; padding: 8px 16px;
    cursor: pointer; color: #0a66c2; font-size: 13px; font-weight: 500;
    gap: 6px; transition: background 0.15s;
  }
  .sb-add-btn:hover { background: rgba(10,102,194,0.06); }
  .sb-add-btn svg { width: 14px; height: 14px; }

  /* --- Context-Sensitive Right Panel (Build 8) --- */
  .rp-section-title {
    font-size: 13px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.6px; color: #555; margin-bottom: 14px;
    display: flex; align-items: center; gap: 8px;
  }
  .rp-review-item {
    background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;
    padding: 14px; margin-bottom: 10px;
    transition: border-color 0.15s;
  }
  .rp-review-item:hover { border-color: #0a66c2; }
  .rp-review-field {
    font-size: 14px; font-weight: 600; color: var(--text-primary);
    margin-bottom: 4px;
  }
  .rp-review-value {
    font-size: 15px; color: var(--text-primary); margin-bottom: 8px;
  }
  .rp-review-source {
    font-size: 11px; color: var(--text-muted); margin-bottom: 10px;
    display: flex; align-items: center; gap: 4px;
  }
  .rp-actions {
    display: flex; gap: 4px;
  }
  .rp-btn {
    padding: 5px 8px; border-radius: 6px; border: 1px solid #e0e0e0;
    font-size: 12px; font-weight: 600; cursor: pointer;
    transition: all 0.15s; background: #fff;
    min-width: 28px; text-align: center;
  }
  .rp-btn .rp-btn-label { display: none; }
  .rp-btn .rp-btn-icon { font-size: 14px; }
  .rp-btn.approve { color: #059669; border-color: #a7f3d0; }
  .rp-btn.approve:hover { background: #ecfdf5; border-color: #059669; }
  .rp-btn.reject { color: #dc2626; border-color: #fecaca; }
  .rp-btn.reject:hover { background: #fef2f2; border-color: #dc2626; }
  .rp-btn.edit { color: #0a66c2; border-color: #bfdbfe; }
  .rp-btn.edit:hover { background: #eff6ff; border-color: #0a66c2; }
  .rp-verified-item {
    display: flex; align-items: center; gap: 6px;
    padding: 6px 0; font-size: 12px; color: var(--text-muted);
    border-bottom: 1px solid #f0f0f0;
  }
  .rp-verified-item:last-child { border-bottom: none; }
  .rp-verified-check {
    color: #059669; font-size: 14px;
  }

  /* --- Build 9: Validation Backend styles --- */
  .rp-critical-badge {
    display: inline-block; font-size: 9px; font-weight: 700;
    color: #fff; background: #dc2626; border-radius: 3px;
    padding: 1px 5px; margin-left: 6px; letter-spacing: 0.5px;
    vertical-align: middle;
  }
  .rp-field-status.corrected {
    background: #dbeafe; color: #1d4ed8; border-color: #93c5fd;
  }
  .rp-field-status.rejected {
    background: #fef2f2; color: #dc2626; border-color: #fecaca;
  }
  .rp-progress-bar {
    background: #e5e7eb; border-radius: 6px; height: 8px;
    overflow: hidden; margin-bottom: 6px;
  }
  .rp-progress-fill {
    height: 100%; border-radius: 6px;
    background: linear-gradient(90deg, #059669, #10b981);
    transition: width 0.4s ease;
  }
  .rp-progress-summary {
    font-size: 11px; color: var(--text-muted); margin-bottom: 16px;
    line-height: 1.5;
  }
  .rp-flagged-item {
    background: #fff; border: 1px solid #fecaca; border-radius: 8px;
    padding: 12px; margin-bottom: 8px; border-left: 3px solid #dc2626;
  }
  .rp-flagged-item .rp-review-field { color: #991b1b; }
  .rp-corrected-item {
    background: #fff; border: 1px solid #93c5fd; border-radius: 8px;
    padding: 12px; margin-bottom: 8px; border-left: 3px solid #1d4ed8;
  }
  .rp-corrected-item .rp-review-field { color: #1e40af; }
  .rp-bulk-approve {
    display: block; width: 100%; padding: 10px 16px;
    background: #059669; color: #fff; border: none; border-radius: 8px;
    font-size: 13px; font-weight: 600; cursor: pointer;
    margin-bottom: 16px; transition: background 0.15s;
  }
  .rp-bulk-approve:hover { background: #047857; }
  .rp-bulk-approve:disabled { background: #9ca3af; cursor: not-allowed; }
  .rp-modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5); z-index: 1000;
    display: flex; align-items: center; justify-content: center;
  }
  .rp-modal {
    background: #fff; border-radius: 12px; padding: 28px;
    max-width: 420px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.2);
  }
  .rp-modal h3 { margin: 0 0 12px; font-size: 18px; }
  .rp-modal p { margin: 0 0 20px; font-size: 14px; color: #555; line-height: 1.5; }
  .rp-modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
  .rp-modal-actions button {
    padding: 8px 20px; border-radius: 8px; font-size: 13px;
    font-weight: 600; cursor: pointer; border: 1px solid #e0e0e0;
    transition: all 0.15s;
  }
  .rp-modal-actions .confirm {
    background: #059669; color: #fff; border-color: #059669;
  }
  .rp-modal-actions .confirm:hover { background: #047857; }
  .rp-modal-actions .cancel { background: #fff; color: #555; }
  .rp-modal-actions .cancel:hover { background: #f5f5f5; }
  .rp-spoke-progress {
    background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;
    padding: 12px 16px; margin-bottom: 16px;
  }
  .rp-spoke-progress .rp-progress-bar { margin-bottom: 4px; }

  /* Field Detail */
  .rp-field-detail { padding: 0; }
  .rp-field-header {
    font-size: 13px; font-weight: 600; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.5px;
    margin-bottom: 8px;
  }
  .rp-field-value {
    font-size: 22px; font-weight: 700; color: var(--text-primary);
    margin-bottom: 16px; word-break: break-word;
  }
  .rp-field-status {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: 600;
    margin-bottom: 16px;
  }
  .rp-field-status.verified { background: #ecfdf5; color: #065f46; }
  .rp-field-status.low_confidence { background: #fefce8; color: #854d0e; }
  .rp-field-status.conflict { background: #fef2f2; color: #991b1b; }
  .rp-field-status.missing { background: #f3f4f6; color: #6b7280; }
  .rp-evidence {
    background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;
    padding: 14px; margin-bottom: 16px;
    border-left: 3px solid #0a66c2;
  }
  .rp-evidence-label {
    font-size: 11px; font-weight: 600; text-transform: uppercase;
    color: var(--text-muted); margin-bottom: 8px; letter-spacing: 0.4px;
  }
  .rp-evidence-snippet {
    font-size: 13px; color: var(--text-secondary); line-height: 1.5;
    font-style: italic;
  }
  .rp-evidence-file {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; color: var(--text-muted); margin-top: 10px;
  }

  /* Edit inline */
  .rp-edit-input {
    width: 100%; padding: 8px 12px; border: 1px solid #0a66c2;
    border-radius: 8px; font-size: 15px; margin-bottom: 10px;
    outline: none; background: #fff;
  }

  /* --- Client Breadcrumb Nav (Build 8.1) --- */
  .client-breadcrumb {
    display: flex; align-items: center; gap: 0;
    padding: 10px 28px 0; background: #fff;
    font-size: 14px;
  }
  .client-breadcrumb a {
    color: #9ca3af; text-decoration: none; cursor: pointer;
    transition: color 0.15s;
  }
  .client-breadcrumb a:hover { color: #6366f1; }
  .client-breadcrumb .cb-sep {
    color: #d1d5db; margin: 0 8px; font-size: 12px;
  }
  .client-breadcrumb .cb-current {
    color: var(--text-primary); font-weight: 600;
  }

  /* --- Client Workspace Tab Bar (Build 8) --- */
  .client-tab-bar {
    display: flex; gap: 0; border-bottom: 2px solid #e8e8e8;
    padding: 0 28px; background: #fff;
    position: sticky; top: 0; z-index: 5;
  }
  .client-tab {
    display: flex; align-items: center; gap: 6px;
    padding: 14px 18px 12px; cursor: pointer;
    font-size: 14px; font-weight: 500; color: var(--text-muted);
    border-bottom: 2px solid transparent;
    margin-bottom: -2px; transition: all 0.15s;
    white-space: nowrap;
  }
  .client-tab:hover { color: var(--text-primary); }
  .client-tab.active {
    color: #0a66c2; font-weight: 600;
    border-bottom-color: #0a66c2;
  }
  .client-tab svg { width: 16px; height: 16px; }
  .client-tab.active svg { color: #0a66c2; }

  /* --- Sidebar Bottom --- */
  .sidebar-bottom {
    margin-top: auto; padding: 12px 16px;
    border-top: 1px solid var(--border-primary);
    display: flex; align-items: center; gap: 8px;
  }
  .sidebar-bottom-avatar {
    width: 28px; height: 28px; border-radius: 50%;
    background: var(--accent-gradient);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.55rem; font-weight: 700; color: white; flex-shrink: 0;
    overflow: hidden;
  }
  .sidebar-bottom-avatar img { width: 100%; height: 100%; object-fit: cover; }
  .sidebar-bottom-name { font-size: 13px; font-weight: 600; flex: 1; }
  .sidebar-bottom-actions { display: flex; gap: 8px; align-items: center; }
  .sidebar-bottom-actions a {
    color: #999; font-size: 12px; text-decoration: none;
    transition: color 0.15s;
  }
  .sidebar-bottom-actions a:hover { color: var(--accent-tertiary); }

  /* --- Entity List --- */
  #entityList { flex: 1; overflow-y: auto; }
  .entity-item {
    padding: 12px 20px; cursor: pointer;
    border-bottom: 1px solid var(--border-subtle);
    transition: all var(--transition-fast);
  }
  .entity-item:hover { background: var(--bg-hover); }
  .entity-item.active {
    background: var(--bg-active);
    border-left: 3px solid var(--accent-primary);
    padding-left: 17px;
  }
  .entity-item-name {
    font-size: 0.85rem; font-weight: 600;
    color: var(--text-primary); margin-bottom: 2px;
  }
  .entity-item-summary {
    font-size: 0.72rem; color: var(--text-muted); line-height: 1.4;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    margin-top: 3px;
  }
  .type-badge {
    display: inline-block; font-size: 0.6rem; font-weight: 600;
    padding: 2px 7px; border-radius: var(--radius-sm);
    text-transform: uppercase; letter-spacing: 0.04em;
    vertical-align: middle; margin-left: 6px;
  }
  .type-badge.person { background: rgba(99,102,241,0.1); color: #6366f1; }
  .type-badge.business { background: rgba(14,165,233,0.1); color: #0284c7; }
  .type-badge.role { background: rgba(59,130,246,0.1); color: #2563eb; }
  .type-badge.organization { background: rgba(34,197,94,0.1); color: #16a34a; }
  .type-badge.credential { background: rgba(245,158,11,0.1); color: #d97706; }
  .type-badge.skill { background: rgba(20,184,166,0.1); color: #0d9488; }
  .type-badge.institution { background: rgba(168,85,247,0.1); color: #7c3aed; }

  /* --- Main Panel --- */
  #main {
    flex: 1; overflow-y: auto;
    padding: 32px 40px;
    background: #ffffff;
    border: 0; outline: 0;
    min-width: 0;
  }
  .empty-state {
    display: flex; align-items: center; justify-content: center;
    height: 100%; color: var(--text-faint);
    font-size: 0.95rem; text-align: center;
    line-height: 1.8; flex-direction: column; gap: 12px;
  }

  /* --- Right Entity Pipeline Panel --- */
  #rightPanel {
    width: 280px; min-width: 280px;
    border: 0; outline: 0; box-shadow: none;
    background: #f4f2ee;
    overflow-y: auto;
    display: flex; flex-direction: column;
    height: 100vh;
    position: relative;
    transition: width 0.2s ease, min-width 0.2s ease, opacity 0.2s ease;
  }
  #rightPanel.collapsed { width: 0; min-width: 0; overflow: hidden; opacity: 0; padding: 0; }
  #rightPanel.hidden { display: none; }
  #rightPanelContent { padding: 36px 12px 24px; }
  .rp-collapse-toggle {
    position: absolute; top: 10px; left: -14px; z-index: 10;
    width: 28px; height: 28px; border-radius: 50%;
    border: 1px solid #e0e0e0; background: #fff;
    cursor: pointer; font-size: 13px; color: #666;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    transition: transform 0.2s ease;
  }
  .rp-collapse-toggle:hover { background: #f5f5f5; color: #333; }
  #rightPanel.collapsed .rp-collapse-toggle { left: -32px; transform: rotate(180deg); }
  #rightPanelToggle {
    display: none; position: fixed; right: 16px; top: 16px; z-index: 100;
    width: 36px; height: 36px; border-radius: 8px; border: 1px solid #e0e0e0;
    background: #fff; cursor: pointer; font-size: 16px; color: #666;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  }
  #rightPanelToggle:hover { background: #f5f5f5; }
  @media (max-width: 1200px) {
    #rightPanel { display: none; }
    #rightPanel.force-show { display: flex; position: fixed; right: 0; top: 0; bottom: 0; z-index: 99; box-shadow: -4px 0 16px rgba(0,0,0,0.1); width: 280px; }
    #rightPanelToggle { display: block; }
  }

  /* Pipeline sections — separate cards */
  .pp-section {
    background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;
    margin-bottom: 16px; overflow: hidden;
  }
  .pp-section:last-child { margin-bottom: 0; }
  .pp-accent { height: 3px; border-radius: 8px 8px 0 0; }
  .pp-accent.collect { background: linear-gradient(90deg, #667eea, #764ba2); }
  .pp-accent.review { background: linear-gradient(90deg, #f59e0b, #ef6c00); }
  .pp-accent.confirm { background: linear-gradient(90deg, #10b981, #059669); }
  .pp-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 20px 28px; cursor: pointer; user-select: none;
  }
  .pp-header-left { display: flex; align-items: center; gap: 8px; }
  .pp-header-icon { font-size: 16px; line-height: 1; }
  .pp-header-title {
    font-size: 17px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .pp-section.collect .pp-header-title { color: #5b21b6; }
  .pp-section.review .pp-header-title { color: #d97706; }
  .pp-section.confirm .pp-header-title { color: #059669; }
  .pp-badge {
    min-width: 22px; height: 22px; border-radius: 11px;
    display: inline-flex; align-items: center; justify-content: center;
    font-size: 12px; font-weight: 700; color: #fff; padding: 0 6px;
  }
  .pp-section.collect .pp-badge { background: #7c3aed; }
  .pp-section.review .pp-badge { background: #f59e0b; }
  .pp-section.confirm .pp-badge { background: #10b981; }
  .pp-chevron { font-size: 12px; color: #999; transition: transform 0.15s; margin-left: 6px; }
  .pp-chevron.collapsed { transform: rotate(-90deg); }
  .pp-body { padding: 0 28px 28px; font-size: 15px; color: #333; line-height: 1.5; }
  .pp-body.collapsed { display: none; }

  /* Collect section */
  .pp-dropzone {
    border: 2px dashed #d0d0d0; border-radius: 8px; padding: 28px;
    text-align: center; font-size: 15px; color: #999; cursor: pointer;
    transition: border-color 0.15s, background 0.15s;
    min-height: 160px; display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 6px;
  }
  .pp-dropzone:hover, .pp-dropzone.dragover { border-color: #7c3aed; background: #f5f3ff; color: #7c3aed; }
  .pp-dropzone .pp-drop-icon { font-size: 32px; color: #ccc; margin-bottom: 4px; }
  .pp-dropzone .pp-drop-sub { font-size: 13px; color: #bbb; }
  .pp-files-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-top: 16px; padding-bottom: 8px; border-bottom: 1px solid #eee;
  }
  .pp-files-title { font-size: 14px; font-weight: 600; color: #333; }
  .pp-files-add {
    width: 24px; height: 24px; border-radius: 6px; border: 1px solid #ddd;
    background: #fff; cursor: pointer; font-size: 16px; color: #999;
    display: flex; align-items: center; justify-content: center;
  }
  .pp-files-add:hover { background: #f5f5f5; color: #333; }
  .pp-files-empty { font-size: 14px; color: #999; padding: 12px 0; }
  .pp-url-row { display: flex; gap: 8px; margin-top: 14px; }
  .pp-url-input {
    flex: 3; padding: 10px 12px; font-size: 15px; border: 1px solid #ddd;
    border-radius: 6px; outline: none; min-width: 0;
  }
  .pp-url-input:focus { border-color: #7c3aed; }
  .pp-url-btn {
    flex: 1; padding: 10px 14px; font-size: 14px; font-weight: 600;
    background: #7c3aed; color: #fff; border: none; border-radius: 6px;
    cursor: pointer; white-space: nowrap;
  }
  .pp-url-btn:hover { background: #6d28d9; }
  .pp-url-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .pp-quick-actions {
    display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;
  }
  .pp-quick-btn {
    display: flex; align-items: center; gap: 4px; padding: 8px 12px;
    font-size: 14px; color: #666; background: #f0f0f0; border: 1px solid #e0e0e0;
    border-radius: 6px; cursor: pointer;
  }
  .pp-quick-btn:hover { background: #e5e5e5; color: #333; }
  .pp-quick-btn svg { width: 14px; height: 14px; }
  .pp-monitor {
    display: flex; align-items: center; justify-content: space-between;
    margin-top: 12px; padding: 10px 12px; background: #f0f0f0; border-radius: 6px;
    font-size: 15px; color: #666;
  }
  .pp-toggle {
    width: 32px; height: 18px; border-radius: 9px; background: #ccc;
    position: relative; cursor: pointer; transition: background 0.2s;
  }
  .pp-toggle::after {
    content: ''; position: absolute; top: 2px; left: 2px;
    width: 14px; height: 14px; border-radius: 50%; background: #fff;
    transition: transform 0.2s;
  }
  .pp-toggle.on { background: #7c3aed; }
  .pp-toggle.on::after { transform: translateX(14px); }

  /* Review section */
  .pp-cluster-card {
    padding: 14px; margin-bottom: 8px; background: #fff;
    border: 1px solid #e0e0e0; border-radius: 8px; font-size: 15px;
  }
  .pp-cluster-top { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .pp-cluster-icon { font-size: 15px; flex-shrink: 0; }
  .pp-cluster-name { flex: 1; font-weight: 600; color: #333; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 15px; }
  .pp-cluster-quadrant {
    font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px;
    text-transform: uppercase; flex-shrink: 0;
  }
  .pp-cluster-quadrant.q1 { background: #dbeafe; color: #1d4ed8; }
  .pp-cluster-quadrant.q2 { background: #fef3c7; color: #d97706; }
  .pp-cluster-quadrant.q3 { background: #e0e7ff; color: #4338ca; }
  .pp-cluster-quadrant.q4 { background: #d1fae5; color: #059669; }
  .pp-conf-bar { height: 4px; background: #eee; border-radius: 2px; margin: 6px 0; }
  .pp-conf-fill { height: 100%; border-radius: 2px; background: #f59e0b; }
  .pp-evidence { margin: 6px 0; }
  .pp-evidence-item { font-size: 14px; padding: 2px 0; }
  .pp-evidence-item.match { color: #059669; }
  .pp-evidence-item.conflict { color: #dc2626; }
  .pp-evidence-item.partial { color: #d97706; }
  .pp-cluster-actions { display: flex; gap: 6px; margin-top: 8px; }
  .pp-btn-accept {
    flex: 1; padding: 8px 12px; font-size: 14px; font-weight: 600;
    background: #10b981; color: #fff; border: none; border-radius: 6px; cursor: pointer;
  }
  .pp-btn-accept:hover { background: #059669; }
  .pp-btn-reject {
    flex: 1; padding: 8px 12px; font-size: 14px; font-weight: 600;
    background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer;
  }
  .pp-btn-reject:hover { background: #eee; }
  .pp-btn-accept-all {
    width: 100%; padding: 10px; font-size: 14px; font-weight: 600;
    background: #10b981; color: #fff; border: none; border-radius: 6px;
    cursor: pointer; margin-bottom: 8px;
  }
  .pp-btn-accept-all:hover { background: #059669; }
  .pp-low-conf {
    font-size: 14px; color: #666; padding: 6px 0; border-top: 1px solid #e0e0e0; margin-top: 8px;
  }
  .pp-low-conf-item { display: flex; align-items: center; justify-content: space-between; padding: 3px 0; }
  .pp-btn-enrich {
    font-size: 13px; padding: 4px 10px; background: #fef3c7; color: #d97706;
    border: none; border-radius: 4px; cursor: pointer; font-weight: 600;
  }
  .pp-btn-enrich:hover { background: #fde68a; }

  /* Confirm section */
  .pp-confirm-card {
    padding: 14px; margin-bottom: 8px; background: #f0fdf4;
    border: 1px solid #d1fae5; border-radius: 8px; font-size: 15px;
  }
  .pp-confirm-summary { color: #333; margin-bottom: 6px; font-size: 15px; }
  .pp-confirm-health { font-size: 14px; color: #059669; }
  .pp-recent { margin-top: 12px; border-top: 1px solid #e0e0e0; padding-top: 10px; }
  .pp-recent-title { font-size: 13px; color: #999; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.3px; }
  .pp-recent-item { font-size: 14px; color: #666; padding: 3px 0; }

  /* Empty states */
  .pp-empty { text-align: center; font-size: 15px; color: #999; padding: 20px 0; }
  .pp-empty-check { color: #10b981; font-size: 18px; display: block; margin-bottom: 4px; }

  /* File input hidden */
  #rpFileInput { display: none; }

  /* --- Detail Header --- */
  .detail-header { margin-bottom: 28px; }
  .detail-header h2 {
    font-size: 1.6rem; font-weight: 700; color: var(--text-primary);
    display: inline; letter-spacing: -0.02em;
  }
  .entity-id-badge {
    font-size: 0.68rem; color: var(--accent-primary);
    font-family: var(--font-mono);
    background: rgba(99,102,241,0.08);
    padding: 3px 10px; border-radius: var(--radius-sm);
    margin-left: 10px; vertical-align: middle;
  }

  .btn-delete-entity {
    margin-left: 12px; vertical-align: middle;
    padding: 3px 12px; border-radius: var(--radius-sm);
    background: rgba(239,68,68,0.1); color: #ef4444;
    border: 1px solid rgba(239,68,68,0.3);
    font-size: 0.72rem; font-weight: 600; cursor: pointer;
    transition: all 0.15s;
  }
  .btn-delete-entity:hover { background: #ef4444; color: #fff; }

  /* --- Cleanup View --- */
  .cleanup-toolbar {
    display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    padding: 12px 16px; margin-bottom: 16px;
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg); box-shadow: var(--shadow-sm);
  }
  .cleanup-toolbar select, .cleanup-toolbar input {
    padding: 6px 10px; border-radius: var(--radius-sm);
    border: 1px solid var(--border-primary); background: var(--bg-primary);
    color: var(--text-primary); font-size: 0.8rem; font-family: var(--font-sans);
  }
  .cleanup-toolbar label { font-size: 0.78rem; color: var(--text-secondary); font-weight: 500; }
  .cleanup-row {
    display: flex; align-items: center; gap: 12px;
    padding: 10px 16px; border-bottom: 1px solid var(--border-subtle);
    transition: background var(--transition-fast);
  }
  .cleanup-row:hover { background: var(--bg-hover); }
  .cleanup-check { accent-color: var(--accent-primary); width: 16px; height: 16px; cursor: pointer; }
  .cleanup-name { flex: 1; font-size: 0.85rem; font-weight: 500; color: var(--text-primary); }
  .cleanup-type-badge {
    font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.05em;
    padding: 2px 8px; border-radius: 9999px; font-weight: 600;
    background: rgba(99,102,241,0.1); color: var(--accent-primary);
  }
  .cleanup-count { font-size: 0.72rem; color: var(--text-muted); min-width: 50px; text-align: right; }
  .cleanup-actions {
    position: sticky; bottom: 0; display: flex; align-items: center; gap: 12px;
    padding: 12px 16px; margin-top: 12px;
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg); box-shadow: var(--shadow-sm);
  }
  .cleanup-actions .btn-danger {
    padding: 8px 20px; border-radius: var(--radius-sm);
    background: #ef4444; color: #fff; border: none;
    font-size: 0.82rem; font-weight: 600; cursor: pointer;
    transition: background 0.15s;
  }
  .cleanup-actions .btn-danger:hover { background: #dc2626; }
  .cleanup-actions .btn-danger:disabled { opacity: 0.4; cursor: not-allowed; }
  .cleanup-actions .cleanup-selection-count { font-size: 0.78rem; color: var(--text-secondary); }
  .cleanup-entity-list {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg); overflow: hidden;
  }

  /* --- Sections --- */
  .section {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    padding: 20px; margin-bottom: 16px;
    transition: border-color var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  .section:hover { border-color: #d1d5db; }
  .section-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 12px;
  }
  .section-title {
    font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.08em; color: var(--text-muted);
  }
  .section-title-only { margin-bottom: 12px; }
  .summary-text { font-size: 0.9rem; color: var(--text-secondary); line-height: 1.7; }
  .summary-edit {
    width: 100%; min-height: 70px; padding: 10px;
    background: var(--bg-input);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-family: var(--font-sans);
    font-size: 0.88rem; line-height: 1.6;
    resize: vertical; outline: none;
  }
  .summary-edit:focus { border-color: var(--border-focus); }
  .edit-actions { margin-top: 8px; display: flex; gap: 8px; }

  /* --- Attributes, Relationships, Values --- */
  .attr-row, .rel-row, .value-item {
    display: flex; align-items: flex-start; gap: 10px;
    padding: 8px 0; font-size: 0.84rem; flex-wrap: wrap;
    border-bottom: 1px solid var(--border-subtle);
  }
  .attr-row:last-child, .rel-row:last-child, .value-item:last-child { border-bottom: none; }
  .attr-key {
    color: var(--accent-secondary); font-weight: 600;
    min-width: 90px; flex-shrink: 0; font-size: 0.82rem;
  }
  .attr-value { color: var(--text-primary); flex: 1; }
  .rel-name { color: var(--text-primary); font-weight: 600; min-width: 110px; }
  .rel-type {
    color: var(--info); font-size: 0.72rem;
    background: var(--info-bg);
    padding: 2px 8px; border-radius: var(--radius-sm);
  }
  .rel-context { color: var(--text-tertiary); font-size: 0.78rem; flex: 1; }
  .rel-sentiment {
    font-size: 0.65rem; padding: 2px 8px; border-radius: var(--radius-sm);
  }
  .sentiment-positive { background: var(--success-bg); color: var(--success); }
  .sentiment-neutral { background: rgba(107,114,128,0.08); color: var(--text-secondary); }
  .sentiment-strained { background: var(--error-bg); color: var(--error); }
  .value-text { color: var(--text-primary); }

  /* --- Badges --- */
  .badge {
    display: inline-block; font-size: 0.6rem; font-weight: 600;
    padding: 2px 7px; border-radius: var(--radius-sm);
    text-transform: uppercase; letter-spacing: 0.04em;
    white-space: nowrap; vertical-align: middle;
  }
  .badge-verified { background: rgba(5,150,105,0.1); color: #059669; }
  .badge-strong { background: rgba(37,99,235,0.1); color: #2563eb; }
  .badge-moderate { background: rgba(217,119,6,0.1); color: #d97706; }
  .badge-speculative { background: rgba(234,88,12,0.1); color: #ea580c; }
  .badge-uncertain { background: rgba(220,38,38,0.1); color: #dc2626; }
  .badge-layer {
    font-size: 0.58rem; padding: 2px 6px; border-radius: var(--radius-sm);
  }
  .badge-layer-1 { background: rgba(5,150,105,0.08); color: #059669; }
  .badge-layer-2 { background: rgba(37,99,235,0.08); color: #2563eb; }
  .badge-layer-3 { background: rgba(219,39,119,0.08); color: #db2777; }

  /* --- Observations --- */
  .obs-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: 12px 14px; margin-bottom: 8px;
    transition: all var(--transition-fast);
  }
  .obs-card:hover { border-color: var(--border-primary); }
  .obs-text { font-size: 0.86rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 8px; }
  .obs-meta {
    display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    font-size: 0.7rem;
  }
  .obs-source {
    color: var(--text-muted); font-family: var(--font-mono);
    font-size: 0.65rem;
  }
  .obs-date { color: var(--text-muted); font-size: 0.65rem; }
  .obs-decay {
    font-size: 0.6rem; color: var(--text-muted);
    font-family: var(--font-mono);
  }
  .btn-delete {
    background: none; border: 1px solid rgba(239,68,68,0.15);
    color: var(--error);
    font-size: 0.6rem; padding: 2px 8px; border-radius: var(--radius-sm);
    cursor: pointer; margin-left: auto; opacity: 0.4;
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .btn-delete:hover { opacity: 1; background: var(--error-bg); }

  /* --- Forms --- */
  .add-obs-form { margin-top: 12px; }
  .obs-textarea {
    width: 100%; min-height: 60px; padding: 12px;
    background: var(--bg-input);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-family: var(--font-sans);
    font-size: 0.86rem; line-height: 1.5;
    resize: vertical; outline: none; margin-bottom: 10px;
    transition: border-color var(--transition-fast);
  }
  .obs-textarea:focus { border-color: var(--border-focus); }
  .obs-textarea::placeholder { color: var(--text-muted); }
  .obs-form-row { display: flex; gap: 8px; align-items: center; }
  .obs-form-row select {
    padding: 7px 10px;
    background: var(--bg-input);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 0.78rem; outline: none;
    font-family: var(--font-sans);
    transition: border-color var(--transition-fast);
  }
  .obs-form-row select:focus { border-color: var(--border-focus); }
  .btn-sm {
    padding: 5px 14px;
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    background: transparent; color: var(--text-tertiary);
    font-size: 0.72rem; cursor: pointer;
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .btn-sm:hover { border-color: var(--accent-primary); color: var(--accent-tertiary); }
  .btn-add {
    padding: 7px 18px; border: none; border-radius: var(--radius-sm);
    background: var(--accent-gradient); color: white;
    font-size: 0.78rem; font-weight: 600; cursor: pointer;
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .btn-add:hover { transform: translateY(-1px); box-shadow: 0 2px 12px rgba(99,102,241,0.3); }
  .btn-add:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
  .btn-save {
    padding: 5px 16px; border: none; border-radius: var(--radius-sm);
    background: var(--success); color: #fff;
    font-size: 0.72rem; font-weight: 600; cursor: pointer;
    font-family: var(--font-sans);
  }
  .btn-cancel {
    padding: 5px 16px;
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    background: transparent; color: var(--text-tertiary);
    font-size: 0.72rem; cursor: pointer; font-family: var(--font-sans);
  }
  .toast {
    position: fixed; bottom: 24px; right: 24px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: 12px 20px; font-size: 0.82rem;
    color: var(--success);
    display: none; z-index: 100;
    box-shadow: var(--shadow-lg);
    animation: slideUp 0.25s ease;
  }
  .toast.active { display: block; }
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  /* --- Upload Zone --- */
  .upload-view { display: none; }
  .upload-view.active { display: block; animation: fadeIn 0.2s ease; }
  .upload-dropzone {
    border: 2px dashed var(--border-primary);
    border-radius: var(--radius-xl);
    padding: 56px 24px;
    text-align: center; cursor: pointer;
    transition: all var(--transition-normal);
    background: var(--bg-secondary); margin-bottom: 20px;
  }
  .upload-dropzone:hover, .upload-dropzone.dragover {
    border-color: var(--accent-primary);
    background: var(--bg-hover);
  }
  .upload-dropzone-icon { font-size: 2.5rem; margin-bottom: 12px; opacity: 0.3; }
  .upload-dropzone-text { font-size: 0.92rem; color: var(--text-tertiary); margin-bottom: 6px; }
  .upload-dropzone-hint { font-size: 0.72rem; color: var(--text-muted); }
  .upload-file-list { margin-bottom: 16px; }
  .upload-file-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 14px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    margin-bottom: 6px; font-size: 0.82rem;
    transition: border-color var(--transition-fast);
  }
  .upload-file-item:hover { border-color: rgba(30,30,46,0.8); }
  .upload-file-name {
    color: var(--text-primary); flex: 1;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .upload-file-size { color: var(--text-muted); font-size: 0.72rem; margin-left: 10px; flex-shrink: 0; }
  .upload-file-status { margin-left: 10px; font-size: 0.72rem; flex-shrink: 0; font-weight: 500; }
  .upload-file-status.pending { color: var(--text-muted); }
  .upload-file-status.processing { color: var(--warning); }
  .upload-file-status.done { color: var(--success); }
  .upload-file-status.error { color: var(--error); }
  .upload-file-remove {
    margin-left: 10px; background: none; border: none;
    color: var(--text-muted); cursor: pointer; font-size: 1rem;
    padding: 0 4px; transition: color var(--transition-fast);
  }
  .upload-file-remove:hover { color: var(--error); }
  .btn-start-upload {
    width: 100%; padding: 11px; border: none; border-radius: var(--radius-md);
    font-size: 0.88rem; font-weight: 600; cursor: pointer;
    background: var(--accent-gradient); color: white;
    transition: all var(--transition-normal); margin-bottom: 8px;
    font-family: var(--font-sans);
  }
  .btn-start-upload:hover { transform: translateY(-1px); box-shadow: 0 4px 20px rgba(99,102,241,0.3); }
  .btn-start-upload:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
  .btn-back-upload {
    width: 100%; padding: 9px;
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    font-size: 0.82rem; font-weight: 500; cursor: pointer;
    background: transparent; color: var(--text-tertiary);
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .btn-back-upload:hover { border-color: var(--accent-primary); color: var(--accent-tertiary); }
  .upload-progress-log {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: 14px; margin-bottom: 16px;
    max-height: 220px; overflow-y: auto;
    font-family: var(--font-mono); font-size: 0.72rem;
    line-height: 1.8; color: var(--text-tertiary);
  }
  .upload-progress-log .log-success { color: var(--success); }
  .upload-progress-log .log-info { color: var(--info); }
  .upload-progress-log .log-error { color: var(--error); }
  .upload-summary {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    padding: 20px; text-align: center; margin-bottom: 16px;
  }
  .upload-summary-stat {
    display: inline-block; margin: 0 20px; text-align: center;
  }
  .upload-summary-num {
    font-size: 1.8rem; font-weight: 700; color: var(--accent-tertiary);
    letter-spacing: -0.02em;
  }
  .upload-summary-label {
    font-size: 0.68rem; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.06em; margin-top: 2px;
  }

  /* --- Drive Picker --- */
  .drive-breadcrumb {
    display: flex; align-items: center; flex-wrap: wrap; gap: 4px;
    margin-bottom: 12px; font-size: 0.78rem;
  }
  .drive-breadcrumb a {
    color: var(--info); text-decoration: none; cursor: pointer;
  }
  .drive-breadcrumb a:hover { text-decoration: underline; }
  .drive-breadcrumb .sep { color: var(--text-muted); }
  .drive-breadcrumb .current { color: var(--text-primary); font-weight: 600; }
  .drive-file-list {
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    overflow: hidden; margin-bottom: 16px;
  }
  .drive-file-row {
    display: flex; align-items: center; padding: 10px 14px;
    border-bottom: 1px solid var(--border-subtle); font-size: 0.82rem;
    transition: background var(--transition-fast); cursor: pointer;
  }
  .drive-file-row:last-child { border-bottom: none; }
  .drive-file-row:hover { background: var(--bg-hover); }
  .drive-file-row.selected { background: var(--bg-active); }
  .drive-file-check {
    width: 16px; height: 16px; margin-right: 10px;
    accent-color: var(--accent-primary); flex-shrink: 0;
  }
  .drive-file-icon {
    width: 20px; text-align: center; margin-right: 10px;
    flex-shrink: 0; font-size: 0.9rem;
  }
  .drive-file-name {
    flex: 1; color: var(--text-primary);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .drive-file-name.folder { color: var(--info); font-weight: 500; }
  .drive-file-meta {
    font-size: 0.68rem; color: var(--text-muted);
    margin-left: 12px; flex-shrink: 0; white-space: nowrap;
  }
  .drive-select-bar {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 12px; font-size: 0.78rem; color: var(--text-tertiary);
  }
  .drive-loading {
    text-align: center; padding: 40px; color: var(--text-muted); font-size: 0.85rem;
  }
  .drive-empty {
    text-align: center; padding: 28px; color: var(--text-muted); font-size: 0.82rem;
  }
  .drive-search-bar {
    display: flex; align-items: center; gap: 6px; margin-bottom: 12px;
  }
  .drive-search-bar input {
    flex: 1; padding: 8px 12px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 0.82rem; outline: none;
    font-family: var(--font-sans);
    transition: border-color var(--transition-fast);
  }
  .drive-search-bar input:focus { border-color: var(--border-focus); }
  .drive-search-bar input::placeholder { color: var(--text-muted); }
  .drive-search-btn {
    padding: 8px 12px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-tertiary); cursor: pointer; font-size: 0.82rem;
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .drive-search-btn:hover { border-color: var(--accent-primary); color: var(--accent-tertiary); }
  .drive-search-clear {
    padding: 8px 12px; background: transparent;
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm);
    color: var(--text-tertiary); cursor: pointer; font-size: 0.75rem;
    transition: all var(--transition-fast); font-family: var(--font-sans);
  }
  .drive-search-clear:hover { border-color: var(--error); color: var(--error); }
  .drive-search-tag {
    display: inline-block; font-size: 0.72rem; color: var(--info); margin-bottom: 8px;
  }

  /* --- Career Profile --- */
  .cl-header {
    display: flex; gap: 20px; align-items: flex-start; margin-bottom: 6px;
  }
  .cl-avatar {
    width: 72px; height: 72px; border-radius: 50%;
    background: var(--accent-gradient);
    display: flex; align-items: center; justify-content: center;
    font-size: 1.6rem; font-weight: 700; color: white; flex-shrink: 0;
    box-shadow: 0 4px 16px rgba(99,102,241,0.25);
  }
  .cl-header-info { flex: 1; min-width: 0; }
  .cl-name {
    font-size: 1.5rem; font-weight: 700; color: var(--text-primary);
    margin-bottom: 4px; letter-spacing: -0.02em;
  }
  .cl-headline { font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 4px; }
  .cl-current { font-size: 0.84rem; color: var(--accent-tertiary); margin-bottom: 4px; }
  .cl-location { font-size: 0.78rem; color: var(--text-tertiary); }
  .cl-contact-row {
    display: flex; gap: 14px; flex-wrap: wrap; margin-top: 10px; font-size: 0.78rem;
  }
  .cl-contact-row a { color: var(--info); text-decoration: none; }
  .cl-contact-row a:hover { text-decoration: underline; }
  .cl-contact-item { color: var(--text-secondary); }
  .cl-interface-badge {
    display: inline-block; font-size: 0.6rem; font-weight: 600;
    padding: 3px 10px; border-radius: var(--radius-sm);
    text-transform: uppercase; letter-spacing: 0.06em;
    background: rgba(139,92,246,0.12); color: var(--accent-tertiary);
    margin-top: 10px;
  }
  /* --- Profile Mode Styles --- */
  .profile-badge {
    display: inline-block; font-size: 0.6rem; font-weight: 600;
    padding: 3px 10px; border-radius: var(--radius-sm);
    text-transform: uppercase; letter-spacing: 0.06em;
    background: rgba(236,72,153,0.12); color: #ec4899;
    margin-left: 8px; vertical-align: middle;
  }
  .profile-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    margin-bottom: 10px; overflow: hidden;
  }
  .profile-section-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 16px; cursor: pointer; user-select: none;
    font-size: 0.85rem; font-weight: 600; color: var(--text-primary);
    background: var(--bg-tertiary);
    border-bottom: 1px solid var(--border-subtle);
    transition: background var(--transition-fast);
  }
  .profile-section-header:hover { background: var(--bg-hover); }
  .profile-section-header .chevron { font-size: 0.7rem; color: var(--text-tertiary); transition: transform 0.2s; }
  .profile-section-header.collapsed .chevron { transform: rotate(-90deg); }
  .profile-section-body { padding: 12px 16px; }
  .profile-section-body.hidden { display: none; }
  .profile-bar-wrap { margin-bottom: 8px; }
  .profile-bar-label {
    display: inline-block; min-width: 120px; font-size: 0.78rem;
    font-weight: 500; color: var(--text-secondary);
  }
  .profile-bar-track {
    display: inline-block; width: calc(100% - 180px); height: 14px;
    background: var(--bg-tertiary); border-radius: 7px; vertical-align: middle;
    overflow: hidden; position: relative;
  }
  .profile-bar-fill {
    height: 100%; border-radius: 7px;
    background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
    transition: width 0.4s ease;
  }
  .profile-bar-value {
    display: inline-block; min-width: 40px; font-size: 0.72rem;
    font-weight: 600; color: var(--text-primary); text-align: right;
    margin-left: 6px; vertical-align: middle;
  }
  .profile-dispute {
    display: inline-block; font-size: 0.65rem; font-weight: 600;
    padding: 1px 6px; border-radius: var(--radius-sm);
    background: rgba(245,158,11,0.15); color: #f59e0b;
    margin-left: 6px; vertical-align: middle;
  }
  .profile-tag {
    display: inline-block; padding: 4px 10px; border-radius: 16px;
    font-size: 0.72rem; font-weight: 500; margin: 2px 4px 2px 0;
    background: rgba(99,102,241,0.08); color: var(--accent-light);
    border: 1px solid rgba(99,102,241,0.15);
  }
  .profile-insight-card {
    background: var(--bg-secondary); border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md); padding: 10px 14px; margin-bottom: 8px;
    border-left: 3px solid var(--accent-tertiary);
  }
  .profile-insight-card .insight-text { font-size: 0.82rem; color: var(--text-primary); line-height: 1.5; }
  .profile-insight-card .insight-source { font-size: 0.7rem; color: var(--text-tertiary); margin-top: 4px; }
  .profile-green {
    border-left: 3px solid #10b981; background: rgba(16,185,129,0.04);
    border-radius: var(--radius-md); padding: 8px 12px; margin-bottom: 6px;
    font-size: 0.82rem; color: var(--text-primary);
  }
  .profile-red {
    border-left: 3px solid #ef4444; background: rgba(239,68,68,0.04);
    border-radius: var(--radius-md); padding: 8px 12px; margin-bottom: 6px;
    font-size: 0.82rem; color: var(--text-primary);
  }
  .profile-amber {
    border-left: 3px solid #f59e0b; background: rgba(245,158,11,0.04);
    border-radius: var(--radius-md); padding: 8px 12px; margin-bottom: 6px;
    font-size: 0.82rem; color: var(--text-primary);
  }
  .profile-kv-row { display: flex; padding: 3px 0; font-size: 0.82rem; }
  .profile-kv-key { min-width: 140px; color: var(--text-tertiary); font-weight: 500; }
  .profile-kv-val { color: var(--text-primary); flex: 1; }
  .profile-source-date { font-size: 0.7rem; color: var(--text-tertiary); }
  .profile-source-date.stale { color: #f59e0b; }

  .cl-exp-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: 14px 16px; margin-bottom: 8px;
    transition: border-color var(--transition-fast);
  }
  .cl-exp-card:hover { border-color: var(--border-primary); }
  .cl-exp-company { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
  .cl-exp-title { font-size: 0.84rem; color: var(--accent-tertiary); }
  .cl-exp-dates { font-size: 0.72rem; color: var(--text-tertiary); margin-top: 2px; }
  .cl-exp-desc { font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px; line-height: 1.6; }
  .cl-edu-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    padding: 12px 16px; margin-bottom: 8px;
    transition: border-color var(--transition-fast);
  }
  .cl-edu-card:hover { border-color: var(--border-primary); }
  .cl-edu-institution { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
  .cl-edu-degree { font-size: 0.8rem; color: var(--text-secondary); }
  .cl-edu-years { font-size: 0.72rem; color: var(--text-tertiary); }
  .cl-skills-wrap { display: flex; flex-wrap: wrap; gap: 6px; }
  .cl-skill-tag {
    display: inline-block; padding: 5px 12px; border-radius: 20px;
    font-size: 0.72rem; font-weight: 500;
    background: rgba(99,102,241,0.08); color: var(--accent-light);
    border: 1px solid rgba(99,102,241,0.15);
    transition: all var(--transition-fast);
  }
  .cl-skill-tag:hover { background: rgba(99,102,241,0.15); }

  /* --- Share Modal --- */
  .share-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.3); z-index: 1000;
    display: flex; align-items: center; justify-content: center;
    backdrop-filter: blur(4px);
  }
  .share-modal {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg); padding: 28px; width: 440px; max-width: 90vw;
    max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.12);
  }
  .share-modal h3 {
    font-size: 1.05rem; font-weight: 600; color: var(--text-primary);
    margin-bottom: 20px;
  }
  .share-section-toggles { margin-bottom: 20px; }
  .share-toggle-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 0; border-bottom: 1px solid var(--border-subtle);
  }
  .share-toggle-row:last-child { border-bottom: none; }
  .share-toggle-row label {
    font-size: 0.85rem; color: var(--text-secondary); cursor: pointer;
  }
  .share-toggle-row input[type="checkbox"] { accent-color: var(--accent-light); width: 16px; height: 16px; cursor: pointer; }
  .share-expiry-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 20px; padding: 10px 0;
  }
  .share-expiry-row label { font-size: 0.85rem; color: var(--text-secondary); }
  .share-expiry-row select {
    background: var(--bg-secondary); border: 1px solid var(--border-primary);
    color: var(--text-primary); border-radius: var(--radius-sm); padding: 6px 10px;
    font-size: 0.82rem;
  }
  .share-actions {
    display: flex; gap: 10px; margin-bottom: 16px;
  }
  .share-actions button {
    flex: 1; padding: 10px; border-radius: var(--radius-sm); font-size: 0.85rem;
    font-weight: 500; cursor: pointer; border: 1px solid var(--border-primary);
    transition: all var(--transition-fast);
  }
  .btn-generate {
    background: var(--accent-gradient); color: #fff; border: none !important;
  }
  .btn-generate:hover { opacity: 0.9; }
  .btn-cancel {
    background: var(--bg-secondary); color: var(--text-secondary);
  }
  .btn-cancel:hover { border-color: var(--text-muted); }
  .share-result {
    background: var(--bg-secondary); border: 1px solid var(--border-primary);
    border-radius: var(--radius-sm); padding: 12px; margin-bottom: 16px;
  }
  .share-result-url {
    font-size: 0.8rem; color: var(--accent-light); word-break: break-all;
    margin-bottom: 8px; font-family: monospace;
  }
  .btn-copy-link {
    background: var(--bg-tertiary); border: 1px solid var(--border-primary);
    color: var(--text-primary); padding: 6px 14px; border-radius: var(--radius-sm);
    font-size: 0.78rem; cursor: pointer; transition: all var(--transition-fast);
  }
  .btn-copy-link:hover { border-color: var(--accent-light); color: var(--accent-light); }
  .share-active-list { margin-top: 16px; }
  .share-active-list h4 {
    font-size: 0.82rem; font-weight: 600; color: var(--text-secondary);
    margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;
  }
  .share-active-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 0; border-bottom: 1px solid var(--border-subtle);
    font-size: 0.8rem;
  }
  .share-active-item:last-child { border-bottom: none; }
  .share-active-info { color: var(--text-tertiary); }
  .share-active-sections { color: var(--text-muted); font-size: 0.72rem; }
  .btn-revoke {
    background: none; border: 1px solid rgba(239,68,68,0.3); color: #ef4444;
    padding: 4px 10px; border-radius: var(--radius-sm); font-size: 0.72rem;
    cursor: pointer; transition: all var(--transition-fast);
  }
  .btn-revoke:hover { background: rgba(239,68,68,0.1); border-color: #ef4444; }
  .btn-share {
    background: var(--accent-gradient); color: #fff; border: none;
    padding: 5px 14px; border-radius: var(--radius-sm); font-size: 0.75rem;
    font-weight: 500; cursor: pointer; transition: opacity var(--transition-fast);
  }
  .btn-share:hover { opacity: 0.85; }
  .cl-header-actions {
    display: flex; align-items: center; gap: 10px;
  }

  /* (old sidebar-footer CSS removed — replaced by .sidebar-bottom styles) */

  /* (old hierarchical sidebar CSS removed — replaced by flat nav styles above) */
  #breadcrumbs {
    padding: 0;
  }
  #breadcrumbs:empty {
    display: none;
  }
  .breadcrumb-bar {
    display: flex; align-items: center; gap: 0;
    padding: 10px 28px 0; font-size: 0.78rem;
  }
  .breadcrumb-bar a {
    color: var(--text-muted); text-decoration: none; cursor: pointer;
    transition: color 0.15s;
  }
  .breadcrumb-bar a:hover { color: #6366f1; }
  .breadcrumb-sep {
    margin: 0 6px; color: var(--text-muted); font-size: 0.7rem;
  }
  .breadcrumb-current {
    color: var(--text-primary); font-weight: 500;
  }
  .cat-page-header {
    font-size: 1.3rem; font-weight: 700; color: var(--text-primary);
    padding: 20px 0 16px; border-bottom: 1px solid var(--border-subtle);
    margin-bottom: 16px;
  }
  .cat-page-count {
    font-size: 0.85rem; font-weight: 400; color: var(--text-muted); margin-left: 8px;
  }
  .cat-card-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 12px;
  }
  .cat-card {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-md); padding: 14px 16px; cursor: pointer;
    transition: all var(--transition-fast); position: relative;
  }
  .cat-card:hover { border-color: #6366f1; box-shadow: 0 2px 8px rgba(99,102,241,0.1); }
  .cat-card-name { font-weight: 600; color: var(--text-primary); margin-bottom: 2px; }
  .cat-card-subtitle { font-size: 0.82rem; color: #555555; margin-bottom: 6px; }
  .cat-card-summary { font-size: 0.8rem; color: var(--text-secondary); line-height: 1.4; }
  /* Strength tiers */
  .cat-card.tier-gold { border-left: 3px solid #D4A017; background: #FFFDF5; }
  .cat-card.tier-green { border-left: 3px solid #4CAF50; }
  .cat-card.tier-muted { background: #F8F8F8; }
  .cat-card.tier-muted .cat-card-name { color: #777; }
  .cat-card.tier-muted .cat-card-subtitle { color: #999; }
  .cat-card.tier-muted .cat-card-summary { color: #999; }
  .cat-card-star { color: #D4A017; font-size: 0.75rem; margin-left: 4px; }
  /* Status overrides (layer on top of tiers) */
  .cat-card.status-deceased { border-left: 3px solid #9E9E9E; background: #FAFAFA; }
  .cat-card.status-deceased .cat-card-name { color: var(--text-primary); }
  .cat-card.status-former-spouse { border-left: 3px solid #FF9800; }
  .cat-card.status-current-spouse { border-left: 3px solid #4CAF50; }
  /* Status pills */
  .cat-status-pill {
    position: absolute; top: 10px; right: 10px;
    font-size: 0.65rem; font-weight: 600; padding: 2px 8px;
    border-radius: 10px; text-transform: uppercase; letter-spacing: 0.3px;
  }
  .cat-status-pill.pill-current { background: #E8F5E9; color: #2E7D32; }
  .cat-status-pill.pill-former { background: #FFF3E0; color: #E65100; }
  .cat-status-pill.pill-deceased { background: #F5F5F5; color: #616161; }
  .cat-status-pill.pill-complex { background: #FFF3E0; color: #E65100; }
  /* People Hub - Facebook-style */
  .people-hub { padding: 0 28px 40px; background: #fff; }
  .people-hub-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 24px 0 16px;
  }
  .people-hub-title-row { display: flex; align-items: center; gap: 10px; }
  .people-hub-title {
    font-size: 1.5rem; font-weight: 700; color: var(--text-primary); margin: 0;
    display: flex; align-items: center; gap: 8px;
  }
  .people-hub-title svg { color: #666; }
  .people-hub-count { font-size: 0.9rem; font-weight: 400; color: var(--text-muted); }
  .people-hub-search {
    padding: 8px 14px 8px 36px; border: 1px solid #ccc; border-radius: 20px;
    font-size: 14px; width: 240px; outline: none; background: #f0f2f5;
    transition: border-color 0.15s, background 0.15s;
  }
  .people-hub-search:focus { border-color: #0a66c2; background: #fff; }
  .people-hub-search-wrap {
    position: relative; display: flex; align-items: center;
  }
  .people-hub-search-wrap svg {
    position: absolute; left: 12px; color: #999; pointer-events: none;
  }
  .people-hub-tabs {
    display: flex; gap: 0; border-bottom: 1px solid #ddd; margin-bottom: 20px;
  }
  .people-hub-tab {
    padding: 12px 20px; font-size: 15px; font-weight: 600; color: #65676b;
    cursor: pointer; border: none; background: transparent; font-family: inherit;
    position: relative; transition: color 0.15s;
  }
  .people-hub-tab:hover { background: #f0f2f5; border-radius: 8px 8px 0 0; }
  .people-hub-tab.active { color: #0a66c2; }
  .people-hub-tab.active::after {
    content: ""; position: absolute; bottom: -1px; left: 0; right: 0;
    height: 3px; background: #0a66c2; border-radius: 3px 3px 0 0;
  }
  .people-hub-tab-count {
    font-size: 13px; font-weight: 400; color: #999; margin-left: 4px;
  }
  .people-hub-content { min-height: 200px; }
  .people-hub-empty {
    padding: 40px; text-align: center; color: var(--text-muted); font-size: 0.9rem;
  }
  .people-hub-tier-section { margin-bottom: 24px; }
  .people-hub-tier-label {
    font-size: 1rem; font-weight: 600; color: var(--text-primary);
    margin-bottom: 12px; padding-bottom: 6px;
    border-bottom: 1px solid var(--border-subtle, #e0e0e0);
    display: flex; align-items: center; gap: 8px;
  }
  .people-hub-tier-dot {
    width: 10px; height: 10px; border-radius: 50%; display: inline-block;
  }

  .cat-subsection { margin-bottom: 20px; }
  .cat-subsection-label {
    font-size: 0.9rem; font-weight: 600; color: var(--text-primary);
    margin-bottom: 10px; padding-left: 2px;
    border-bottom: 1px solid var(--border-subtle, var(--border-primary)); padding-bottom: 6px;
  }
  .cat-sub-divider {
    font-size: 0.82rem; font-weight: 500; color: #888;
    margin-top: 16px; margin-bottom: 8px; padding-left: 2px;
    border-top: 1px solid #E0E0E0; padding-top: 10px;
  }
  .cat-sub-divider:first-child { margin-top: 0; border-top: none; padding-top: 0; }
  /* (old sidebar-footer-user CSS removed — replaced by .sidebar-bottom styles) */

  /* --- Review Queue Badge --- */
  .review-queue-badge {
    display: inline-block; background: #ef4444; color: #fff; font-size: 10px; font-weight: 700;
    min-width: 16px; height: 16px; line-height: 16px; text-align: center;
    border-radius: 8px; padding: 0 4px; margin-left: 3px; vertical-align: top;
  }

  /* --- Review Queue & Staging UI --- */
  .review-queue { padding: 24px; max-width: 900px; margin: 0 auto; }
  .review-queue h2 { font-size: 1.2rem; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; }
  .review-queue-empty { padding: 40px; text-align: center; color: var(--text-muted); font-size: 0.9rem; }
  .cluster-card {
    background: var(--bg-card); border: 1px solid var(--border-primary); border-radius: var(--radius-md);
    padding: 16px; margin-bottom: 12px; transition: border-color var(--transition-fast);
  }
  .cluster-card:hover { border-color: var(--accent-tertiary); }
  .cluster-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .cluster-name { font-weight: 600; color: var(--text-primary); font-size: 0.95rem; }
  .cluster-source { font-size: 0.75rem; color: var(--text-muted); }
  .cluster-signals { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 10px; }
  .cluster-signals span { margin-right: 12px; }
  .cluster-actions { display: flex; gap: 8px; flex-wrap: wrap; }
  .cluster-actions button {
    padding: 5px 12px; border-radius: var(--radius-sm); border: 1px solid var(--border-primary);
    font-size: 0.78rem; cursor: pointer; transition: all var(--transition-fast);
  }
  .btn-merge { background: #22c55e; color: #fff; border-color: #22c55e; }
  .btn-merge:hover { background: #16a34a; }
  .btn-create-entity { background: #6366f1; color: #fff; border-color: #6366f1; }
  .btn-create-entity:hover { background: #4f46e5; }
  .btn-add-source { background: #f59e0b; color: #fff; border-color: #f59e0b; }
  .btn-add-source:hover { background: #d97706; }
  .btn-hold { background: var(--bg-primary); color: var(--text-secondary); }
  .btn-hold:hover { background: var(--bg-elevated); }

  /* Quadrant badges */
  .quadrant-badge {
    display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem;
    font-weight: 600; letter-spacing: 0.3px;
  }
  .quadrant-badge.q1 { background: #dbeafe; color: #1d4ed8; }
  .quadrant-badge.q2 { background: #dcfce7; color: #15803d; }
  .quadrant-badge.q3 { background: #fef3c7; color: #92400e; }
  .quadrant-badge.q4 { background: #f3e8ff; color: #6b21a8; }

  /* Ambiguous cluster styling */
  .rq-card.ambiguous { border-color: #f59e0b; border-width: 2px; background: linear-gradient(135deg, var(--bg-card) 97%, rgba(245,158,11,0.08) 100%); }
  .rq-evidence-panel {
    background: var(--bg-secondary); border-radius: var(--radius-sm);
    padding: 10px 12px; margin: 8px 0; font-size: 0.78rem;
  }
  .rq-evidence-panel .ev-title {
    font-size: 0.68rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em;
    color: #f59e0b; margin-bottom: 6px;
  }
  .rq-evidence-item {
    display: flex; align-items: center; gap: 6px; padding: 2px 0; color: var(--text-secondary);
  }
  .rq-evidence-item .ev-icon { font-size: 0.85rem; width: 18px; text-align: center; flex-shrink: 0; }
  .rq-evidence-item .ev-factor { font-weight: 600; color: var(--text-primary); min-width: 70px; }
  .rq-evidence-item .ev-note { font-size: 0.72rem; color: var(--text-muted); font-style: italic; }
  .rq-ambiguous-label {
    display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px;
    border-radius: 10px; font-size: 0.65rem; font-weight: 700;
    background: rgba(245,158,11,0.15); color: #d97706; margin-left: 6px;
  }

  /* Preview cluster overlay badges */
  .preview-cluster-badge {
    display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px;
    border-radius: var(--radius-sm); font-size: 0.72rem; font-weight: 600; margin-top: 4px;
  }
  .preview-cluster-badge.merge { background: #dcfce7; color: #15803d; border: 1px solid #86efac; }
  .preview-cluster-badge.review { background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; }
  .preview-cluster-badge.duplicate { background: #f3e8ff; color: #6b21a8; border: 1px solid #c084fc; }
  .preview-cluster-badge.new-entity { background: #dbeafe; color: #1d4ed8; border: 1px solid #93c5fd; }
  .preview-cluster-actions { display: flex; gap: 6px; margin-top: 4px; }
  .preview-cluster-actions button {
    padding: 2px 8px; border-radius: var(--radius-sm); border: 1px solid var(--border-primary);
    font-size: 0.7rem; cursor: pointer; background: var(--bg-primary); color: var(--text-secondary);
  }
  .preview-cluster-actions button:hover { background: var(--bg-elevated); }
  .preview-cluster-actions button.primary { background: #22c55e; color: #fff; border-color: #22c55e; }
  .preview-cluster-actions button.primary:hover { background: #16a34a; }

  /* --- Skeleton Loading --- */
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }
  .skeleton {
    background: linear-gradient(90deg, var(--bg-card) 25%, var(--bg-elevated) 50%, var(--bg-card) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    border-radius: var(--radius-sm);
  }

  /* ========================================
     UI UPGRADE: Knowledge Intelligence Platform
     ======================================== */

  /* --- Hero Card --- */
  .hero-card {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-xl);
    padding: 28px 32px;
    margin-bottom: 20px;
    box-shadow: var(--shadow-md);
    position: relative;
    overflow: hidden;
  }
  .hero-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 4px;
    background: var(--accent-gradient);
  }
  .hero-top {
    display: flex; gap: 20px; align-items: flex-start;
  }
  .hero-avatar {
    width: 80px; height: 80px; border-radius: 50%;
    background: var(--accent-gradient);
    display: flex; align-items: center; justify-content: center;
    font-size: 1.8rem; font-weight: 700; color: white; flex-shrink: 0;
    box-shadow: 0 4px 16px rgba(99,102,241,0.25);
    overflow: hidden;
  }
  .hero-avatar img { width: 100%; height: 100%; object-fit: cover; }
  .hero-info { flex: 1; min-width: 0; }
  .hero-name-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 4px; }
  .hero-name {
    font-size: 1.6rem; font-weight: 700; color: var(--text-primary);
    letter-spacing: -0.02em;
  }
  .hero-headline { font-size: 0.92rem; color: var(--text-secondary); margin-bottom: 4px; }
  .hero-current { font-size: 0.86rem; color: var(--accent-tertiary); margin-bottom: 4px; font-weight: 500; }
  .hero-location {
    font-size: 0.8rem; color: var(--text-tertiary);
    display: flex; align-items: center; gap: 4px;
  }
  .hero-contact-row {
    display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; font-size: 0.8rem;
  }
  .hero-contact-item {
    display: flex; align-items: center; gap: 5px;
    color: var(--text-secondary); font-size: 0.78rem;
  }
  .hero-contact-item a {
    color: var(--info); text-decoration: none;
    display: flex; align-items: center; gap: 5px;
  }
  .hero-contact-item a:hover { text-decoration: underline; }
  .hero-badges {
    display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; align-items: center;
  }
  .hero-actions {
    display: flex; gap: 8px; align-items: center; margin-top: 12px;
  }

  /* --- Tier Badges --- */
  .tier-badge {
    display: inline-flex; align-items: center; gap: 4px;
    font-size: 0.65rem; font-weight: 700; padding: 3px 10px;
    border-radius: 12px; text-transform: uppercase; letter-spacing: 0.05em;
  }
  .tier-badge.tier-self {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #78350f; box-shadow: 0 1px 4px rgba(245,158,11,0.3);
  }
  .tier-badge.tier-inner {
    background: rgba(34,197,94,0.12); color: #15803d;
    border: 1px solid rgba(34,197,94,0.25);
  }
  .tier-badge.tier-outer {
    background: rgba(107,114,128,0.1); color: var(--text-tertiary);
    border: 1px solid rgba(107,114,128,0.2);
  }

  /* --- Health Score Indicator --- */
  .health-indicator {
    display: inline-flex; align-items: center; gap: 6px;
    font-size: 0.72rem; font-weight: 600; padding: 3px 10px;
    border-radius: 12px;
  }
  .health-indicator .health-dots {
    display: flex; gap: 3px;
  }
  .health-indicator .health-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--border-primary);
  }
  .health-indicator .health-dot.filled { background: currentColor; }
  .health-thin { color: #ef4444; background: rgba(239,68,68,0.08); }
  .health-developing { color: #f59e0b; background: rgba(245,158,11,0.08); }
  .health-strong { color: #22c55e; background: rgba(34,197,94,0.08); }

  /* --- Confidence Badges (color coded) --- */
  .conf-badge {
    display: inline-flex; align-items: center; gap: 4px;
    font-size: 0.65rem; font-weight: 600; padding: 2px 8px;
    border-radius: 10px; white-space: nowrap;
  }
  .conf-badge .conf-dot {
    width: 5px; height: 5px; border-radius: 50%;
    background: currentColor;
  }
  .conf-high { color: #15803d; background: rgba(34,197,94,0.1); }
  .conf-mid { color: #b45309; background: rgba(245,158,11,0.1); }
  .conf-low { color: #dc2626; background: rgba(239,68,68,0.1); }

  /* --- Timeline Experience Cards --- */
  .timeline-section { position: relative; padding-left: 24px; }
  .timeline-section::before {
    content: '';
    position: absolute; left: 7px; top: 8px; bottom: 8px;
    width: 2px; background: var(--border-primary);
    border-radius: 1px;
  }
  .timeline-item {
    position: relative;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: 16px 18px;
    margin-bottom: 10px;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  .timeline-item:hover { border-color: var(--accent-tertiary); box-shadow: var(--shadow-md); }
  .timeline-item::before {
    content: '';
    position: absolute; left: -20px; top: 18px;
    width: 10px; height: 10px; border-radius: 50%;
    background: var(--accent-primary);
    border: 2px solid var(--bg-primary);
    box-shadow: 0 0 0 2px var(--accent-primary);
  }
  .timeline-item.current::before {
    background: #22c55e;
    box-shadow: 0 0 0 2px #22c55e;
  }
  .timeline-company { font-size: 0.92rem; font-weight: 600; color: var(--text-primary); }
  .timeline-title { font-size: 0.84rem; color: var(--accent-tertiary); font-weight: 500; }
  .timeline-dates { font-size: 0.72rem; color: var(--text-tertiary); margin-top: 2px; }
  .timeline-desc { font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px; line-height: 1.6; }

  /* --- Education Cards --- */
  .edu-card {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: 14px 18px;
    margin-bottom: 8px;
    display: flex; align-items: flex-start; gap: 14px;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  .edu-card:hover { border-color: var(--accent-tertiary); }
  .edu-icon {
    width: 36px; height: 36px; border-radius: var(--radius-sm);
    background: rgba(168,85,247,0.1);
    display: flex; align-items: center; justify-content: center;
    font-size: 1rem; flex-shrink: 0;
  }
  .edu-info { flex: 1; }
  .edu-institution { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
  .edu-degree { font-size: 0.82rem; color: var(--text-secondary); }
  .edu-years { font-size: 0.72rem; color: var(--text-tertiary); }

  /* --- Skill Tags (upgraded) --- */
  .skill-grid {
    display: flex; flex-wrap: wrap; gap: 8px;
  }
  .skill-chip {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 6px 14px; border-radius: 20px;
    font-size: 0.75rem; font-weight: 500;
    background: rgba(99,102,241,0.06); color: var(--accent-light);
    border: 1px solid rgba(99,102,241,0.12);
    transition: all var(--transition-fast);
  }
  .skill-chip:hover {
    background: rgba(99,102,241,0.12);
    border-color: rgba(99,102,241,0.25);
    transform: translateY(-1px);
  }

  /* --- Relationship Cards --- */
  .rel-card {
    display: flex; align-items: center; gap: 12px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    padding: 12px 16px;
    margin-bottom: 8px;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  .rel-card:hover { border-color: var(--accent-tertiary); }
  .rel-card-avatar {
    width: 36px; height: 36px; border-radius: 50%;
    background: var(--bg-tertiary);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.7rem; font-weight: 700; color: var(--text-muted); flex-shrink: 0;
  }
  .rel-card-info { flex: 1; min-width: 0; }
  .rel-card-name { font-size: 0.86rem; font-weight: 600; color: var(--text-primary); }
  .rel-card-context { font-size: 0.75rem; color: var(--text-tertiary); margin-top: 2px; }
  .rel-type-badge {
    font-size: 0.62rem; font-weight: 600; padding: 2px 8px;
    border-radius: 10px; text-transform: uppercase; letter-spacing: 0.03em;
    white-space: nowrap;
  }
  .rel-type-badge.friend { background: rgba(59,130,246,0.1); color: #2563eb; }
  .rel-type-badge.colleague { background: rgba(99,102,241,0.1); color: #6366f1; }
  .rel-type-badge.family { background: rgba(236,72,153,0.1); color: #ec4899; }
  .rel-type-badge.mentor { background: rgba(168,85,247,0.1); color: #7c3aed; }
  .rel-type-badge.default { background: rgba(107,114,128,0.1); color: var(--text-tertiary); }

  /* --- Source Attribution --- */
  .source-footer {
    display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
    padding: 14px 18px;
    background: var(--bg-card);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    margin-top: 16px;
  }
  .source-footer-label {
    font-size: 0.68rem; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.06em; color: var(--text-muted); margin-right: 4px;
  }
  .source-tag {
    display: inline-flex; align-items: center; gap: 5px;
    font-size: 0.7rem; padding: 3px 10px;
    border-radius: 10px; font-weight: 500;
    background: var(--bg-tertiary); color: var(--text-secondary);
  }
  .source-tag svg { width: 12px; height: 12px; opacity: 0.7; }

  /* --- Review Queue Upgrade --- */
  .rq-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
  }
  .rq-header h2 {
    font-size: 1.3rem; font-weight: 700; color: var(--text-primary);
    display: flex; align-items: center; gap: 10px;
  }
  .rq-stats {
    display: flex; gap: 16px;
  }
  .rq-stat {
    display: flex; flex-direction: column; align-items: center;
    padding: 8px 16px;
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-md);
    min-width: 80px;
  }
  .rq-stat-num {
    font-size: 1.3rem; font-weight: 700; letter-spacing: -0.02em;
  }
  .rq-stat-num.unresolved { color: #6366f1; }
  .rq-stat-num.provisional { color: #f59e0b; }
  .rq-stat-num.ready { color: #22c55e; }
  .rq-stat-label {
    font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.06em;
    color: var(--text-muted); font-weight: 600;
  }

  .rq-group-header {
    font-size: 0.75rem; font-weight: 600; color: var(--text-tertiary);
    padding: 12px 0 6px; margin-top: 8px;
    border-bottom: 1px solid var(--border-subtle);
    display: flex; align-items: center; gap: 6px;
  }
  .rq-group-header svg { width: 14px; height: 14px; opacity: 0.5; }

  .rq-card {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    padding: 18px 20px;
    margin-bottom: 10px;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-sm);
  }
  .rq-card:hover { border-color: var(--accent-tertiary); box-shadow: var(--shadow-md); }
  .rq-card-header {
    display: flex; align-items: center; gap: 10px; margin-bottom: 10px;
  }
  .rq-entity-icon {
    width: 32px; height: 32px; border-radius: var(--radius-sm);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.9rem; flex-shrink: 0;
  }
  .rq-entity-icon.person { background: rgba(99,102,241,0.1); }
  .rq-entity-icon.business, .rq-entity-icon.organization { background: rgba(14,165,233,0.1); }
  .rq-card-title { flex: 1; }
  .rq-card-name { font-size: 0.95rem; font-weight: 600; color: var(--text-primary); }
  .rq-card-source {
    font-size: 0.72rem; color: var(--text-muted); margin-top: 2px;
    display: flex; align-items: center; gap: 4px;
  }
  .rq-conf-bar {
    display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
  }
  .rq-conf-track {
    flex: 1; height: 6px; background: var(--bg-tertiary);
    border-radius: 3px; overflow: hidden;
  }
  .rq-conf-fill {
    height: 100%; border-radius: 3px;
    transition: width 0.4s ease;
  }
  .rq-conf-fill.high { background: linear-gradient(90deg, #22c55e, #16a34a); }
  .rq-conf-fill.mid { background: linear-gradient(90deg, #f59e0b, #d97706); }
  .rq-conf-fill.low { background: linear-gradient(90deg, #ef4444, #dc2626); }
  .rq-conf-label { font-size: 0.72rem; font-weight: 600; color: var(--text-secondary); min-width: 35px; }
  .rq-signals {
    font-size: 0.78rem; color: var(--text-secondary); margin-bottom: 12px;
    display: flex; gap: 14px; flex-wrap: wrap;
  }
  .rq-signal-item { display: flex; align-items: center; gap: 4px; }
  .rq-actions {
    display: flex; gap: 8px; flex-wrap: wrap;
  }
  .rq-actions button {
    padding: 7px 16px; border-radius: var(--radius-md);
    font-size: 0.78rem; font-weight: 600; cursor: pointer;
    transition: all var(--transition-fast);
    border: none;
  }
  .rq-btn-create { background: #22c55e; color: #fff; }
  .rq-btn-create:hover { background: #16a34a; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(34,197,94,0.3); }
  .rq-btn-merge { background: #6366f1; color: #fff; }
  .rq-btn-merge:hover { background: #4f46e5; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(99,102,241,0.3); }
  .rq-btn-hold { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-primary) !important; }
  .rq-btn-hold:hover { background: var(--bg-hover); }
  .rq-btn-reject { background: rgba(239,68,68,0.1); color: #ef4444; border: 1px solid rgba(239,68,68,0.2) !important; }
  .rq-btn-reject:hover { background: #ef4444; color: #fff; }
  .rq-btn-source { background: rgba(245,158,11,0.1); color: #b45309; border: 1px solid rgba(245,158,11,0.2) !important; }
  .rq-btn-source:hover { background: #f59e0b; color: #fff; }

  /* Quadrant badges (upgraded) */
  .rq-quadrant {
    font-size: 0.62rem; font-weight: 700; padding: 3px 10px;
    border-radius: 10px; letter-spacing: 0.04em;
    display: inline-flex; align-items: center; gap: 4px;
  }
  .rq-quadrant.q1 { background: #dbeafe; color: #1d4ed8; }
  .rq-quadrant.q2 { background: #dcfce7; color: #15803d; }
  .rq-quadrant.q3 { background: #fef3c7; color: #92400e; }
  .rq-quadrant.q4 { background: #f3e8ff; color: #6b21a8; }

  /* --- Bundle Cards (Extraction Event Grouping) --- */
  .rq-bundle {
    background: var(--bg-card);
    border: 1px solid var(--border-primary);
    border-radius: var(--radius-lg);
    margin-bottom: 14px;
    box-shadow: var(--shadow-sm);
    overflow: hidden;
    transition: all var(--transition-fast);
  }
  .rq-bundle:hover { border-color: var(--accent-tertiary); box-shadow: var(--shadow-md); }
  .rq-bundle-header {
    display: flex; align-items: center; gap: 12px;
    padding: 16px 20px; cursor: pointer;
    background: linear-gradient(135deg, var(--bg-card) 80%, rgba(99,102,241,0.04) 100%);
  }
  .rq-bundle-header:hover { background: var(--bg-hover); }
  .rq-bundle-icon {
    width: 40px; height: 40px; border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
    font-size: 1.1rem; flex-shrink: 0; background: rgba(99,102,241,0.08);
  }
  .rq-bundle-info { flex: 1; min-width: 0; }
  .rq-bundle-title {
    font-size: 1rem; font-weight: 700; color: var(--text-primary);
    display: flex; align-items: center; gap: 8px;
  }
  .rq-bundle-summary {
    font-size: 0.72rem; color: var(--text-muted); margin-top: 2px;
  }
  .rq-bundle-meta {
    display: flex; gap: 6px; align-items: center;
  }
  .rq-bundle-count {
    font-size: 0.68rem; font-weight: 700; padding: 2px 8px;
    border-radius: 10px; background: rgba(99,102,241,0.1); color: #6366f1;
  }
  .rq-bundle-chevron {
    font-size: 0.9rem; color: var(--text-muted); transition: transform 0.2s;
  }
  .rq-bundle.expanded .rq-bundle-chevron { transform: rotate(90deg); }
  .rq-bundle-body {
    display: none; padding: 0 20px 16px; border-top: 1px solid var(--border-subtle);
  }
  .rq-bundle.expanded .rq-bundle-body { display: block; }
  .rq-bundle-primary {
    padding: 14px 0; border-bottom: 1px solid var(--border-subtle);
  }
  .rq-bundle-primary-label {
    font-size: 0.62rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.06em; color: #6366f1; margin-bottom: 6px;
  }
  .rq-bundle-related {
    padding: 12px 0;
  }
  .rq-bundle-related-label {
    font-size: 0.62rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 8px;
  }
  .rq-related-item {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 12px; margin-bottom: 4px;
    border-radius: var(--radius-md); background: var(--bg-secondary);
    transition: background 0.15s;
  }
  .rq-related-item:hover { background: var(--bg-tertiary); }
  .rq-related-check {
    width: 16px; height: 16px; cursor: pointer; accent-color: #6366f1;
  }
  .rq-related-icon {
    width: 28px; height: 28px; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem; flex-shrink: 0; background: rgba(14,165,233,0.08);
  }
  .rq-related-info { flex: 1; min-width: 0; }
  .rq-related-name { font-size: 0.82rem; font-weight: 600; color: var(--text-primary); }
  .rq-related-role { font-size: 0.68rem; color: var(--text-muted); }
  .rq-exists-badge {
    font-size: 0.6rem; font-weight: 700; padding: 1px 6px;
    border-radius: 6px; background: rgba(34,197,94,0.12); color: #15803d;
  }
  .rq-bundle-actions {
    display: flex; gap: 8px; padding: 12px 0 0;
    border-top: 1px solid var(--border-subtle); margin-top: 4px;
  }
  .rq-btn-add-graph {
    padding: 8px 20px; border-radius: var(--radius-md);
    font-size: 0.82rem; font-weight: 700; cursor: pointer;
    background: #22c55e; color: #fff; border: none;
    transition: all var(--transition-fast);
  }
  .rq-btn-add-graph:hover { background: #16a34a; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(34,197,94,0.3); }
  .rq-btn-dismiss {
    padding: 8px 20px; border-radius: var(--radius-md);
    font-size: 0.82rem; font-weight: 600; cursor: pointer;
    background: var(--bg-tertiary); color: var(--text-secondary);
    border: 1px solid var(--border-primary);
    transition: all var(--transition-fast);
  }
  .rq-btn-dismiss:hover { background: var(--bg-hover); }

  /* --- Sidebar Upgrades --- */
  .sidebar-health-dot {
    display: inline-block; width: 8px; height: 8px;
    border-radius: 50%; margin-left: 6px; vertical-align: middle;
  }
  .sidebar-health-dot.health-thin { background: #ef4444; }
  .sidebar-health-dot.health-developing { background: #f59e0b; }
  .sidebar-health-dot.health-strong { background: #22c55e; }

  .sidebar-metric {
    font-size: 1.1rem; font-weight: 700; color: var(--text-primary);
    margin-right: 4px; letter-spacing: -0.01em;
  }
  .sidebar-metric-label {
    font-size: 0.65rem; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.06em;
  }

  @keyframes pulseBadge {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }
  .review-queue-badge.pulse {
    animation: pulseBadge 2s ease-in-out infinite;
    background: linear-gradient(135deg, #ef4444, #dc2626);
    box-shadow: 0 2px 8px rgba(239,68,68,0.4);
  }

  /* --- Connection Tier Toggle --- */
  .conn-tier-toggle {
    cursor: pointer; display: flex; align-items: center; gap: 6px;
    padding: 4px 8px; border-radius: var(--radius-sm);
    transition: background var(--transition-fast);
    user-select: none;
  }
  .conn-tier-toggle:hover { background: var(--bg-secondary); }

  /* --- Connection Intel Banner --- */
  .conn-intel-banner {
    display: flex; flex-wrap: wrap; gap: 8px;
    padding: 10px 14px; border-radius: var(--radius-md);
    background: var(--bg-secondary); border: 1px solid var(--border-subtle);
    margin-bottom: 12px; font-size: 0.78rem;
  }
  .conn-intel-item {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 2px 8px; border-radius: 10px; font-weight: 600;
  }
  .conn-intel-item.intel-warn { background: rgba(239,68,68,0.1); color: #ef4444; }
  .conn-intel-item.intel-info { background: rgba(59,130,246,0.1); color: #3b82f6; }
  .conn-intel-item.intel-muted { background: rgba(156,163,175,0.1); color: #9ca3af; }

  /* --- Connections Grid (Facebook-style) --- */
  .conn-grid-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 8px;
  }
  .conn-grid-search {
    display: flex; align-items: center; gap: 6px;
  }
  .conn-grid-search input {
    padding: 4px 10px; border-radius: 6px; border: 1px solid var(--border-primary);
    background: var(--bg-secondary); color: var(--text-primary);
    font-size: 0.72rem; width: 150px; outline: none;
  }
  .conn-grid-search input:focus { border-color: var(--accent); }
  .conn-grid-summary {
    font-size: 0.72rem; color: var(--text-muted); margin-bottom: 14px;
    display: flex; flex-wrap: wrap; gap: 4px; align-items: center;
  }
  .conn-grid-summary-item {
    display: inline-flex; align-items: center; gap: 3px;
  }
  .conn-grid-summary-dot {
    width: 8px; height: 8px; border-radius: 50%; display: inline-block;
  }
  .conn-tier-section { margin-bottom: 16px; }
  .conn-tier-label {
    font-size: 0.7rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.04em; margin-bottom: 8px;
    display: flex; align-items: center; gap: 5px;
    padding-bottom: 4px; border-bottom: 2px solid var(--border-subtle);
  }
  .conn-grid {
    display: grid; grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  @media (max-width: 900px) { .conn-grid { grid-template-columns: repeat(2, 1fr); } }
  .conn-grid-card {
    display: flex; align-items: center; gap: 10px;
    padding: 10px 12px;
    background: var(--bg-card); border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    transition: all var(--transition-fast);
  }
  .conn-grid-card:hover { border-color: var(--accent-tertiary); box-shadow: var(--shadow-sm); }
  .conn-grid-card.clickable { cursor: pointer; }
  .conn-grid-avatar {
    width: 40px; height: 40px; border-radius: 50%;
    background: var(--bg-tertiary);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem; font-weight: 700; color: var(--text-muted);
    flex-shrink: 0;
  }
  .conn-grid-avatar.in-graph { background: rgba(99,102,241,0.1); color: #6366f1; }
  .conn-grid-info { flex: 1; min-width: 0; overflow: hidden; }
  .conn-grid-name {
    font-size: 0.82rem; font-weight: 600; color: var(--text-primary);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .conn-grid-desc {
    font-size: 0.68rem; color: var(--text-muted); margin-top: 1px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .conn-grid-tier {
    font-size: 0.55rem; font-weight: 700; color: #fff;
    padding: 1px 5px; border-radius: 6px; white-space: nowrap; flex-shrink: 0;
  }
  .conn-show-more {
    display: block; text-align: center; padding: 6px;
    font-size: 0.72rem; font-weight: 600; color: var(--accent);
    cursor: pointer; border-radius: var(--radius-sm);
    transition: background var(--transition-fast);
  }
  .conn-show-more:hover { background: rgba(99,102,241,0.06); }
  .conn-view-all-link {
    display: block; text-align: center; padding: 10px;
    font-size: 0.78rem; font-weight: 600; color: var(--accent);
    cursor: pointer; margin-top: 8px;
    border: 1px dashed var(--border-primary); border-radius: var(--radius-md);
  }
  .conn-view-all-link:hover { background: rgba(99,102,241,0.04); }

  /* --- Conflict Detection UI --- */
  .conflict-badge {
    display: inline-flex; align-items: center; gap: 3px;
    padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; font-weight: 700;
    background: rgba(249,115,22,0.15); color: #f97316; border: 1px solid rgba(249,115,22,0.3);
  }
  .conflict-section {
    margin-top: 20px; padding: 16px; border-radius: var(--radius-md);
    background: rgba(249,115,22,0.04); border: 1px solid rgba(249,115,22,0.2);
  }
  .conflict-section h3 {
    font-size: 0.82rem; font-weight: 700; color: #f97316; margin: 0 0 12px 0;
    display: flex; align-items: center; gap: 6px;
  }
  .conflict-card {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-md); padding: 12px 14px; margin-bottom: 10px;
  }
  .conflict-card-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 8px;
  }
  .conflict-attr { font-size: 0.78rem; font-weight: 700; color: var(--text-primary); text-transform: capitalize; }
  .conflict-type-tag {
    font-size: 0.65rem; font-weight: 700; padding: 1px 6px; border-radius: 6px;
    text-transform: uppercase; letter-spacing: 0.04em;
  }
  .conflict-type-tag.factual { background: rgba(239,68,68,0.1); color: #ef4444; }
  .conflict-type-tag.temporal { background: rgba(59,130,246,0.1); color: #3b82f6; }
  .conflict-type-tag.identity { background: rgba(168,85,247,0.1); color: #a855f7; }
  .conflict-values {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;
  }
  .conflict-val {
    padding: 8px 10px; border-radius: var(--radius-sm); font-size: 0.75rem;
  }
  .conflict-val.val-a { background: rgba(239,68,68,0.06); border: 1px solid rgba(239,68,68,0.15); }
  .conflict-val.val-b { background: rgba(59,130,246,0.06); border: 1px solid rgba(59,130,246,0.15); }
  .conflict-val-label { font-size: 0.65rem; color: var(--text-muted); font-weight: 600; margin-bottom: 2px; }
  .conflict-val-text { font-weight: 600; color: var(--text-primary); }
  .conflict-val-source { font-size: 0.62rem; color: var(--text-muted); margin-top: 2px; }
  .conflict-actions { display: flex; gap: 6px; }
  .conflict-actions button {
    padding: 4px 10px; border-radius: 6px; font-size: 0.7rem; font-weight: 600;
    cursor: pointer; border: 1px solid var(--border-primary); background: var(--bg-card);
    color: var(--text-primary); transition: all 0.15s;
  }
  .conflict-actions button:hover { background: var(--accent); color: white; border-color: var(--accent); }
  .conflict-actions button.btn-keep-both { color: var(--text-muted); }

  /* --- Section Headers (upgraded) --- */
  .section-header-icon {
    display: inline-flex; align-items: center; justify-content: center;
    width: 28px; height: 28px; border-radius: var(--radius-sm);
    font-size: 0.85rem; margin-right: 8px; flex-shrink: 0;
  }

  /* ========================================
     OVERVIEW DASHBOARD
     ======================================== */
  .ov-section { margin-bottom: 24px; }
  .ov-section-title {
    font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.06em; color: var(--text-muted);
    margin-bottom: 12px; padding-bottom: 6px;
    border-bottom: 1px solid var(--border-subtle);
  }
  .ov-coverage-grid {
    display: grid; grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .ov-coverage-cat {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-md); padding: 14px 16px;
  }
  .ov-coverage-cat-title {
    font-size: 0.78rem; font-weight: 700; color: var(--text-primary);
    margin-bottom: 8px;
  }
  .ov-coverage-item {
    display: flex; align-items: center; gap: 8px;
    font-size: 0.78rem; color: var(--text-secondary);
    padding: 3px 0;
  }
  .ov-coverage-dot {
    width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
  }
  .ov-coverage-dot.filled { background: #22c55e; }
  .ov-coverage-dot.empty { background: var(--bg-tertiary); border: 1.5px solid var(--text-muted); }
  .ov-stat-grid {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 10px;
  }
  .ov-stat-card {
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-md); padding: 14px 12px; text-align: center;
  }
  .ov-stat-value {
    font-size: 1.5rem; font-weight: 800; color: #6366f1;
    line-height: 1;
  }
  .ov-stat-label {
    font-size: 0.68rem; color: var(--text-muted); text-transform: uppercase;
    letter-spacing: 0.04em; margin-top: 4px;
  }
  .ov-activity-item {
    display: flex; gap: 12px; padding: 10px 0;
    border-bottom: 1px solid var(--border-subtle);
  }
  .ov-activity-item:last-child { border-bottom: none; }
  .ov-activity-dot {
    width: 8px; height: 8px; border-radius: 50%; background: #6366f1;
    flex-shrink: 0; margin-top: 6px;
  }
  .ov-activity-text {
    font-size: 0.82rem; color: var(--text-primary); line-height: 1.4;
  }
  .ov-activity-meta {
    font-size: 0.72rem; color: var(--text-muted); margin-top: 2px;
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
  }
  .ov-conn-grid {
    display: grid; grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .ov-conn-card {
    display: flex; align-items: center; gap: 10px;
    background: var(--bg-card); border: 1px solid var(--border-primary);
    border-radius: var(--radius-md); padding: 12px 14px;
    transition: all var(--transition-fast);
  }
  .ov-conn-card:hover { border-color: #6366f1; transform: translateY(-1px); }
  .ov-conn-avatar {
    width: 36px; height: 36px; border-radius: 50%;
    background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center;
    font-size: 0.7rem; font-weight: 700; color: var(--text-muted); flex-shrink: 0;
  }
  .ov-conn-info { flex: 1; min-width: 0; }
  .ov-conn-name {
    font-size: 0.82rem; font-weight: 600; color: var(--text-primary);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .ov-conn-type {
    font-size: 0.68rem; color: var(--text-muted); margin-top: 1px;
  }
  .ov-source-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 12px; background: var(--bg-card);
    border: 1px solid var(--border-primary); border-radius: var(--radius-sm);
    margin-bottom: 6px;
  }
  .ov-source-name {
    font-size: 0.82rem; font-weight: 500; color: var(--text-primary);
    display: flex; align-items: center; gap: 6px;
  }
  .ov-source-count {
    font-size: 0.75rem; font-weight: 700; color: #6366f1;
    background: rgba(99,102,241,0.1); padding: 2px 8px;
    border-radius: 10px;
  }
  .ov-tier-bar {
    display: flex; height: 8px; border-radius: 4px; overflow: hidden;
    background: var(--border-primary); margin-top: 12px;
  }
  .ov-tier-legend {
    display: flex; justify-content: space-between;
    font-size: 0.68rem; color: var(--text-muted); margin-top: 4px;
  }
  .ov-tier-dot {
    display: inline-block; width: 8px; height: 8px;
    border-radius: 2px; margin-right: 4px; vertical-align: middle;
  }

  /* ========================================
     DENSITY BADGES & ENRICHMENT PROMPTS
     ======================================== */
  .density-badge {
    display: inline-flex; align-items: center; gap: 4px;
    font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.04em; padding: 2px 8px; border-radius: 10px;
  }
  .density-badge.density-skeleton {
    background: rgba(156,163,175,0.15); color: #9ca3af;
  }
  .density-badge.density-partial {
    background: rgba(249,115,22,0.12); color: #f97316;
  }
  .density-badge.density-rich {
    background: rgba(59,130,246,0.12); color: #3b82f6;
  }
  .density-badge.density-comprehensive {
    background: rgba(16,185,129,0.12); color: #10b981;
  }
  .density-dot {
    width: 6px; height: 6px; border-radius: 50%;
  }
  .density-skeleton .density-dot { background: #9ca3af; }
  .density-partial .density-dot { background: #f97316; }
  .density-rich .density-dot { background: #3b82f6; }
  .density-comprehensive .density-dot { background: #10b981; }

  .enrich-prompt {
    display: flex; align-items: center; gap: 10px;
    padding: 12px 16px; margin: 8px 0;
    background: var(--bg-card); border: 1px dashed var(--border-primary);
    border-radius: var(--radius-sm); color: var(--text-muted);
    font-size: 0.8rem; line-height: 1.4;
  }
  .enrich-prompt-icon {
    font-size: 1.1rem; flex-shrink: 0;
  }
  .enrich-prompt-text { flex: 1; }
  .enrich-prompt-action {
    font-size: 0.72rem; font-weight: 600; color: #6366f1;
    white-space: nowrap; cursor: pointer;
    padding: 4px 10px; border: 1px solid #6366f1;
    border-radius: var(--radius-sm); background: transparent;
  }
  .enrich-prompt-action:hover {
    background: rgba(99,102,241,0.08);
  }

  /* ========================================
     DISCOVER SPINNER
     ======================================== */
  .discover-spinner {
    width: 14px; height: 14px;
    border: 2px solid var(--border-primary);
    border-top: 2px solid #10b981;
    border-radius: 50%;
    animation: discoverSpin 0.8s linear infinite;
    flex-shrink: 0;
  }
  @keyframes discoverSpin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* ========================================
     LINKEDIN-INSPIRED PROFILE CARDS (MAYA)
     ======================================== */
  #main.li-profile-bg {
    background: #f4f2ee; padding: 36px 24px 40px;
  }
  .li-profile {
    width: 100%; padding: 0 0 40px;
  }

  /* Integrated breadcrumbs */
  .li-breadcrumbs {
    display: flex; align-items: center; gap: 0; padding: 14px 0 8px;
    font-size: 13px; color: #666;
  }
  .li-breadcrumbs a {
    color: #666; text-decoration: none; cursor: pointer;
  }
  .li-breadcrumbs a:hover { color: #0a66c2; }
  .li-breadcrumbs .li-bc-sep {
    margin: 0 6px; color: #bbb; font-size: 11px;
  }
  .li-breadcrumbs .li-bc-current {
    color: #191919; font-weight: 600;
  }

  /* Horizontal tab bar — sticky */
  .li-tab-bar {
    display: flex; gap: 0; background: #fff; border-bottom: 1px solid #e0e0e0;
    border-radius: 0; margin-bottom: 8px;
    position: sticky; top: 0; z-index: 10;
  }
  .li-tab {
    flex: 1; padding: 14px 8px; text-align: center; font-size: 13px;
    font-weight: 600; color: #666; cursor: pointer; border: none;
    background: transparent; font-family: inherit; position: relative;
    transition: color 0.15s;
  }
  .li-tab:hover { color: #191919; background: rgba(0,0,0,0.02); }
  .li-tab.active { color: #0a66c2; font-weight: 700; }
  .li-tab.active::after {
    content: ''; position: absolute; bottom: 0; left: 0; right: 0;
    height: 2px; background: #0a66c2;
  }

  /* Card base */
  .li-card {
    background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;
    padding: 24px; margin-bottom: 8px; position: relative;
  }
  .li-card.editing { border-left: 3px solid #0a66c2; }
  .li-card-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 16px;
  }
  .li-card-title {
    font-size: 18px; font-weight: 600; color: #191919; margin: 0;
  }
  .li-card-subtitle {
    font-size: 14px; color: #666; margin-top: 2px;
  }
  .li-edit-btn {
    background: none; border: none; cursor: pointer; padding: 6px;
    border-radius: 50%; color: #999; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
  }
  .li-edit-btn:hover {
    background: #f0f0f0; color: #191919;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  }

  /* Hero card specifics */
  .li-hero { padding: 24px; }
  .li-hero-top { display: flex; gap: 20px; align-items: flex-start; }
  .li-hero-avatar {
    width: 80px; height: 80px; border-radius: 50%; display: flex;
    align-items: center; justify-content: center; font-size: 1.8rem;
    font-weight: 700; color: #fff; flex-shrink: 0;
  }
  .li-hero-avatar.person { background: linear-gradient(135deg, #0a66c2, #004182); }
  .li-hero-avatar.org { background: linear-gradient(135deg, #057642, #004d2c); }
  .li-hero-info { flex: 1; min-width: 0; }
  .li-hero-name {
    font-size: 24px; font-weight: 700; color: #191919; margin: 0;
    line-height: 1.2;
  }
  .li-hero-headline {
    font-size: 14px; color: #191919; margin-top: 4px; line-height: 1.4;
  }
  .li-hero-meta {
    display: flex; align-items: center; gap: 8px; margin-top: 6px;
    font-size: 14px; color: #666; flex-wrap: wrap;
  }
  .li-hero-meta svg { flex-shrink: 0; }
  .li-hero-type {
    font-size: 11px; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.04em; padding: 2px 8px; border-radius: 4px;
    background: #f0f0f0; color: #666;
  }
  .li-hero-stats {
    display: flex; gap: 16px; margin-top: 10px; font-size: 14px;
  }
  .li-hero-stat { color: #0a66c2; font-weight: 600; cursor: pointer; }
  .li-hero-stat:hover { text-decoration: underline; }
  .li-hero-stat.muted { color: #666; font-weight: 400; cursor: default; }
  .li-hero-stat.muted:hover { text-decoration: none; }
  .li-hero-socials {
    display: flex; gap: 10px; margin-top: 10px; align-items: center;
  }
  .li-hero-social-link {
    display: flex; align-items: center; gap: 4px; color: #0a66c2;
    font-size: 13px; text-decoration: none;
  }
  .li-hero-social-link:hover { text-decoration: underline; }
  .li-hero-right {
    display: flex; flex-direction: column; align-items: flex-end; gap: 8px;
    flex-shrink: 0; align-self: center;
  }

  /* Health score circle */
  .li-health-circle {
    width: 48px; height: 48px; border-radius: 50%; display: flex;
    align-items: center; justify-content: center; font-size: 14px;
    font-weight: 700; border: 3px solid;
  }
  .li-health-circle.strong { border-color: #057642; color: #057642; }
  .li-health-circle.developing { border-color: #b45309; color: #b45309; }
  .li-health-circle.thin { border-color: #cc1016; color: #cc1016; }

  /* About card */
  .li-about-text {
    font-size: 14px; color: #191919; line-height: 1.5;
    display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .li-about-text.expanded {
    -webkit-line-clamp: unset; overflow: visible;
  }
  .li-see-more {
    color: #666; font-size: 13px; font-weight: 600; cursor: pointer;
    margin-top: 4px; display: inline-block;
  }
  .li-see-more:hover { color: #0a66c2; }
  .li-skill-pills {
    display: flex; flex-wrap: wrap; gap: 6px; margin-top: 12px;
    align-items: center;
  }
  .li-skill-pill {
    background: #e8f4f8; border-radius: 16px; padding: 4px 12px;
    font-size: 13px; color: #191919; white-space: nowrap;
  }
  .li-skill-label {
    font-size: 13px; color: #666; font-weight: 600; margin-right: 4px;
  }
  .li-show-all {
    color: #0a66c2; font-size: 13px; font-weight: 600; cursor: pointer;
    margin-top: 8px; display: inline-block;
  }
  .li-show-all:hover { text-decoration: underline; }

  /* Intelligence card */
  .li-intel-private {
    font-size: 14px; color: #666; display: flex; align-items: center;
    gap: 6px;
  }
  .li-intel-stats {
    display: flex; gap: 12px; margin-top: 12px;
  }
  .li-intel-stat {
    flex: 1; background: #f4f2ee; border-radius: 8px; padding: 14px 16px;
    text-align: center;
  }
  .li-intel-stat-value {
    font-size: 22px; font-weight: 700; color: #191919;
  }
  .li-intel-stat-label {
    font-size: 12px; color: #666; margin-top: 2px;
  }
  .li-intel-footer {
    font-size: 12px; color: #666; margin-top: 12px;
  }
  .li-intel-warning {
    display: flex; align-items: center; gap: 6px; margin-top: 10px;
    padding: 8px 12px; background: #fff7ed; border: 1px solid #fed7aa;
    border-radius: 6px; font-size: 13px; color: #b45309;
  }

  /* Dynamic structured-attribute cards */
  .li-collapse-btn {
    background: none; border: none; cursor: pointer; padding: 4px;
    border-radius: 50%; color: #999; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
  }
  .li-collapse-btn:hover { background: #f0f0f0; color: #191919; }
  .li-card.li-collapsed .li-card-body { display: none; }
  .li-card.li-collapsed .li-collapse-btn svg { transform: rotate(-90deg); }

  .li-kv-row { display: flex; padding: 6px 0; border-bottom: 1px solid #f0f0f0; font-size: 14px; }
  .li-kv-row:last-child { border-bottom: none; }
  .li-kv-key { min-width: 160px; color: #666; font-weight: 500; flex-shrink: 0; }
  .li-kv-val { color: #191919; flex: 1; line-height: 1.4; }

  .li-bar-wrap { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
  .li-bar-label { min-width: 140px; font-size: 14px; font-weight: 500; color: #191919; }
  .li-bar-track { flex: 1; height: 18px; background: #f0f0f0; border-radius: 9px; overflow: hidden; }
  .li-bar-fill { height: 100%; border-radius: 9px; background: linear-gradient(90deg, #0a66c2, #004182); transition: width 0.4s; }
  .li-bar-value { min-width: 40px; font-size: 13px; font-weight: 700; color: #191919; text-align: right; }
  .li-bar-dispute { font-size: 11px; font-weight: 600; padding: 2px 8px; border-radius: 4px; background: rgba(245,158,11,0.12); color: #b45309; margin-left: 4px; }

  .li-pill-tag { display: inline-block; padding: 4px 12px; border-radius: 16px; font-size: 13px; font-weight: 500; margin: 3px 4px 3px 0; }
  .li-pill-green { background: #ecfdf5; color: #059669; border: 1px solid #a7f3d0; }
  .li-pill-red { background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; }
  .li-pill-blue { background: #eff6ff; color: #2563eb; border: 1px solid #bfdbfe; }
  .li-pill-amber { background: #fffbeb; color: #d97706; border: 1px solid #fde68a; }

  .li-border-item { border-left: 3px solid; border-radius: 6px; padding: 8px 14px; margin-bottom: 6px; font-size: 14px; color: #191919; line-height: 1.4; }
  .li-border-green { border-color: #10b981; background: rgba(16,185,129,0.04); }
  .li-border-red { border-color: #ef4444; background: rgba(239,68,68,0.04); }
  .li-border-amber { border-color: #f59e0b; background: rgba(245,158,11,0.04); }
  .li-border-blue { border-color: #3b82f6; background: rgba(59,130,246,0.04); }

  .li-status-tag { display: inline-block; font-size: 11px; font-weight: 600; padding: 2px 8px; border-radius: 4px; margin-left: 6px; text-transform: uppercase; letter-spacing: 0.03em; }
  .li-status-confirmed { background: rgba(16,185,129,0.12); color: #059669; }
  .li-status-disputed { background: rgba(239,68,68,0.12); color: #dc2626; }
  .li-status-modified { background: rgba(245,158,11,0.12); color: #d97706; }

  .li-blockquote { border-left: 3px solid #0a66c2; padding: 12px 16px; margin: 8px 0; background: #f8fafc; border-radius: 0 8px 8px 0; }
  .li-blockquote-text { font-size: 14px; color: #191919; line-height: 1.5; font-style: italic; }
  .li-blockquote-source { font-size: 12px; color: #666; margin-top: 6px; font-style: normal; }

  .li-sub-section { margin-top: 16px; }
  .li-sub-title { font-size: 15px; font-weight: 600; color: #191919; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
  .li-sub-card { background: #fafafa; border: 1px solid #f0f0f0; border-radius: 8px; padding: 14px; margin-bottom: 8px; }

  .li-insight-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px 14px; margin-bottom: 8px; border-left: 3px solid #0a66c2; }
  .li-insight-text { font-size: 14px; color: #191919; line-height: 1.5; }
  .li-insight-source { font-size: 12px; color: #666; margin-top: 4px; }

  .li-mbti-badge { display: inline-block; background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 8px; padding: 8px 14px; font-weight: 700; font-size: 16px; color: #1d4ed8; }
  .li-enneagram-badge { display: inline-block; background: #faf5ff; border: 1px solid #e9d5ff; border-radius: 8px; padding: 8px 14px; font-weight: 700; font-size: 16px; color: #7c3aed; }

  .li-family-member { display: flex; gap: 14px; padding: 14px; background: #fafafa; border: 1px solid #f0f0f0; border-radius: 8px; margin-bottom: 8px; }
  .li-family-avatar { width: 44px; height: 44px; border-radius: 50%; background: linear-gradient(135deg, #0a66c2, #004182); display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 700; color: #fff; flex-shrink: 0; }
  .li-family-info { flex: 1; min-width: 0; }
  .li-family-name { font-size: 14px; font-weight: 600; color: #191919; }
  .li-family-role { font-size: 13px; color: #666; margin-top: 2px; }
  .li-family-detail { font-size: 13px; color: #191919; margin-top: 4px; }

  /* Experience card */
  .li-exp-item {
    display: flex; gap: 14px; padding: 14px 0;
    border-bottom: 1px solid #f0f0f0;
  }
  .li-exp-item:last-child { border-bottom: none; }
  .li-exp-logo {
    width: 40px; height: 40px; border-radius: 4px; background: #f0f0f0;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; font-weight: 700; color: #666; flex-shrink: 0;
  }
  .li-exp-info { flex: 1; min-width: 0; }
  .li-exp-title { font-size: 14px; font-weight: 600; color: #191919; }
  .li-exp-company { font-size: 14px; color: #191919; }
  .li-exp-company a { color: #0a66c2; text-decoration: none; }
  .li-exp-company a:hover { text-decoration: underline; }
  .li-exp-dates { font-size: 13px; color: #666; margin-top: 2px; }
  .li-exp-loc { font-size: 13px; color: #666; }
  .li-exp-desc {
    font-size: 13px; color: #191919; margin-top: 6px; line-height: 1.5;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .li-exp-desc.expanded {
    -webkit-line-clamp: unset; overflow: visible;
  }
  .li-conf-dot {
    display: inline-block; width: 6px; height: 6px; border-radius: 50%;
    margin-left: 4px; vertical-align: middle;
  }
  .li-conf-dot.high { background: #057642; }
  .li-conf-dot.mid { background: #b45309; }
  .li-conf-dot.low { background: #cc1016; }

  /* Education card */
  .li-edu-item {
    display: flex; gap: 14px; padding: 12px 0;
    border-bottom: 1px solid #f0f0f0;
  }
  .li-edu-item:last-child { border-bottom: none; }
  .li-edu-logo {
    width: 40px; height: 40px; border-radius: 4px; background: #f5f0ff;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; font-weight: 700; color: #7c3aed; flex-shrink: 0;
  }
  .li-edu-info { flex: 1; }
  .li-edu-name { font-size: 14px; font-weight: 600; color: #191919; }
  .li-edu-degree { font-size: 14px; color: #191919; }
  .li-edu-years { font-size: 13px; color: #666; }

  /* Activity / Observations card */
  .li-obs-item {
    padding: 12px 0; border-bottom: 1px solid #f0f0f0;
  }
  .li-obs-item:last-child { border-bottom: none; }
  .li-obs-source {
    display: flex; align-items: center; gap: 6px; font-size: 12px;
    color: #666; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.03em; margin-bottom: 4px;
  }
  .li-obs-source-icon {
    width: 20px; height: 20px; border-radius: 4px; background: #f0f0f0;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px;
  }
  .li-obs-text {
    font-size: 14px; color: #191919; line-height: 1.5;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .li-obs-date { font-size: 12px; color: #666; margin-top: 4px; }

  /* Connections card — reuse existing conn-grid inside li-card */
  .li-card .conn-grid-header { margin-bottom: 12px; }

  /* Edit mode form elements */
  .li-edit-field {
    width: 100%; padding: 8px 12px; border: 1px solid #e0e0e0;
    border-radius: 6px; font-size: 14px; font-family: inherit;
    color: #191919; background: #fff; outline: none;
    transition: border-color 0.15s;
  }
  .li-edit-field:focus { border-color: #0a66c2; }
  .li-edit-textarea {
    width: 100%; padding: 8px 12px; border: 1px solid #e0e0e0;
    border-radius: 6px; font-size: 14px; font-family: inherit;
    color: #191919; min-height: 80px; resize: vertical;
    outline: none;
  }
  .li-edit-textarea:focus { border-color: #0a66c2; }
  .li-edit-row {
    display: flex; gap: 8px; margin-bottom: 8px; align-items: center;
  }
  .li-edit-row label {
    font-size: 13px; color: #666; min-width: 80px; font-weight: 500;
  }
  .li-edit-row input, .li-edit-row select {
    flex: 1; padding: 6px 10px; border: 1px solid #e0e0e0;
    border-radius: 6px; font-size: 14px; font-family: inherit;
  }
  .li-edit-actions {
    display: flex; gap: 8px; margin-top: 14px; justify-content: flex-end;
  }
  .li-btn-save {
    padding: 8px 20px; background: #0a66c2; color: #fff; border: none;
    border-radius: 20px; font-size: 14px; font-weight: 600;
    cursor: pointer; font-family: inherit;
  }
  .li-btn-save:hover { background: #004182; }
  .li-btn-cancel {
    padding: 8px 20px; background: #fff; color: #666; border: 1px solid #e0e0e0;
    border-radius: 20px; font-size: 14px; font-weight: 600;
    cursor: pointer; font-family: inherit;
  }
  .li-btn-cancel:hover { background: #f8f8f8; }
  .li-pill-remove {
    background: none; border: none; cursor: pointer; color: #999;
    font-size: 14px; margin-left: 2px; padding: 0 2px;
  }
  .li-pill-remove:hover { color: #cc1016; }
  .li-pill-add {
    background: #fff; border: 1px dashed #ccc; border-radius: 16px;
    padding: 4px 12px; font-size: 13px; color: #0a66c2; cursor: pointer;
  }
  .li-pill-add:hover { border-color: #0a66c2; }
  .li-add-entry {
    display: flex; align-items: center; gap: 6px; padding: 10px 0;
    color: #0a66c2; font-size: 14px; font-weight: 600; cursor: pointer;
  }
  .li-add-entry:hover { text-decoration: underline; }

  /* Org: People card */
  .li-people-item {
    display: flex; gap: 12px; padding: 10px 0; align-items: center;
    border-bottom: 1px solid #f0f0f0; cursor: pointer;
  }
  .li-people-item:last-child { border-bottom: none; }
  .li-people-item:hover { background: #f8f8f8; margin: 0 -12px; padding: 10px 12px; border-radius: 6px; }
  .li-people-avatar {
    width: 36px; height: 36px; border-radius: 50%; background: #e8f4f8;
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; font-weight: 700; color: #0a66c2; flex-shrink: 0;
  }
  .li-people-name { font-size: 14px; font-weight: 600; color: #191919; }
  .li-people-role { font-size: 13px; color: #666; }

  /* --- Gap Analysis Dashboard (MECE-019) — font sizes bumped Build 8 --- */
  .gap-dashboard { padding: 24px 28px; font-size: 15px; }
  .gap-dashboard-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 24px; flex-wrap: wrap; gap: 12px;
  }
  .gap-dashboard-title {
    font-size: 1.5rem; font-weight: 700; color: var(--text-primary);
    display: flex; align-items: center; gap: 8px;
  }
  .gap-dashboard-controls { display: flex; align-items: center; gap: 10px; }
  .gap-dashboard-controls select {
    padding: 6px 12px; border: 1px solid #d0d0d0; border-radius: 6px;
    font-size: 13px; background: #fff; cursor: pointer;
  }
  .gap-dashboard-controls button {
    padding: 6px 14px; border: 1px solid #0a66c2; border-radius: 6px;
    background: #0a66c2; color: #fff; font-size: 13px; cursor: pointer;
    transition: background 0.15s;
  }
  .gap-dashboard-controls button:hover { background: #004182; }
  .gap-ring-container {
    display: flex; align-items: center; justify-content: center;
    gap: 40px; margin-bottom: 28px; flex-wrap: wrap;
  }
  .gap-ring {
    position: relative; width: 180px; height: 180px;
    border-radius: 50%;
  }
  .gap-ring-label {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center;
  }
  .gap-ring-pct { font-size: 3rem; font-weight: 700; line-height: 1; }
  .gap-ring-sub { font-size: 0.75rem; color: var(--text-muted); margin-top: 2px; }
  .gap-score-bars { flex: 1; min-width: 260px; }
  .gap-score-bar {
    margin-bottom: 14px;
  }
  .gap-score-bar-header {
    display: flex; justify-content: space-between; font-size: 14px;
    margin-bottom: 4px; color: var(--text-primary);
  }
  .gap-score-bar-track {
    height: 10px; background: #e8e8e8; border-radius: 5px; overflow: hidden;
  }
  .gap-score-bar-fill {
    height: 100%; border-radius: 5px; transition: width 0.4s ease;
  }
  .gap-category {
    margin-bottom: 20px;
  }
  .gap-category-title {
    font-size: 1.1rem; font-weight: 600; color: var(--text-primary);
    margin-bottom: 10px; display: flex; align-items: center; gap: 6px;
  }
  .gap-category-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 10px;
  }
  .gap-missing-item {
    display: flex; align-items: flex-start; gap: 8px; padding: 12px 16px;
    border: 1px solid #e0e0e0; border-radius: 8px; background: #fff;
    font-size: 14px; transition: border-color 0.15s, box-shadow 0.15s;
  }
  .gap-missing-item[style*="cursor:pointer"]:hover,
  .gap-missing-item[onclick]:hover {
    border-color: #0a66c2; box-shadow: 0 2px 8px rgba(10,102,194,0.1);
  }
  .gap-missing-item svg { width: 16px; height: 16px; flex-shrink: 0; margin-top: 1px; }
  .gap-missing-item .gap-item-name { font-weight: 500; color: var(--text-primary); }
  .gap-missing-item .gap-item-detail { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
  .gap-priority-badge {
    font-size: 10px; font-weight: 600; padding: 1px 6px; border-radius: 8px;
    text-transform: uppercase; letter-spacing: 0.3px; margin-left: auto; flex-shrink: 0;
  }
  .gap-priority-badge.high { background: #FEE2E2; color: #991B1B; }
  .gap-priority-badge.medium { background: #FEF3C7; color: #92400E; }
  .gap-priority-badge.low { background: #E0E7FF; color: #3730A3; }
  .gap-suggestions {
    margin-top: 20px; padding: 16px; background: #F0F9FF;
    border: 1px solid #BAE6FD; border-radius: 8px;
  }
  .gap-suggestions-title {
    font-size: 0.9rem; font-weight: 600; color: #0369A1; margin-bottom: 8px;
  }
  .gap-suggestions ul { margin: 0; padding-left: 20px; }
  .gap-suggestions li { font-size: 13px; color: #0C4A6E; margin-bottom: 4px; }
  .gap-found-section { margin-top: 20px; }
  .gap-found-item {
    display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px;
    background: #ECFDF5; border: 1px solid #A7F3D0; border-radius: 6px;
    font-size: 12px; color: #065F46; margin: 3px;
  }

  /* --- Export View (Build 6) — card-based layout matching Completeness — font bumps Build 8 --- */
  .export-view { padding: 24px 28px; font-size: 15px; }
  .export-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 24px; flex-wrap: wrap; gap: 12px;
  }
  .export-title {
    font-size: 1.5rem; font-weight: 700; color: var(--text-primary);
    display: flex; align-items: center; gap: 8px;
  }
  .export-summary {
    display: flex; gap: 16px; margin-bottom: 24px; flex-wrap: wrap;
  }
  .export-stat {
    display: flex; align-items: center; gap: 6px;
    font-size: 13px; color: var(--text-secondary);
  }
  .export-stat-count { font-weight: 700; font-size: 18px; line-height: 1; }
  .export-btn-csv {
    padding: 8px 16px; border: 1px solid #0a66c2; border-radius: 6px;
    background: #0a66c2; color: #fff; font-size: 13px; cursor: pointer;
    font-weight: 600; display: flex; align-items: center; gap: 6px;
    transition: background 0.15s;
  }
  .export-btn-csv:hover { background: #004182; }
  /* Role card — matches gap-category styling */
  .export-role-card {
    margin-bottom: 20px; background: #fff;
    border: 1px solid #e0e0e0; border-radius: 8px;
  }
  .export-role-header {
    display: flex; align-items: center; gap: 8px;
    padding: 12px 16px; border-bottom: 1px solid #f0f0f0;
    cursor: pointer; user-select: none;
  }
  .export-role-header:hover { background: #fafafa; }
  .export-role-icon {
    width: 28px; height: 28px; border-radius: 6px;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }
  .export-role-icon.org { background: #EFF6FF; color: #1D4ED8; }
  .export-role-icon.person { background: #F0FDF4; color: #16A34A; }
  .export-role-name { font-size: 16px; font-weight: 600; color: var(--text-primary); flex: 1; }
  .export-role-count {
    font-size: 11px; font-weight: 600; padding: 2px 8px; border-radius: 10px;
    background: #F3F4F6; color: #6B7280;
  }
  .export-role-count.complete { background: #DCFCE7; color: #166534; }
  .export-role-chevron { transition: transform 0.2s; color: #999; }
  .export-role-chevron.collapsed { transform: rotate(-90deg); }
  .export-role-body { padding: 0; }
  .export-role-body.collapsed { display: none; }
  /* Entity sub-header inside role card */
  .export-entity-header {
    padding: 8px 16px; font-size: 12px; font-weight: 600; color: #0a66c2;
    background: #fafbfc; border-bottom: 1px solid #f0f0f0;
    display: flex; align-items: center; gap: 6px;
  }
  /* Field row inside card — not a table, a flex list */
  .export-field-row {
    display: flex; align-items: flex-start; gap: 10px;
    padding: 10px 16px; border-bottom: 1px solid #f5f5f5;
    font-size: 14px; transition: background 0.1s; cursor: pointer;
  }
  .export-field-row:last-child { border-bottom: none; }
  .export-field-row:hover { background: #fafbfc; }
  .export-field-row.missing { opacity: 0.6; }
  .export-field-label {
    width: 160px; min-width: 120px; font-weight: 500;
    color: var(--text-secondary); flex-shrink: 0; font-size: 14px;
  }
  .export-field-value {
    flex: 1; color: var(--text-primary); font-weight: 500; font-size: 15px;
    display: flex; align-items: flex-start; gap: 8px; flex-wrap: wrap;
  }
  .export-field-value.empty { color: #9CA3AF; font-style: italic; font-weight: 400; }
  .export-field-meta {
    display: flex; align-items: center; gap: 8px; flex-shrink: 0;
  }
  /* Badge — same as before */
  .export-badge {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 2px 8px; border-radius: 10px;
    font-size: 10px; font-weight: 600; white-space: nowrap;
  }
  .export-badge.verified { background: #DCFCE7; color: #166534; }
  .export-badge.low_confidence { background: #FEF9C3; color: #854D0E; }
  .export-badge.conflict { background: #FEE2E2; color: #991B1B; }
  .export-badge.missing { background: #F3F4F6; color: #6B7280; }
  /* Source pill */
  .export-source-pill {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 2px 8px; background: #EFF6FF; border: 1px solid #BFDBFE;
    border-radius: 10px; font-size: 10px; color: #1D4ED8;
    cursor: pointer; max-width: 180px; overflow: hidden;
    text-overflow: ellipsis; white-space: nowrap;
    transition: background 0.15s;
  }
  .export-source-pill:hover { background: #DBEAFE; }
  /* Evidence snippet inline expand */
  .export-evidence-inline {
    margin: 6px 0 4px 170px; padding: 10px 14px;
    background: #FFFBEB; border-left: 3px solid #F59E0B;
    border-radius: 0 8px 8px 0; font-size: 12px;
    line-height: 1.6; color: #191919; position: relative;
  }
  .export-evidence-inline .snippet-text { font-style: italic; }
  .export-evidence-meta {
    margin-top: 6px; font-size: 11px; color: #666;
    display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
  }
  .export-evidence-meta span { font-weight: 600; color: #333; }
  .export-btn-view-original {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 10px; background: #f0f0f0; border: 1px solid #d0d0d0;
    border-radius: 6px; font-size: 11px; color: #333; cursor: pointer;
    text-decoration: none;
  }
  .export-btn-view-original:hover { background: #e0e0e0; }
  .export-not-found {
    padding: 16px; text-align: center; color: #9CA3AF; font-size: 13px;
    font-style: italic;
  }

</style>
</head>
<body>

<!-- Login Screen -->
<div id="login-screen">
  <div class="login-card">
    <div class="login-brand">
      <svg width="36" height="36" viewBox="0 0 36 36" fill="none">
        <rect width="36" height="36" rx="10" fill="url(#loginGrad)"/>
        <text x="18" y="23" text-anchor="middle" fill="white" font-size="14" font-weight="700" font-family="system-ui">CA</text>
        <defs><linearGradient id="loginGrad" x1="0" y1="0" x2="36" y2="36"><stop stop-color="#6366f1"/><stop offset="1" stop-color="#8b5cf6"/></linearGradient></defs>
      </svg>
    </div>
    <h1><span>Context Architecture</span></h1>
    <p class="subtitle">Knowledge Graph Dashboard</p>
    <a href="/auth/google" class="btn google-btn" id="btnGoogle">
      <svg width="18" height="18" viewBox="0 0 48 48" style="vertical-align:middle;margin-right:8px;">
        <path fill="#4285F4" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/>
        <path fill="#34A853" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/>
        <path fill="#FBBC05" d="M10.53 28.59a14.5 14.5 0 010-9.18l-7.98-6.19a24.1 24.1 0 000 21.56l7.98-6.19z"/>
        <path fill="#EA4335" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/>
      </svg>
      Sign in with Google
    </a>
    <div class="login-divider"><span>or use API key</span></div>
    <input type="password" id="apiKeyInput" placeholder="Enter API key (ctx-...)" />
    <div class="login-error" id="loginError"></div>
    <button class="btn" id="btnLogin" onclick="login()">Connect</button>
  </div>
</div>

<!-- App -->
<div id="app">
  <div id="sidebar">
    <!-- Brand -->
    <div class="sidebar-brand">
      <div class="brand-icon">CA</div>
      <div class="brand-text">Context Architecture</div>
    </div>
    <!-- Utility bar -->
    <div class="sidebar-utility-bar">
      <div class="sidebar-utility-link" onclick="showUploadView()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        <span>Upload</span>
      </div>
      <div class="sidebar-utility-link" id="sidebarSearchToggle" onclick="toggleSidebarSearch()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
        <span>Search</span>
      </div>
      <div class="sidebar-utility-link" onclick="showReviewQueue()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
        <span>Review<span id="reviewQueueBadge" class="review-queue-badge" style="display:none">0</span></span>
      </div>
      <div class="sidebar-utility-link" onclick="showCleanupView()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
        <span>Cleanup</span>
      </div>
    </div>
    <!-- Hideable search panel -->
    <div id="sidebarSearchPanel" style="display:none">
      <div class="sidebar-search">
        <div class="search-wrapper">
          <svg class="search-icon" width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
            <circle cx="6.5" cy="6.5" r="5"/>
            <path d="M14.5 14.5l-4-4"/>
          </svg>
          <input type="text" id="searchInput" placeholder="Search or ask a question..." oninput="onSearch()" onkeydown="if(event.key==='Enter')onSearch(true)" />
        </div>
      </div>
    </div>
    <!-- Spoke selector -->
    <div id="spokeSelector"></div>
    <!-- Dynamic content -->
    <div id="entityList"></div>
    <!-- Bottom user section -->
    <div class="sidebar-bottom">
      <div class="sidebar-bottom-avatar" id="userAvatar"></div>
      <span class="sidebar-bottom-name" id="userInfo"></span>
      <span id="logoutLink"></span>
    </div>
  </div>
  <div id="main">
    <div id="breadcrumbs"></div>
    <div class="empty-state" id="emptyState">
      <svg width="48" height="48" viewBox="0 0 48 48" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.2">
        <circle cx="24" cy="24" r="20"/>
        <circle cx="24" cy="20" r="7"/>
        <path d="M12 40c0-6.627 5.373-12 12-12s12 5.373 12 12"/>
      </svg>
      <div>Select an entity from the sidebar<br/>to view its knowledge graph profile</div>
    </div>
  </div>
  <div id="rightPanel">
    <button class="rp-collapse-toggle" onclick="toggleCollapseRightPanel()" title="Collapse panel">&#x203A;</button>
    <div id="rightPanelContent"></div>
  </div>
  <button id="rightPanelToggle" onclick="toggleRightPanel()" title="Toggle context panel">&#9776;</button>
</div>

<div class="toast" id="toast"></div>
<input type="file" id="uploadFileInput" multiple accept=".pdf,.docx,.doc,.xlsx,.xls,.csv,.txt,.md,.json" style="display:none" />

<script>
var apiKey = '';
var sessionUser = null;
var entities = [];
var selectedId = null;
var selectedData = null;
var searchTimeout = null;
var primaryEntityId = null;
var primaryEntityData = null;
var allEntities = [];
var selectedView = null;
var selectedCategory = null;
var breadcrumbs = [];
var recentEntities = [];
var _sbProjectsExpanded = false;
var _selectedSpoke = null;  // null = "All", or spoke ID
var _spokesList = [];       // [{id, name, centered_entity_name, entity_count, _completeness, _hasTemplate}]
var _templatesList = [];    // [{id, label, category_count, entity_roles}]
var _activeClientTab = 'completeness'; // Current tab when viewing a client workspace

function esc(s) { var d = document.createElement('div'); d.textContent = s || ''; return d.innerHTML; }

function toggleSidebarSearch() {
  var panel = document.getElementById('sidebarSearchPanel');
  if (!panel) return;
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    var inp = document.getElementById('searchInput');
    if (inp) inp.focus();
  } else {
    panel.style.display = 'none';
    var inp = document.getElementById('searchInput');
    if (inp) { inp.value = ''; onSearch(); }
  }
}

function trackRecentEntity(id, name) {
  if (!id || id === primaryEntityId) return;
  recentEntities = recentEntities.filter(function(r) { return r.id !== id; });
  recentEntities.unshift({ id: id, name: name || id });
  if (recentEntities.length > 8) recentEntities = recentEntities.slice(0, 8);
}

function renderBreadcrumbs() {
  var el = document.getElementById('breadcrumbs');
  if (!el) return;
  if (!breadcrumbs || breadcrumbs.length === 0) { el.innerHTML = ''; return; }
  var html = '<div class="breadcrumb-bar">';
  for (var i = 0; i < breadcrumbs.length; i++) {
    var b = breadcrumbs[i];
    if (i > 0) html += '<span class="breadcrumb-sep">\u203A</span>';
    if (i < breadcrumbs.length - 1 && b.action) {
      html += '<a onclick="' + b.action + '">' + esc(b.label) + '</a>';
    } else {
      html += '<span class="breadcrumb-current">' + esc(b.label) + '</span>';
    }
  }
  html += '</div>';
  el.innerHTML = html;
}

function findPrimaryUser(ents, user) {
  if (!user || !user.name) return null;
  var persons = ents.filter(function(e) { return e.entity_type === 'person'; });
  if (persons.length === 0) return null;
  var uname = user.name.toLowerCase().trim();
  var uemail = (user.email || '').toLowerCase().trim();

  for (var i = 0; i < persons.length; i++) {
    console.log('SIDEBAR_DEBUG: comparing entity:', persons[i].name, 'to user:', user.name, uemail);
  }

  // 1. Exact email match
  if (uemail) {
    for (var i = 0; i < persons.length; i++) {
      var pemail = (persons[i].email || '').toLowerCase().trim();
      if (pemail && pemail === uemail) { console.log('SIDEBAR_DEBUG: matched by email'); return persons[i].entity_id; }
    }
  }

  // 2. Exact name match
  for (var i = 0; i < persons.length; i++) {
    if (persons[i].name && persons[i].name.toLowerCase().trim() === uname) { console.log('SIDEBAR_DEBUG: matched by exact name'); return persons[i].entity_id; }
  }

  // 3. Substring match (either direction)
  for (var i = 0; i < persons.length; i++) {
    var pname = (persons[i].name || '').toLowerCase().trim();
    if (pname.indexOf(uname) !== -1 || uname.indexOf(pname) !== -1) { console.log('SIDEBAR_DEBUG: matched by substring'); return persons[i].entity_id; }
  }

  // 4. First+last word match: check if first AND last word of one appear in the other
  var uwords = uname.split(/\\s+/);
  if (uwords.length >= 2) {
    var ufirst = uwords[0];
    var ulast = uwords[uwords.length - 1];
    for (var i = 0; i < persons.length; i++) {
      var pname = (persons[i].name || '').toLowerCase();
      if (pname.indexOf(ufirst) !== -1 && pname.indexOf(ulast) !== -1) { console.log('SIDEBAR_DEBUG: matched by first+last'); return persons[i].entity_id; }
    }
  }
  // Also check reverse: entity first+last in user name
  for (var i = 0; i < persons.length; i++) {
    var pwords = (persons[i].name || '').toLowerCase().split(/\\s+/);
    if (pwords.length >= 2) {
      var pfirst = pwords[0];
      var plast = pwords[pwords.length - 1];
      if (uname.indexOf(pfirst) !== -1 && uname.indexOf(plast) !== -1) { console.log('SIDEBAR_DEBUG: matched by entity first+last in user'); return persons[i].entity_id; }
    }
  }

  // Fallback: single person entity
  if (persons.length === 1) return persons[0].entity_id;
  console.log('SIDEBAR_DEBUG: NO MATCH FOUND');
  return null;
}

// === DIMENSION-READING FUNCTIONS ===
// All categorization is driven by relationship_dimensions. No keyword matching.

function getPage(entity) {
  var d = entity.relationship_dimensions;
  if (!d || !d.connection_type) return 'other';

  // Family: blood, or marriage direct, or any in-law (sub_role gates it)
  if (d.connection_type === 'blood' || d.connection_type === 'marriage') {
    if (!d.connected_through) return 'family';
    if (d.connection_type === 'blood') return 'family';
    if (d.connection_type === 'marriage' && d.sub_role === 'in_law') return 'family';
    // Marriage through someone else (friend's spouse) = Other
    if (d.connection_type === 'marriage' && d.connected_through) return 'other';
    return 'family';
  }

  // Indirect connections with low strength = Other (friend's partners, etc.)
  if (d.connected_through && (d.strength || 0) < 0.30) return 'other';

  // Page assignment uses connection_type only — never access score
  if (d.connection_type === 'chosen') return 'friends';
  if (d.connection_type === 'professional' || d.connection_type === 'work' || d.connection_type === 'colleague') return 'professional';
  if (d.connection_type === 'community') return 'other';

  return 'other';
}

function getFamilySection(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return 'Extended Family';
  if (d.sub_role === 'spouse') return 'Spouse';
  if (d.sub_role === 'child') return 'Children';
  if (d.sub_role === 'parent' || d.sub_role === 'sibling' || d.sub_role === 'grandparent') return 'Parents & Siblings';
  return 'Extended Family';
}

function getParentsSiblingsSubSection(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return 'Siblings';
  if (d.sub_role === 'parent' || d.sub_role === 'grandparent') return 'Parents';
  return 'Siblings';
}

function getFriendsSection(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return 'Friends';
  var str = d.strength || 0;
  if (str >= 0.85) return 'Inner Circle';
  if (str >= 0.65) return 'Close Friends';
  if (str >= 0.40) return 'Friends';
  return 'Acquaintances';
}

function getProfessionalSection(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return 'Current';
  if (d.sub_role === 'partner') return 'Partners';
  if (d.status === 'active' || d.status === 'stable') return 'Current';
  return 'Former';
}

function getCardClasses(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return 'cat-card';
  var classes = 'cat-card';
  // Status overrides come first
  if (d.status === 'deceased') {
    return 'cat-card status-deceased';
  }
  if (d.sub_role === 'spouse' && d.status !== 'active' && d.status !== 'stable') {
    return 'cat-card status-former-spouse';
  }
  // Strength tier
  var tier = d.visual_tier || 'neutral';
  if (tier === 'gold') return 'cat-card tier-gold';
  if (tier === 'green') return 'cat-card tier-green';
  if (tier === 'muted') return 'cat-card tier-muted';
  return 'cat-card';
}

function getStatusPill(entity) {
  var d = entity.relationship_dimensions;
  if (!d) return '';
  if (d.status === 'deceased') return '<span class="cat-status-pill pill-deceased">In Memory</span>';
  if (d.sub_role === 'spouse' && d.status !== 'active' && d.status !== 'stable')
    return '<span class="cat-status-pill pill-former">Former</span>';
  if (d.sub_role === 'spouse' && (d.status === 'active' || d.status === 'stable'))
    return '<span class="cat-status-pill pill-current">Current</span>';
  if (d.status === 'complicated') return '<span class="cat-status-pill pill-complex">Complex</span>';
  return '';
}

function showGoldStar(entity) {
  var d = entity.relationship_dimensions;
  return d && d.visual_tier === 'gold';
}

function getCardSubtitle(entity) {
  var d = entity.relationship_dimensions;
  return (d && d.descriptor) || entity.descriptor || entity._relType || entity.summary || '';
}

function sortPeopleGroup(group, category) {
  // All sections: living first by strength desc, then deceased by strength desc
  if (category === 'family') {
    var rolePriority = { 'spouse': 1, 'child': 2, 'parent': 3, 'grandparent': 3, 'sibling': 4 };
    group.sort(function(a, b) {
      var da = a.relationship_dimensions || {};
      var db = b.relationship_dimensions || {};
      // Deceased sort after living
      var aDead = da.status === 'deceased' ? 1 : 0;
      var bDead = db.status === 'deceased' ? 1 : 0;
      if (aDead !== bDead) return aDead - bDead;
      var pa = rolePriority[da.sub_role] || 99;
      var pb = rolePriority[db.sub_role] || 99;
      if (pa !== pb) return pa - pb;
      var sa = da.strength || 0;
      var sb = db.strength || 0;
      if (sa !== sb) return sb - sa;
      return (a.name || '').localeCompare(b.name || '');
    });
  } else {
    // Friends, Professional, Other: living first, then deceased, each by strength desc
    group.sort(function(a, b) {
      var da = a.relationship_dimensions || {};
      var db = b.relationship_dimensions || {};
      var aDead = da.status === 'deceased' ? 1 : 0;
      var bDead = db.status === 'deceased' ? 1 : 0;
      if (aDead !== bDead) return aDead - bDead;
      var sa = da.strength || 0;
      var sb = db.strength || 0;
      if (sa !== sb) return sb - sa;
      return (a.name || '').localeCompare(b.name || '');
    });
  }
  return group;
}

function buildSidebarData() {
  var q = (document.getElementById('searchInput') || {}).value;
  q = (q || '').trim().toLowerCase();
  var isSearching = q.length > 0;

  // Build relationship map from primary entity (store raw data, not pre-categorized)
  var relMap = {};
  var primaryUserName = '';
  if (primaryEntityData && primaryEntityData.entity) {
    var pn = primaryEntityData.entity.name || {};
    primaryUserName = (pn.full || pn.preferred || '').toLowerCase().trim();
  }
  if (primaryEntityData && primaryEntityData.relationships) {
    var rels = primaryEntityData.relationships;
    for (var i = 0; i < rels.length; i++) {
      var rname = (rels[i].name || '').toLowerCase().trim();
      var entry = {
        type: rels[i].relationship_type || '',
        context: rels[i].context || '',
        strength: rels[i].strength || '',
        trust_level: rels[i].trust_level || ''
      };
      relMap[rname] = entry;
      // Also key by name without parentheticals: "Allen Jones (Big Al)" -> "allen jones"
      var stripped = rname.replace(/\\s*\\([^)]*\\)/g, '').trim();
      if (stripped && stripped !== rname) {
        relMap[stripped] = entry;
      }
    }
  }

  // Build role/credential maps from connected objects for org grouping
  var roleByOrg = {};   // orgName -> roleTitle (name-based)
  var credByOrg = {};   // orgName -> credLabel (name-based)
  var roleByOrgId = {}; // entity_id -> roleTitle (id-based, more reliable)
  var credByOrgId = {}; // entity_id -> credLabel (id-based, more reliable)
  var connectedIds = {}; // entity_id -> true (set of all connected object IDs)
  var connected = (primaryEntityData && primaryEntityData.connected_objects) || [];

  // First pass: index all connected objects by ID
  for (var i = 0; i < connected.length; i++) {
    connectedIds[connected[i].entity_id] = true;
  }

  // Second pass: build role and credential maps
  // For roles, find which org entity they reference by matching the org name
  for (var i = 0; i < connected.length; i++) {
    var c = connected[i];
    if (c.entity_type === 'role' && c.label) {
      var atIdx = c.label.indexOf(' at ');
      if (atIdx !== -1) {
        var orgName = c.label.substring(atIdx + 4).trim();
        var roleTitle = c.label.substring(0, atIdx).trim();
        roleByOrg[orgName.toLowerCase()] = roleTitle;
        // Find the connected org entity with this name and map by ID
        for (var j = 0; j < connected.length; j++) {
          var co = connected[j];
          if ((co.entity_type === 'organization' || co.entity_type === 'institution' || co.entity_type === 'business') && co.label) {
            if (co.label.toLowerCase().trim() === orgName.toLowerCase()) {
              roleByOrgId[co.entity_id] = roleTitle;
            }
          }
        }
      }
    }
    if (c.entity_type === 'credential' && c.label) {
      var commaIdx = c.label.indexOf(', ');
      if (commaIdx !== -1) {
        var instName = c.label.substring(commaIdx + 2).trim();
        credByOrg[instName.toLowerCase()] = c.label;
        // Find the connected org/institution entity with this name and map by ID
        for (var j = 0; j < connected.length; j++) {
          var co = connected[j];
          if ((co.entity_type === 'organization' || co.entity_type === 'institution' || co.entity_type === 'business') && co.label) {
            if (co.label.toLowerCase().trim() === instName.toLowerCase()) {
              credByOrgId[co.entity_id] = c.label;
            }
          }
        }
      }
    }
  }

  var you = null;
  var people = { family: [], friends: [], professional: [], community: [], other: [] };
  var organizations = { career: [], education: [], affiliations: [], services: [], other: [] };
  var projects = { active: [], rnd: [], archive: [] };
  var seenOrgNames = {}; // lowercase name -> entity_id (dedup: prefer connected objects)

  var src = isSearching ? entities : allEntities;
  for (var i = 0; i < src.length; i++) {
    var e = src[i];
    var t = e.entity_type;
    // Skip role/credential/skill from sidebar
    if (t === 'role' || t === 'credential' || t === 'skill') continue;

    // Filter out test entities
    var ename = (e.name || '');
    if (ename.match(/\\btest\\b/i) || ename.match(/\\bTestCorp\\b/i) || ename.match(/\\bBigTech\\b/i)) continue;

    if (e.entity_id === primaryEntityId) {
      you = e;
      continue;
    }
    if (t === 'person') {
      var elower = ename.toLowerCase().trim();

      // Step 1: Exact match in relMap
      var relEntry = relMap[elower] || null;

      // Step 2: Fuzzy match — strip parentheticals from entity name and try again
      if (!relEntry) {
        var eStripped = elower.replace(/\\s*\\([^)]*\\)/g, '').trim();
        if (eStripped !== elower) relEntry = relMap[eStripped] || null;
      }

      // Step 3: Fuzzy match — first+last name overlap
      if (!relEntry) {
        var eParts = elower.split(/\\s+/);
        if (eParts.length >= 2) {
          var eFirst = eParts[0];
          var eLast = eParts[eParts.length - 1];
          for (var rk in relMap) {
            if (rk.indexOf(eFirst) !== -1 && rk.indexOf(eLast) !== -1) {
              relEntry = relMap[rk];
              break;
            }
          }
          // Also try: relMap key first+last in entity name
          if (!relEntry) {
            for (var rk in relMap) {
              var rkParts = rk.split(/\\s+/);
              if (rkParts.length >= 2) {
                var rkFirst = rkParts[0];
                var rkLast = rkParts[rkParts.length - 1];
                if (elower.indexOf(rkFirst) !== -1 && elower.indexOf(rkLast) !== -1) {
                  relEntry = relMap[rk];
                  break;
                }
              }
            }
          }
        }
      }

      // Step 4: Reverse lookup — check if entity's own relationships mention the primary user
      if (!relEntry && e.relationships && primaryUserName) {
        var eRels = e.relationships;
        for (var ri = 0; ri < eRels.length; ri++) {
          var erName = (eRels[ri].name || '').toLowerCase();
          if (erName && primaryUserName.indexOf(erName) !== -1) {
            relEntry = { type: eRels[ri].relationship_type || '', context: eRels[ri].context || '', strength: '', trust_level: '' };
            break;
          }
          // Also fuzzy: first+last of rel name in primary user name
          var erParts = erName.split(/\\s+/);
          if (erParts.length >= 2) {
            if (primaryUserName.indexOf(erParts[0]) !== -1 && primaryUserName.indexOf(erParts[erParts.length - 1]) !== -1) {
              relEntry = { type: eRels[ri].relationship_type || '', context: eRels[ri].context || '', strength: '', trust_level: '' };
              break;
            }
          }
        }
      }

      // Categorize using dimension-reading functions
      var page = getPage(e);
      console.log('CAT_DEBUG:', ename, '->', page);

      // Set subtitle from descriptor
      e._relType = getCardSubtitle(e);

      if (people[page]) {
        people[page].push(e);
      } else {
        people.other.push(e);
      }
    } else if (t === 'organization' || t === 'business' || t === 'institution') {
      var oname = ename.toLowerCase().trim();

      // Dedup: skip if we already added an entity with this name
      // Prefer connected objects (which are processed first in allEntities)
      if (seenOrgNames[oname] && seenOrgNames[oname] !== e.entity_id) continue;
      seenOrgNames[oname] = e.entity_id;

      // Priority 1: Read org_category attribute (set by /api/cleanup-orgs)
      var orgCat = '';
      var orgRole = '';
      var orgDates = '';
      var orgCred = '';
      var orgGradYear = '';
      var eaList = e.attributes || [];
      for (var ai = 0; ai < eaList.length; ai++) {
        if (eaList[ai].key === 'org_category') orgCat = (eaList[ai].value || '').toLowerCase();
        if (eaList[ai].key === 'cj_role') orgRole = eaList[ai].value || '';
        if (eaList[ai].key === 'cj_dates') orgDates = eaList[ai].value || '';
        if (eaList[ai].key === 'cj_credential') orgCred = eaList[ai].value || '';
        if (eaList[ai].key === 'cj_grad_year') orgGradYear = eaList[ai].value || '';
      }

      // Build subtitle from attribute data
      var orgSubtitle = '';
      if (orgCat === 'career') {
        orgSubtitle = orgRole || roleByOrgId[e.entity_id] || roleByOrg[oname] || '';
        if (orgDates) orgSubtitle += (orgSubtitle ? ' (' + orgDates + ')' : orgDates);
      } else if (orgCat === 'education') {
        orgSubtitle = orgCred || credByOrgId[e.entity_id] || credByOrg[oname] || '';
        if (orgGradYear) orgSubtitle += (orgSubtitle ? ' (' + orgGradYear + ')' : orgGradYear);
      }

      if (orgCat === 'career' || orgCat === 'education' || orgCat === 'affiliations' || orgCat === 'services') {
        organizations[orgCat].push({ org: e, subtitle: orgSubtitle });
      } else {
        // Priority 2: Fallback to role/credential matching
        if (roleByOrgId[e.entity_id]) {
          organizations.career.push({ org: e, subtitle: roleByOrgId[e.entity_id] });
        } else if (credByOrgId[e.entity_id]) {
          organizations.education.push({ org: e, subtitle: credByOrgId[e.entity_id] });
        } else if (roleByOrg[oname]) {
          organizations.career.push({ org: e, subtitle: roleByOrg[oname] });
        } else if (credByOrg[oname]) {
          organizations.education.push({ org: e, subtitle: credByOrg[oname] });
        } else {
          // Fuzzy match
          var matched = false;
          for (var rk in roleByOrg) {
            if (oname.indexOf(rk) !== -1 || rk.indexOf(oname) !== -1) {
              organizations.career.push({ org: e, subtitle: roleByOrg[rk] });
              matched = true;
              break;
            }
          }
          if (!matched) {
            for (var ck in credByOrg) {
              if (oname.indexOf(ck) !== -1 || ck.indexOf(oname) !== -1) {
                organizations.education.push({ org: e, subtitle: credByOrg[ck] });
                matched = true;
                break;
              }
            }
          }
          if (!matched) {
            organizations.other.push({ org: e, subtitle: '' });
          }
        }
      }
    } else if (t === 'project') {
      projects.active.push(e);
    }
  }

  // Sort people groups
  sortPeopleGroup(people.family, 'family');
  sortPeopleGroup(people.friends, 'friends');
  sortPeopleGroup(people.professional, 'professional');
  sortPeopleGroup(people.community, 'community');
  sortPeopleGroup(people.other, 'other');

  // If not searching and primary not in allEntities, still show You if we have data
  if (!you && primaryEntityId && !isSearching) {
    for (var i = 0; i < allEntities.length; i++) {
      if (allEntities[i].entity_id === primaryEntityId) { you = allEntities[i]; break; }
    }
  }
  return { you: you, people: people, organizations: organizations, projects: projects };
}

function selectView(viewId) {
  if (!primaryEntityId) return;
  selectedId = primaryEntityId;
  selectedView = null;
  selectedCategory = null;
  // Map sidebar lens IDs to tab bar IDs
  var tabMap = { 'overview': 'overview', 'career': 'career', 'network-map': 'network', 'intelligence-brief': 'intel-brief', 'org-brief': 'org-brief', 'source-provenance': 'sources' };
  window._liActiveTab = tabMap[viewId] || 'overview';
  var mainEl = document.getElementById('main');
  if (mainEl) mainEl.className = '';
  breadcrumbs = [{ label: 'My Profile' }];
  var empty = document.getElementById('emptyState');
  if (empty) empty.style.display = 'none';

  var renderWithData = function(data) {
    selectedData = data;
    renderDetail(data);
  };

  if (primaryEntityData) {
    renderWithData(primaryEntityData);
  } else {
    api('GET', '/api/entity/' + primaryEntityId).then(function(data) {
      primaryEntityData = data;
      renderWithData(data);
    });
  }
  renderSidebar();
}

function renderSourceProvenance(data) {
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var prov = data.provenance_chain || {};
  var docs = prov.source_documents || [];
  var e = data.entity || {};
  var name = (e.name && (e.name.full || e.name.common || e.name.legal)) || '';
  var h = '';
  h += '<div style="padding:24px;">';
  h += '<h2 style="font-size:1.1rem;font-weight:700;margin-bottom:16px;">Source Provenance &mdash; ' + esc(name) + '</h2>';
  // Source documents
  if (docs.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Source Documents (' + docs.length + ')</div>';
    for (var i = 0; i < docs.length; i++) {
      var d = docs[i];
      h += '<div class="ov-source-row">';
      h += '<span class="ov-source-name">' + getSourceIcon(d.source || '') + ' ' + esc(d.source || 'Unknown') + '</span>';
      h += '<span style="font-size:0.72rem;color:var(--text-muted);">' + esc(d.ingested_at ? new Date(d.ingested_at).toLocaleDateString() : '') + '</span>';
      h += '</div>';
    }
    h += '</div>';
  }
  // Observations by source
  var bySrc = {};
  for (var i = 0; i < obs.length; i++) {
    var src = obs[i].source || 'unknown';
    if (!bySrc[src]) bySrc[src] = [];
    bySrc[src].push(obs[i]);
  }
  var srcKeys = Object.keys(bySrc);
  if (srcKeys.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Observations by Source</div>';
    for (var s = 0; s < srcKeys.length; s++) {
      var sk = srcKeys[s];
      var items = bySrc[sk];
      h += '<div style="margin-bottom:12px;">';
      h += '<div style="font-size:0.78rem;font-weight:600;color:var(--text-primary);margin-bottom:6px;">' + getSourceIcon(sk) + ' ' + esc(sk) + ' <span style="color:var(--text-muted);font-weight:400;">(' + items.length + ')</span></div>';
      for (var j = 0; j < items.length; j++) {
        var o = items[j];
        h += '<div style="font-size:0.78rem;color:var(--text-secondary);padding:4px 0 4px 16px;border-left:2px solid var(--border-primary);">';
        h += esc(o.observation || '');
        if (o.confidence) h += ' <span style="color:var(--text-muted);font-size:0.7rem;">(' + Math.round(o.confidence * 100) + '%)</span>';
        h += '</div>';
      }
      h += '</div>';
    }
    h += '</div>';
  }
  // Merge history
  var merges = (prov.merge_history || []);
  if (merges.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Merge History</div>';
    for (var i = 0; i < merges.length; i++) {
      var m = merges[i];
      h += '<div style="font-size:0.78rem;color:var(--text-secondary);padding:4px 0;">' + esc(JSON.stringify(m)) + '</div>';
    }
    h += '</div>';
  }
  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function renderNetworkMapPlaceholder(data) {
  var rels = data.relationships || [];
  var e = data.entity || {};
  var name = (e.name && (e.name.full || e.name.common || e.name.legal)) || '';
  var h = '<div style="padding:24px;">';
  h += '<h2 style="font-size:1.1rem;font-weight:700;margin-bottom:16px;">Network Map &mdash; ' + esc(name) + '</h2>';
  h += '<div style="font-size:0.85rem;color:var(--text-muted);margin-bottom:16px;">' + rels.length + ' connections mapped</div>';
  for (var i = 0; i < rels.length; i++) {
    var r = rels[i];
    h += '<div style="display:flex;align-items:center;gap:8px;padding:6px 0;border-bottom:1px solid var(--border-subtle);">';
    h += '<span style="font-size:0.82rem;font-weight:500;color:var(--text-primary);">' + esc(r.name || r.target_entity_id || '') + '</span>';
    h += '<span class="type-badge" style="font-size:0.65rem;">' + esc(r.relationship_type || '') + '</span>';
    if (r.confidence) h += '<span style="font-size:0.68rem;color:var(--text-muted);">' + Math.round(r.confidence * 100) + '%</span>';
    h += '</div>';
  }
  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function renderIntelligenceBriefPlaceholder(data) {
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var e = data.entity || {};
  var name = (e.name && (e.name.full || e.name.common)) || '';
  var h = '<div style="padding:24px;">';
  h += '<h2 style="font-size:1.1rem;font-weight:700;margin-bottom:16px;">Intelligence Brief &mdash; ' + esc(name) + '</h2>';
  h += '<div style="font-size:0.85rem;color:var(--text-muted);margin-bottom:16px;">' + obs.length + ' observations from multiple sources</div>';
  // Key observations grouped by theme
  for (var i = 0; i < Math.min(obs.length, 15); i++) {
    var o = obs[i];
    h += '<div style="padding:8px 12px;margin-bottom:6px;background:var(--bg-card);border:1px solid var(--border-primary);border-radius:var(--radius-sm);">';
    h += '<div style="font-size:0.82rem;color:var(--text-primary);">' + esc(o.observation || '') + '</div>';
    h += '<div style="font-size:0.68rem;color:var(--text-muted);margin-top:2px;">' + esc(o.source || '') + ' &middot; ' + esc(o.observed_at ? new Date(o.observed_at).toLocaleDateString() : '') + '</div>';
    h += '</div>';
  }
  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function selectCategoryPage(category) {
  // Redirect to People Hub with the appropriate tab
  var tabMap = { family: 'family', friends: 'friends', professional: 'professional', community: 'other', other: 'other' };
  showPeopleHub(tabMap[category] || 'all');
}

function renderPeopleCards(people, category) {
  var html = '';
  for (var i = 0; i < people.length; i++) {
    var p = people[i];
    var pName = p.name || '';
    var pSub = getCardSubtitle(p);
    var pSummary = (p.summary || '').substring(0, 120);
    if ((p.summary || '').length > 120) pSummary += '...';

    var cardClass = getCardClasses(p);
    var pillHtml = getStatusPill(p);
    var starHtml = showGoldStar(p) ? '<span class="cat-card-star">\u2605</span>' : '';

    // Keep star for deceased gold-tier entities
    var d = p.relationship_dimensions || {};
    if (d.status === 'deceased' && d.visual_tier === 'gold') {
      starHtml = '<span class="cat-card-star">\u2605</span>';
    }

    html += '<div class="' + cardClass + '" onclick="selectEntity(' + "'" + esc(p.entity_id) + "'" + ',' + "'" + category + "'" + ')">';
    if (pillHtml) html += pillHtml;
    html += '<div class="cat-card-name">' + esc(pName) + starHtml + '</div>';
    if (pSub) html += '<div class="cat-card-subtitle">' + esc(pSub) + '</div>';
    if (pSummary) html += '<div class="cat-card-summary">' + esc(pSummary) + '</div>';
    html += '</div>';
  }
  return html;
}

function renderSubSection(label, people, category) {
  if (people.length === 0) return '';
  var html = '<div class="cat-subsection">';
  html += '<div class="cat-subsection-label">' + esc(label) + ' (' + people.length + ')</div>';
  html += '<div class="cat-card-grid">';
  html += renderPeopleCards(people, category);
  html += '</div></div>';
  return html;
}

function renderParentsSiblingsSection(parentsSiblings, category) {
  if (parentsSiblings.length === 0) return '';
  // Split using sub_role from dimensions — no keyword matching
  var parents = [], siblings = [];
  for (var i = 0; i < parentsSiblings.length; i++) {
    var subSec = getParentsSiblingsSubSection(parentsSiblings[i]);
    if (subSec === 'Parents') parents.push(parentsSiblings[i]);
    else siblings.push(parentsSiblings[i]);
  }
  var html = '<div class="cat-subsection">';
  html += '<div class="cat-subsection-label">Parents & Siblings (' + parentsSiblings.length + ')</div>';
  if (parents.length > 0) {
    html += '<div class="cat-sub-divider">Parents (' + parents.length + ')</div>';
    html += '<div class="cat-card-grid">';
    html += renderPeopleCards(parents, category);
    html += '</div>';
  }
  if (siblings.length > 0) {
    html += '<div class="cat-sub-divider">Siblings (' + siblings.length + ')</div>';
    html += '<div class="cat-card-grid">';
    html += renderPeopleCards(siblings, category);
    html += '</div>';
  }
  html += '</div>';
  return html;
}

function renderCategoryPage(category, people) {
  var catMeta = {
    family: { emoji: '\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC66', label: 'Family' },
    friends: { emoji: '\uD83E\uDD1D', label: 'Friends' },
    professional: { emoji: '\uD83D\uDCBC', label: 'Professional' },
    community: { emoji: '\uD83C\uDFD8\uFE0F', label: 'Communities' },
    other: { emoji: '\uD83D\uDC65', label: 'Other' }
  };
  var meta = catMeta[category] || { emoji: '', label: category };
  var html = '<div style="padding: 24px 28px;">';
  html += '<div class="cat-page-header">' + meta.emoji + ' ' + esc(meta.label);
  html += '<span class="cat-page-count">&middot; ' + people.length + ' ' + (people.length === 1 ? 'person' : 'people') + '</span>';
  html += '</div>';

  if (category === 'family') {
    // Family sub-sections using getFamilySection() — pure dimension reads
    var spouse = [], children = [], parentsSiblings = [], extended = [];
    for (var i = 0; i < people.length; i++) {
      var section = getFamilySection(people[i]);
      if (section === 'Spouse') spouse.push(people[i]);
      else if (section === 'Children') children.push(people[i]);
      else if (section === 'Parents & Siblings') parentsSiblings.push(people[i]);
      else extended.push(people[i]);
    }
    // Sort: spouse active/stable first, then by strength
    spouse.sort(function(a, b) {
      var da = (a.relationship_dimensions || {});
      var db = (b.relationship_dimensions || {});
      var aActive = (da.status === 'active' || da.status === 'stable') ? 0 : 1;
      var bActive = (db.status === 'active' || db.status === 'stable') ? 0 : 1;
      if (aActive !== bActive) return aActive - bActive;
      return (db.strength || 0) - (da.strength || 0);
    });
    // Parents before grandparents, then by strength
    parentsSiblings.sort(function(a, b) {
      var da = (a.relationship_dimensions || {});
      var db = (b.relationship_dimensions || {});
      var rolePri = { 'parent': 1, 'grandparent': 2, 'sibling': 3 };
      var pa = rolePri[da.sub_role] || 99;
      var pb = rolePri[db.sub_role] || 99;
      if (pa !== pb) return pa - pb;
      return (db.strength || 0) - (da.strength || 0);
    });
    // Extended by strength descending
    extended.sort(function(a, b) {
      return ((b.relationship_dimensions || {}).strength || 0) - ((a.relationship_dimensions || {}).strength || 0);
    });
    html += renderSubSection('Spouse', spouse, category);
    html += renderSubSection('Children', children, category);
    html += renderParentsSiblingsSection(parentsSiblings, category);
    html += renderSubSection('Extended Family', extended, category);
  } else if (category === 'friends') {
    // Friends sub-sections using getFriendsSection()
    var innerCircle = [], closeFriends = [], friends = [], acquaintances = [];
    for (var i = 0; i < people.length; i++) {
      var section = getFriendsSection(people[i]);
      if (section === 'Inner Circle') innerCircle.push(people[i]);
      else if (section === 'Close Friends') closeFriends.push(people[i]);
      else if (section === 'Friends') friends.push(people[i]);
      else acquaintances.push(people[i]);
    }
    html += renderSubSection('Inner Circle', innerCircle, category);
    html += renderSubSection('Close Friends', closeFriends, category);
    html += renderSubSection('Friends', friends, category);
    html += renderSubSection('Acquaintances', acquaintances, category);
  } else if (category === 'professional') {
    // Professional sub-sections using getProfessionalSection()
    var partners = [], current = [], former = [];
    for (var i = 0; i < people.length; i++) {
      var section = getProfessionalSection(people[i]);
      if (section === 'Partners') partners.push(people[i]);
      else if (section === 'Current') current.push(people[i]);
      else former.push(people[i]);
    }
    html += renderSubSection('Partners', partners, category);
    html += renderSubSection('Current', current, category);
    html += renderSubSection('Former', former, category);
  } else {
    // Other / Community: flat grid sorted by strength
    html += '<div class="cat-card-grid">';
    html += renderPeopleCards(people, category);
    html += '</div>';
  }

  if (people.length === 0) {
    html += '<div style="padding:24px;color:var(--text-muted);text-align:center;">No people in this category</div>';
  }
  html += '</div>';
  document.getElementById('main').innerHTML = html;
}

// --- People Hub: Facebook-style tab navigation ---

var _peopleHubTab = 'all';
var _peopleHubSearch = '';

function showPeopleHub(tab) {
  _peopleHubTab = tab || _peopleHubTab || 'all';
  selectedCategory = 'people_hub';
  selectedId = null;
  selectedView = null;
  var empty = document.getElementById('emptyState');
  if (empty) empty.style.display = 'none';
  breadcrumbs = [];
  renderBreadcrumbs();
  renderPeopleHub();
  renderRightPanel(null);
  renderSidebar();
}

function renderPeopleHub() {
  var data = buildSidebarData();
  var allPeople = [];
  var cats = ['family', 'friends', 'professional', 'community', 'other'];
  for (var c = 0; c < cats.length; c++) {
    var items = data.people[cats[c]] || [];
    for (var i = 0; i < items.length; i++) {
      items[i]._peopleCategory = cats[c];
      allPeople.push(items[i]);
    }
  }

  // Count per tab
  var familyPeople = [], friendsPeople = [], proPeople = [], otherPeople = [];
  for (var i = 0; i < allPeople.length; i++) {
    var cat = allPeople[i]._peopleCategory;
    if (cat === 'family') familyPeople.push(allPeople[i]);
    else if (cat === 'friends') friendsPeople.push(allPeople[i]);
    else if (cat === 'professional') proPeople.push(allPeople[i]);
    else otherPeople.push(allPeople[i]);
  }

  var tabs = [
    { id: 'all', label: 'All', count: allPeople.length },
    { id: 'family', label: 'Family', count: familyPeople.length },
    { id: 'friends', label: 'Friends', count: friendsPeople.length },
    { id: 'professional', label: 'Professional', count: proPeople.length },
    { id: 'other', label: 'Other', count: otherPeople.length }
  ];

  var h = '<div class="people-hub">';

  // Header
  h += '<div class="people-hub-header">';
  h += '<div class="people-hub-title-row">';
  h += '<h1 class="people-hub-title"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg> People</h1>';
  h += '<span class="people-hub-count">' + allPeople.length + ' people</span>';
  h += '</div>';
  h += '<div class="people-hub-search-wrap">';
  h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>';
  h += '<input class="people-hub-search" id="peopleHubSearch" placeholder="Search people..." oninput="filterPeopleHub()" value="' + esc(_peopleHubSearch) + '" />';
  h += '</div></div>';

  // Tab bar
  h += '<div class="people-hub-tabs">';
  for (var t = 0; t < tabs.length; t++) {
    var tab = tabs[t];
    if (tab.id !== 'all' && tab.count === 0) continue;
    h += '<button class="people-hub-tab' + (tab.id === _peopleHubTab ? ' active' : '') + '" onclick="switchPeopleTab(\\'' + tab.id + '\\')">';
    h += esc(tab.label);
    h += '<span class="people-hub-tab-count">' + tab.count + '</span>';
    h += '</button>';
  }
  h += '</div>';

  // Content area
  h += '<div class="people-hub-content" id="peopleHubContent">';

  var searchQ = (_peopleHubSearch || '').toLowerCase().trim();
  var activePeople;

  if (_peopleHubTab === 'all') activePeople = allPeople;
  else if (_peopleHubTab === 'family') activePeople = familyPeople;
  else if (_peopleHubTab === 'friends') activePeople = friendsPeople;
  else if (_peopleHubTab === 'professional') activePeople = proPeople;
  else activePeople = otherPeople;

  // Filter by search
  if (searchQ) {
    activePeople = activePeople.filter(function(p) {
      return (p.name || '').toLowerCase().indexOf(searchQ) !== -1 ||
             (p.descriptor || '').toLowerCase().indexOf(searchQ) !== -1 ||
             (p.summary || '').toLowerCase().indexOf(searchQ) !== -1;
    });
  }

  if (activePeople.length === 0) {
    h += '<div class="people-hub-empty">' + (searchQ ? 'No people match your search' : 'No people in this category') + '</div>';
  } else if (_peopleHubTab === 'all') {
    h += renderPeopleHubAll(activePeople);
  } else if (_peopleHubTab === 'family') {
    h += renderPeopleHubFamily(activePeople);
  } else if (_peopleHubTab === 'friends') {
    h += renderPeopleHubFriends(activePeople);
  } else if (_peopleHubTab === 'professional') {
    h += renderPeopleHubProfessional(activePeople);
  } else {
    h += renderPeopleHubGeneric(activePeople);
  }

  h += '</div></div>';
  document.getElementById('main').innerHTML = h;

  // Focus search if it had text
  if (_peopleHubSearch) {
    var si = document.getElementById('peopleHubSearch');
    if (si) { si.focus(); si.setSelectionRange(si.value.length, si.value.length); }
  }
}

function switchPeopleTab(tab) {
  _peopleHubTab = tab;
  renderPeopleHub();
}

function filterPeopleHub() {
  var si = document.getElementById('peopleHubSearch');
  _peopleHubSearch = si ? si.value : '';
  renderPeopleHub();
}

// ALL tab: grouped by relationship tier
function renderPeopleHubAll(people) {
  var tierDefs = [
    { id: 5, label: 'Inner Circle', color: '#D4A017' },
    { id: 4, label: 'Close Friends', color: '#22c55e' },
    { id: 3, label: 'Friends', color: '#3b82f6' },
    { id: 2, label: 'Colleagues', color: '#6b7280' },
    { id: 1, label: 'Acquaintances', color: '#9ca3af' }
  ];
  var buckets = { 5: [], 4: [], 3: [], 2: [], 1: [] };
  for (var i = 0; i < people.length; i++) {
    var d = people[i].relationship_dimensions || {};
    var str = d.strength || 0;
    var tier;
    if (str >= 0.85) tier = 5;
    else if (str >= 0.65) tier = 4;
    else if (str >= 0.40) tier = 3;
    else if (str >= 0.20) tier = 2;
    else tier = 1;
    buckets[tier].push(people[i]);
  }
  var h = '';
  for (var t = 0; t < tierDefs.length; t++) {
    var td = tierDefs[t];
    var bucket = buckets[td.id];
    if (bucket.length === 0) continue;
    // Sort by strength descending
    bucket.sort(function(a, b) { return ((b.relationship_dimensions || {}).strength || 0) - ((a.relationship_dimensions || {}).strength || 0); });
    h += '<div class="people-hub-tier-section">';
    h += '<div class="people-hub-tier-label"><span class="people-hub-tier-dot" style="background:' + td.color + '"></span> ' + esc(td.label) + ' (' + bucket.length + ')</div>';
    h += '<div class="cat-card-grid">';
    h += renderPeopleCards(bucket, 'all');
    h += '</div></div>';
  }
  return h;
}

// FAMILY tab: sub-sections
function renderPeopleHubFamily(people) {
  var spouse = [], children = [], parentsSiblings = [], extended = [];
  for (var i = 0; i < people.length; i++) {
    var section = getFamilySection(people[i]);
    if (section === 'Spouse') spouse.push(people[i]);
    else if (section === 'Children') children.push(people[i]);
    else if (section === 'Parents & Siblings') parentsSiblings.push(people[i]);
    else extended.push(people[i]);
  }
  spouse.sort(function(a, b) {
    var da = (a.relationship_dimensions || {}); var db = (b.relationship_dimensions || {});
    var aActive = (da.status === 'active' || da.status === 'stable') ? 0 : 1;
    var bActive = (db.status === 'active' || db.status === 'stable') ? 0 : 1;
    if (aActive !== bActive) return aActive - bActive;
    return (db.strength || 0) - (da.strength || 0);
  });
  extended.sort(function(a, b) { return ((b.relationship_dimensions || {}).strength || 0) - ((a.relationship_dimensions || {}).strength || 0); });
  var h = '';
  h += renderSubSection('Spouse', spouse, 'family');
  h += renderSubSection('Children', children, 'family');
  h += renderParentsSiblingsSection(parentsSiblings, 'family');
  h += renderSubSection('Extended Family', extended, 'family');
  return h;
}

// FRIENDS tab: sub-sections by strength
function renderPeopleHubFriends(people) {
  var innerCircle = [], closeFriends = [], friends = [], acquaintances = [];
  for (var i = 0; i < people.length; i++) {
    var section = getFriendsSection(people[i]);
    if (section === 'Inner Circle') innerCircle.push(people[i]);
    else if (section === 'Close Friends') closeFriends.push(people[i]);
    else if (section === 'Friends') friends.push(people[i]);
    else acquaintances.push(people[i]);
  }
  var h = '';
  h += renderSubSection('Inner Circle', innerCircle, 'friends');
  h += renderSubSection('Close Friends', closeFriends, 'friends');
  h += renderSubSection('Friends', friends, 'friends');
  h += renderSubSection('Acquaintances', acquaintances, 'friends');
  return h;
}

// PROFESSIONAL tab: sub-sections
function renderPeopleHubProfessional(people) {
  var partners = [], current = [], former = [];
  for (var i = 0; i < people.length; i++) {
    var section = getProfessionalSection(people[i]);
    if (section === 'Partners') partners.push(people[i]);
    else if (section === 'Current') current.push(people[i]);
    else former.push(people[i]);
  }
  var h = '';
  h += renderSubSection('Business Partners', partners, 'professional');
  h += renderSubSection('Current Colleagues', current, 'professional');
  h += renderSubSection('Former Colleagues', former, 'professional');
  return h;
}

// OTHER/generic tab: flat grid sorted by strength
function renderPeopleHubGeneric(people) {
  people.sort(function(a, b) { return ((b.relationship_dimensions || {}).strength || 0) - ((a.relationship_dimensions || {}).strength || 0); });
  var h = '<div class="cat-card-grid">';
  h += renderPeopleCards(people, 'other');
  h += '</div>';
  return h;
}

// --- Affiliations Hub: tab navigation for organizations ---

var _affiliationsHubTab = 'all';
var _affiliationsHubSearch = '';

function showAffiliationsHub(tab) {
  _affiliationsHubTab = tab || _affiliationsHubTab || 'all';
  selectedCategory = 'affiliations_hub';
  selectedId = null;
  selectedView = null;
  var empty = document.getElementById('emptyState');
  if (empty) empty.style.display = 'none';
  breadcrumbs = [];
  renderBreadcrumbs();
  renderAffiliationsHub();
  renderRightPanel(null);
  renderSidebar();
}

function renderAffiliationsHub() {
  var data = buildSidebarData();
  var allOrgs = [];
  var cats = ['career', 'education', 'services', 'affiliations', 'other'];
  for (var c = 0; c < cats.length; c++) {
    var items = data.organizations[cats[c]] || [];
    for (var i = 0; i < items.length; i++) {
      items[i]._orgCategory = cats[c];
      allOrgs.push(items[i]);
    }
  }

  var careerOrgs = [], eduOrgs = [], svcOrgs = [], affOrgs = [], otherOrgs = [];
  for (var i = 0; i < allOrgs.length; i++) {
    var cat = allOrgs[i]._orgCategory;
    if (cat === 'career') careerOrgs.push(allOrgs[i]);
    else if (cat === 'education') eduOrgs.push(allOrgs[i]);
    else if (cat === 'services') svcOrgs.push(allOrgs[i]);
    else if (cat === 'affiliations') affOrgs.push(allOrgs[i]);
    else otherOrgs.push(allOrgs[i]);
  }

  var tabs = [
    { id: 'all', label: 'All', count: allOrgs.length },
    { id: 'career', label: 'Career', count: careerOrgs.length },
    { id: 'education', label: 'Education', count: eduOrgs.length },
    { id: 'services', label: 'Services', count: svcOrgs.length },
    { id: 'organizations', label: 'Organizations', count: affOrgs.length },
    { id: 'other', label: 'Other', count: otherOrgs.length }
  ];

  var h = '<div class="people-hub">';

  // Header
  h += '<div class="people-hub-header">';
  h += '<div class="people-hub-title-row">';
  h += '<h1 class="people-hub-title"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg> Affiliations</h1>';
  h += '<span class="people-hub-count">' + allOrgs.length + ' affiliations</span>';
  h += '</div>';
  h += '<div class="people-hub-search-wrap">';
  h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>';
  h += '<input class="people-hub-search" id="affiliationsHubSearch" placeholder="Search affiliations..." oninput="filterAffiliationsHub()" value="' + esc(_affiliationsHubSearch) + '" />';
  h += '</div></div>';

  // Tab bar
  h += '<div class="people-hub-tabs">';
  for (var t = 0; t < tabs.length; t++) {
    var tab = tabs[t];
    if (tab.id !== 'all' && tab.count === 0) continue;
    h += '<button class="people-hub-tab' + (tab.id === _affiliationsHubTab ? ' active' : '') + '" onclick="switchAffiliationsTab(\\'' + tab.id + '\\')">';
    h += esc(tab.label);
    h += '<span class="people-hub-tab-count">' + tab.count + '</span>';
    h += '</button>';
  }
  h += '</div>';

  // Content area
  h += '<div class="people-hub-content" id="affiliationsHubContent">';

  var searchQ = (_affiliationsHubSearch || '').toLowerCase().trim();
  var activeOrgs;

  if (_affiliationsHubTab === 'all') activeOrgs = allOrgs;
  else if (_affiliationsHubTab === 'career') activeOrgs = careerOrgs;
  else if (_affiliationsHubTab === 'education') activeOrgs = eduOrgs;
  else if (_affiliationsHubTab === 'services') activeOrgs = svcOrgs;
  else if (_affiliationsHubTab === 'organizations') activeOrgs = affOrgs;
  else activeOrgs = otherOrgs;

  // Filter by search
  if (searchQ) {
    activeOrgs = activeOrgs.filter(function(item) {
      var o = item.org || item;
      return (o.name || '').toLowerCase().indexOf(searchQ) !== -1 ||
             (item.subtitle || '').toLowerCase().indexOf(searchQ) !== -1 ||
             (o.summary || '').toLowerCase().indexOf(searchQ) !== -1;
    });
  }

  if (activeOrgs.length === 0) {
    h += '<div class="people-hub-empty">' + (searchQ ? 'No affiliations match your search' : 'No affiliations in this category') + '</div>';
  } else {
    h += '<div class="cat-card-grid">';
    for (var i = 0; i < activeOrgs.length; i++) {
      var item = activeOrgs[i];
      var o = item.org || item;
      var oName = o.name || '';
      var oSub = item.subtitle || '';
      var oSummary = (o.summary || '').substring(0, 140);
      if ((o.summary || '').length > 140) oSummary += '...';
      var oType = o.entity_type || '';
      var typeBadge = '';
      if (oType === 'institution') typeBadge = '<span style="font-size:0.7rem;background:#e0e7ff;color:#4338ca;padding:1px 6px;border-radius:8px;margin-left:6px;">Institution</span>';
      else if (oType === 'business') typeBadge = '<span style="font-size:0.7rem;background:#dcfce7;color:#166534;padding:1px 6px;border-radius:8px;margin-left:6px;">Business</span>';
      var cat = item._orgCategory || '';
      h += '<div class="cat-card" onclick="selectEntity(\\'' + esc(o.entity_id) + '\\',\\'org_' + cat + '\\')">';
      h += '<div class="cat-card-name">' + esc(oName) + typeBadge + '</div>';
      if (oSub) h += '<div class="cat-card-subtitle">' + esc(oSub) + '</div>';
      if (oSummary) h += '<div class="cat-card-summary">' + esc(oSummary) + '</div>';
      h += '</div>';
    }
    h += '</div>';
  }

  h += '</div></div>';
  document.getElementById('main').innerHTML = h;

  // Focus search if it had text
  if (_affiliationsHubSearch) {
    var si = document.getElementById('affiliationsHubSearch');
    if (si) { si.focus(); si.setSelectionRange(si.value.length, si.value.length); }
  }
}

function switchAffiliationsTab(tab) {
  _affiliationsHubTab = tab;
  renderAffiliationsHub();
}

function filterAffiliationsHub() {
  var si = document.getElementById('affiliationsHubSearch');
  _affiliationsHubSearch = si ? si.value : '';
  renderAffiliationsHub();
}

// --- Gap Analysis / Completeness Dashboard (MECE-019) ---
var _gapData = null;

function showCompletenessDashboard() {
  // Route through client workspace if a spoke is selected
  if (_selectedSpoke && _selectedSpoke !== 'default') {
    showClientWorkspace(_selectedSpoke, 'completeness');
    return;
  }
  selectedView = 'completeness';
  selectedId = null;
  selectedCategory = null;
  breadcrumbs = [{ label: 'Completeness' }];
  renderBreadcrumbs();
  renderSidebar();
  document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Loading gap analysis...</div>';
  var spokeParam = _selectedSpoke ? _selectedSpoke : '';
  if (!spokeParam) { document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Select a client first</div>'; return; }
  api('GET', '/api/spoke/' + encodeURIComponent(spokeParam) + '/gaps').then(function(data) {
    _gapData = data;
    renderCompletenessDashboard(data);
  }).catch(function(err) {
    // May need template assignment
    if (err.message && err.message.indexOf('No template') >= 0) {
      renderTemplateSelector();
    } else {
      document.getElementById('main').innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load gap analysis') + '</div>';
    }
  });
}

function renderTemplateSelector() {
  api('GET', '/api/templates').then(function(data) {
    var templates = data.templates || [];
    var h = '<div class="gap-dashboard"><div class="gap-dashboard-title">';
    h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>';
    h += ' Completeness Analysis</div>';
    h += '<p style="color:var(--text-muted);margin:16px 0 24px;">Select a matter type to begin analyzing completeness for this spoke.</p>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px;">';
    for (var i = 0; i < templates.length; i++) {
      var t = templates[i];
      h += '<div class="gap-missing-item" style="cursor:pointer;transition:border-color 0.15s;" onclick="setMatterType(\\'' + esc(t.id) + '\\')" onmouseover="this.style.borderColor=\\'#0a66c2\\'" onmouseout="this.style.borderColor=\\'#e0e0e0\\'">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#0a66c2" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(t.label) + '</div>';
      h += '<div class="gap-item-detail">' + t.category_count + ' categories &middot; ' + t.entity_roles + ' roles</div></div>';
      h += '</div>';
    }
    h += '</div></div>';
    document.getElementById('main').innerHTML = h;
  });
}

function setMatterType(templateType) {
  if (!_selectedSpoke) return;
  api('PUT', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/template', { template_type: templateType }).then(function() {
    // Refresh the analysis (works in both tab and standalone mode)
    refreshGapAnalysis();
  }).catch(function(err) {
    toast('Failed to set template: ' + (err.message || err));
  });
}

function refreshGapAnalysis() {
  if (!_selectedSpoke) return;
  // If in client workspace, refresh within the tab
  var container = document.getElementById('clientTabContent');
  if (container) {
    container.innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Analyzing completeness...</div>';
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/gaps?refresh=true').then(function(data) {
      _gapData = data;
      container.innerHTML = _buildCompletenessHtml(data);
      // Also refresh completeness dots in sidebar
      loadSpokes();
    }).catch(function(err) {
      container.innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Analysis failed') + '</div>';
    });
  } else {
    document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Analyzing completeness...</div>';
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/gaps?refresh=true').then(function(data) {
      _gapData = data;
      renderCompletenessDashboard(data);
      loadSpokes();
    }).catch(function(err) {
      document.getElementById('main').innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Analysis failed') + '</div>';
    });
  }
}

// Build 13: Generate document request email
function generateRequestEmail() {
  if (!_selectedSpoke) { toast('No client selected'); return; }

  // Find spoke name
  var spokeName = _selectedSpoke;
  for (var i = 0; i < _spokesList.length; i++) {
    if (_spokesList[i].id === _selectedSpoke) { spokeName = _spokesList[i].name; break; }
  }

  api('POST', '/api/spokes/' + encodeURIComponent(_selectedSpoke) + '/request-email', {
    client_name: spokeName,
    include_upload_link: true
  }).then(function(data) {
    // Show modal with email preview
    var overlay = document.createElement('div');
    overlay.id = 'emailModal';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:9999;';

    var mh = '<div style="background:#fff;border-radius:16px;padding:28px;max-width:600px;width:90%;max-height:85vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,0.3);">';
    mh += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">';
    mh += '<div style="font-size:18px;font-weight:700;">Document Request Email</div>';
    mh += '<button onclick="document.getElementById(\\'emailModal\\').remove()" style="border:none;background:none;font-size:24px;cursor:pointer;color:#999;padding:0 4px;">&times;</button>';
    mh += '</div>';

    // Subject line
    mh += '<div style="margin-bottom:16px;">';
    mh += '<label style="display:block;font-size:12px;font-weight:600;color:#555;margin-bottom:4px;">Subject</label>';
    mh += '<div style="padding:10px 14px;background:#f5f5f5;border-radius:8px;font-size:14px;">' + esc(data.subject || '') + '</div>';
    mh += '</div>';

    // Email body
    mh += '<div style="margin-bottom:20px;">';
    mh += '<label style="display:block;font-size:12px;font-weight:600;color:#555;margin-bottom:4px;">Email Body</label>';
    mh += '<pre id="emailBodyText" style="padding:16px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;font-size:13px;font-family:inherit;white-space:pre-wrap;word-wrap:break-word;line-height:1.6;max-height:300px;overflow-y:auto;">' + esc(data.body || '') + '</pre>';
    mh += '</div>';

    // Share URL
    if (data.share_url) {
      mh += '<div style="margin-bottom:20px;padding:12px 16px;background:#eff6ff;border-radius:8px;font-size:13px;">';
      mh += '<strong>Client Upload Link:</strong> <a href="' + esc(data.share_url) + '" target="_blank" style="color:#6366f1;word-break:break-all;">' + esc(data.share_url) + '</a>';
      mh += '</div>';
    }

    // Missing items count
    var items = data.missing_items || [];
    mh += '<div style="font-size:12px;color:var(--text-muted);margin-bottom:20px;">' + items.length + ' missing item' + (items.length !== 1 ? 's' : '') + ' included in request</div>';

    // Action buttons
    mh += '<div style="display:flex;gap:10px;">';
    mh += '<button onclick="copyEmailToClipboard()" style="flex:1;padding:10px;border:none;border-radius:8px;background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;font-size:13px;font-weight:600;cursor:pointer;">Copy to Clipboard</button>';
    if (data.mailto_link) {
      mh += '<a href="' + esc(data.mailto_link) + '" style="flex:1;padding:10px;border:1px solid #e5e7eb;border-radius:8px;text-align:center;text-decoration:none;color:#333;font-size:13px;font-weight:600;display:flex;align-items:center;justify-content:center;">Open in Email</a>';
    }
    mh += '</div>';
    mh += '</div>';

    overlay.innerHTML = mh;
    document.body.appendChild(overlay);
    overlay.addEventListener('click', function(e) { if (e.target === overlay) overlay.remove(); });
  }).catch(function(err) {
    toast('Error generating email: ' + (err.message || err));
  });
}

function copyEmailToClipboard() {
  var el = document.getElementById('emailBodyText');
  if (!el) return;
  var text = el.textContent || el.innerText;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(function() { toast('Email copied to clipboard'); });
  } else {
    // Fallback
    var ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    toast('Email copied to clipboard');
  }
}

function _gapScoreColor(score) {
  if (score >= 0.8) return '#16A34A';
  if (score >= 0.5) return '#CA8A04';
  return '#DC2626';
}

function _gapFormatLabel(item) {
  return (item || '').replace(/_/g, ' ').replace(/\\b[a-z]/g, function(l) { return l.toUpperCase(); });
}

function renderCompletenessDashboard(data) {
  var pct = Math.round((data.overall_score || 0) * 100);
  var color = _gapScoreColor(data.overall_score || 0);
  var h = '<div class="gap-dashboard">';

  // Header
  h += '<div class="gap-dashboard-header">';
  h += '<div class="gap-dashboard-title">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>';
  h += ' ' + esc(data.template_name || 'Completeness') + '</div>';
  h += '<div class="gap-dashboard-controls">';
  h += '<select id="gapTemplateSelect" onchange="setMatterType(this.value)">';
  // Load templates list inline
  h += '<option value="' + esc(data.template_type || '') + '">' + esc(data.template_name || '') + '</option>';
  h += '</select>';
  h += '<button onclick="refreshGapAnalysis()">Refresh Analysis</button>';
  h += '</div></div>';

  // Score ring + bars
  h += '<div class="gap-ring-container">';
  var deg = Math.round(pct * 3.6);
  h += '<div class="gap-ring" style="background: conic-gradient(' + color + ' 0deg, ' + color + ' ' + deg + 'deg, #e8e8e8 ' + deg + 'deg);">';
  h += '<div class="gap-ring-label" style="background:#fff;width:140px;height:140px;border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;">';
  h += '<div class="gap-ring-pct" style="color:' + color + ';">' + pct + '%</div>';
  h += '<div class="gap-ring-sub">Complete</div>';
  h += '</div></div>';

  // Score bars
  h += '<div class="gap-score-bars">';
  var bars = [
    { label: 'Documents', score: data.document_score || 0, weight: '40%' },
    { label: 'Entities', score: data.entity_score || 0, weight: '40%' },
    { label: 'Relationships', score: data.relationship_score || 0, weight: '20%' }
  ];
  for (var b = 0; b < bars.length; b++) {
    var bar = bars[b];
    var bPct = Math.round(bar.score * 100);
    var bColor = _gapScoreColor(bar.score);
    h += '<div class="gap-score-bar">';
    h += '<div class="gap-score-bar-header"><span>' + bar.label + ' <span style="color:var(--text-muted);font-size:11px;">(' + bar.weight + ' weight)</span></span><span style="font-weight:600;color:' + bColor + ';">' + bPct + '%</span></div>';
    h += '<div class="gap-score-bar-track"><div class="gap-score-bar-fill" style="width:' + bPct + '%;background:' + bColor + ';"></div></div>';
    h += '</div>';
  }
  h += '</div></div>';

  // Missing Documents
  var missingDocs = data.missing_documents || [];
  if (missingDocs.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#DC2626" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> Missing Documents (' + missingDocs.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var d = 0; d < missingDocs.length; d++) {
      var doc = missingDocs[d];
      h += '<div class="gap-missing-item">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(doc.item)) + '</div>';
      h += '<div class="gap-item-detail">' + esc(_gapFormatLabel(doc.category)) + '</div></div>';
      h += '<span class="gap-priority-badge ' + (doc.priority || 'medium') + '">' + (doc.priority || 'medium') + '</span>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  // Missing Entity Fields
  var missingFields = data.missing_entity_fields || [];
  if (missingFields.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#CA8A04" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg> Missing Entity Fields (' + missingFields.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var f = 0; f < missingFields.length; f++) {
      var field = missingFields[f];
      h += '<div class="gap-missing-item">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(field.missing)) + '</div>';
      h += '<div class="gap-item-detail">' + esc(_gapFormatLabel(field.role)) + (field.entity ? ' &middot; ' + esc(field.entity) : '') + '</div></div>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  // Missing Relationships
  var missingRels = data.missing_relationships || [];
  if (missingRels.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#7C3AED" stroke-width="2"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg> Missing Relationships (' + missingRels.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var r = 0; r < missingRels.length; r++) {
      var rel = missingRels[r];
      h += '<div class="gap-missing-item">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(rel.expected)) + '</div>';
      h += '<div class="gap-item-detail">Expected connection</div></div>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  // Found Documents
  var foundDocs = data.found_documents || [];
  if (foundDocs.length > 0) {
    h += '<div class="gap-found-section">';
    h += '<div class="gap-category-title" style="color:#065F46;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#16A34A" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Found Documents (' + foundDocs.length + ')</div>';
    h += '<div>';
    for (var fd = 0; fd < foundDocs.length; fd++) {
      var fdoc = foundDocs[fd];
      h += '<span class="gap-found-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> ' + esc(_gapFormatLabel(fdoc.item)) + '</span>';
    }
    h += '</div></div>';
  }

  // Suggestions
  var suggestions = data.suggestions || [];
  if (suggestions.length > 0) {
    h += '<div class="gap-suggestions">';
    h += '<div class="gap-suggestions-title">Suggested Next Steps</div>';
    h += '<ul>';
    for (var s = 0; s < suggestions.length; s++) {
      h += '<li>' + esc(suggestions[s]) + '</li>';
    }
    h += '</ul></div>';
  }

  // Meta
  h += '<div style="margin-top:20px;font-size:11px;color:var(--text-muted);">';
  h += (data.entity_count || 0) + ' entities &middot; ' + (data.source_documents || []).length + ' source documents';
  if (data.cached) h += ' &middot; <span style="color:#CA8A04;">cached</span>';
  if (data.analyzed_at) h += ' &middot; analyzed ' + new Date(data.analyzed_at).toLocaleString();
  h += '</div>';

  h += '</div>';
  document.getElementById('main').innerHTML = h;

  // Populate template selector async
  api('GET', '/api/templates').then(function(tData) {
    var sel = document.getElementById('gapTemplateSelect');
    if (!sel) return;
    var templates = tData.templates || [];
    sel.innerHTML = '';
    for (var i = 0; i < templates.length; i++) {
      var opt = document.createElement('option');
      opt.value = templates[i].id;
      opt.textContent = templates[i].label;
      if (templates[i].id === data.template_type) opt.selected = true;
      sel.appendChild(opt);
    }
  });
}

function selectOrgCategoryPage(category) {
  selectedCategory = 'org_' + category;
  selectedId = null;
  selectedView = null;
  var empty = document.getElementById('emptyState');
  if (empty) empty.style.display = 'none';
  var catLabels = { career: 'Career', education: 'Education', affiliations: 'Affiliations', services: 'Services', other: 'Other' };
  breadcrumbs = [
    { label: 'Affiliations', action: 'showAffiliationsHub()' },
    { label: catLabels[category] || category }
  ];
  renderBreadcrumbs();
  var data = buildSidebarData();
  var orgs = data.organizations[category] || [];
  renderOrgCategoryPage(category, orgs);
  renderRightPanel(null);
  renderSidebar();
}

function renderOrgCategoryPage(category, orgs) {
  var catMeta = {
    career: { emoji: '\uD83D\uDCBC', label: 'Career' },
    education: { emoji: '\uD83C\uDF93', label: 'Education' },
    affiliations: { emoji: '\uD83E\uDD1D', label: 'Affiliations' },
    services: { emoji: '\uD83C\uDFE6', label: 'Services' },
    other: { emoji: '\uD83C\uDFE2', label: 'Other' }
  };
  var meta = catMeta[category] || { emoji: '', label: category };
  var html = '<div style="padding: 24px 28px;">';
  html += '<div class="cat-page-header">' + meta.emoji + ' ' + esc(meta.label);
  html += '<span class="cat-page-count">&middot; ' + orgs.length + ' ' + (orgs.length === 1 ? 'affiliation' : 'affiliations') + '</span>';
  html += '</div>';
  html += '<div class="cat-card-grid">';
  for (var i = 0; i < orgs.length; i++) {
    var item = orgs[i];
    var o = item.org || item;
    var oName = o.name || '';
    var oSub = item.subtitle || '';
    var oSummary = (o.summary || '').substring(0, 140);
    if ((o.summary || '').length > 140) oSummary += '...';
    var oType = o.entity_type || '';
    var typeBadge = '';
    if (oType === 'institution') typeBadge = '<span style="font-size:0.7rem;background:#e0e7ff;color:#4338ca;padding:1px 6px;border-radius:8px;margin-left:6px;">Institution</span>';
    else if (oType === 'business') typeBadge = '<span style="font-size:0.7rem;background:#dcfce7;color:#166534;padding:1px 6px;border-radius:8px;margin-left:6px;">Business</span>';
    html += '<div class="cat-card" onclick="selectEntity(' + "'" + esc(o.entity_id) + "'" + ',' + "'" + 'org_' + category + "'" + ')">';
    html += '<div class="cat-card-name">' + esc(oName) + typeBadge + '</div>';
    if (oSub) html += '<div class="cat-card-subtitle">' + esc(oSub) + '</div>';
    if (oSummary) html += '<div class="cat-card-summary">' + esc(oSummary) + '</div>';
    html += '</div>';
  }
  html += '</div>';
  if (orgs.length === 0) {
    html += '<div style="padding:24px;color:var(--text-muted);text-align:center;">No affiliations in this category</div>';
  }
  html += '</div>';
  document.getElementById('main').innerHTML = html;
}

function renderProfileOverview(data) {
  var e = data.entity || {};
  var cl = data.career_lite || {};
  var name = (e.name && (e.name.full || e.name.preferred || e.name.common)) || '';
  var summary = (e.summary && e.summary.value) || '';
  var attrs = data.attributes || [];
  var connected = data.connected_objects || [];
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var rels = data.relationships || [];
  var prov = data.provenance_chain || {};

  // Build attribute map
  var attrMap = {};
  for (var i = 0; i < attrs.length; i++) {
    attrMap[attrs[i].key] = String(attrs[i].value || '');
  }
  var headline = attrMap['headline'] || '';
  var location = attrMap['location'] || cl.location || '';

  // Count connected objects by type
  var connCounts = {};
  for (var i = 0; i < connected.length; i++) {
    var ct = connected[i].entity_type;
    connCounts[ct] = (connCounts[ct] || 0) + 1;
  }

  var h = '';

  // ===== 1. HERO CARD =====
  h += '<div class="hero-card"><div class="hero-top">';
  h += '<div class="hero-avatar">';
  if (sessionUser && sessionUser.picture) {
    h += '<img src="' + esc(sessionUser.picture) + '" alt="" />';
  } else {
    var initials = name.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
    h += initials;
  }
  h += '</div>';
  h += '<div class="hero-info">';
  h += '<div class="hero-name-row"><span class="hero-name">' + esc(name) + '</span>' + renderTierBadge(e.entity_id) + renderDensityBadge(data) + '</div>';
  if (headline) h += '<div class="hero-headline">' + esc(headline) + '</div>';
  if (cl.current_role && cl.current_company) {
    h += '<div class="hero-current">' + esc(cl.current_role) + ' at ' + esc(cl.current_company) + '</div>';
  }
  if (location) h += '<div class="hero-location"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg> ' + esc(location) + '</div>';
  // Contact row
  var contactItems = [];
  if (attrMap['email']) contactItems.push('<span class="hero-contact-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg> ' + esc(attrMap['email']) + '</span>');
  if (attrMap['phone']) contactItems.push('<span class="hero-contact-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72c.127.96.361 1.903.7 2.81a2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45c.907.339 1.85.573 2.81.7A2 2 0 0 1 22 16.92z"></path></svg> ' + esc(attrMap['phone']) + '</span>');
  if (attrMap['x_handle']) contactItems.push('<span class="hero-contact-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg> ' + esc(attrMap['x_handle']) + '</span>');
  if (contactItems.length > 0) {
    h += '<div class="hero-contact-row">' + contactItems.join('') + '</div>';
  }
  h += '</div></div></div>';

  // ===== 2. DATA COVERAGE DASHBOARD =====
  var hasWorkHistory = cl.experience && cl.experience.length > 0;
  var hasSkills = (cl.skills && cl.skills.length > 0) || !!attrMap['skills'];
  var hasEducation = cl.education && cl.education.length > 0;
  var hasLinkedIn = !!cl.linkedin_url || !!attrMap['linkedin_url'];
  if (!hasLinkedIn && prov.source_documents) {
    for (var i = 0; i < prov.source_documents.length; i++) {
      if ((prov.source_documents[i].source || '').indexOf('linkedin') !== -1) { hasLinkedIn = true; break; }
    }
  }
  var hasXHandle = !!attrMap['x_handle'] || !!attrMap['x_url'];
  var hasInstagram = !!attrMap['instagram_handle'] || !!attrMap['instagram_url'];
  var hasYouTube = false;
  if (cl.experience) {
    for (var i = 0; i < cl.experience.length; i++) {
      if ((cl.experience[i].company || '').toLowerCase().indexOf('youtube') !== -1 ||
          (cl.experience[i].title || '').toLowerCase().indexOf('youtube') !== -1 ||
          (cl.experience[i].company || '').toLowerCase().indexOf('putchuon') !== -1) {
        hasYouTube = true; break;
      }
    }
  }
  var hasLocation = !!location;
  var hasFamilyConns = false;
  var hasFriendConns = false;
  var famTypes = ['spouse', 'son', 'daughter', 'sister', 'brother', 'parent', 'mother', 'father', 'ex-spouse'];
  for (var i = 0; i < rels.length; i++) {
    var rt = (rels[i].relationship_type || '').toLowerCase();
    for (var f = 0; f < famTypes.length; f++) {
      if (rt.indexOf(famTypes[f]) !== -1) { hasFamilyConns = true; break; }
    }
    if (rt.indexOf('friend') !== -1) hasFriendConns = true;
  }
  var hasObservations = obs.length > 0;
  var hasPersonality = !!attrMap['personality'];
  var hasValues = data.values && data.values.length > 0;

  // Count filled vs total for coverage percentage
  var allChecks = [hasWorkHistory, hasSkills, hasEducation, hasLinkedIn, hasXHandle, hasInstagram, hasYouTube, hasLocation, hasFamilyConns, hasFriendConns, hasObservations, hasPersonality, hasValues];
  var filledCount = 0;
  for (var i = 0; i < allChecks.length; i++) { if (allChecks[i]) filledCount++; }
  var coveragePct = Math.round(filledCount / allChecks.length * 100);

  function covItem(has, label) {
    return '<div class="ov-coverage-item"><div class="ov-coverage-dot ' + (has ? 'filled' : 'empty') + '"></div>' + esc(label) + '</div>';
  }

  h += '<div class="ov-section">';
  h += '<div class="ov-section-title">Data Coverage <span style="float:right;color:#6366f1;font-weight:800;">' + coveragePct + '%</span></div>';
  h += '<div class="ov-coverage-grid">';
  h += '<div class="ov-coverage-cat"><div class="ov-coverage-cat-title">Professional</div>';
  h += covItem(hasWorkHistory, 'Work History');
  h += covItem(hasSkills, 'Skills');
  h += covItem(hasEducation, 'Education');
  h += covItem(hasLinkedIn, 'LinkedIn');
  h += '</div>';
  h += '<div class="ov-coverage-cat"><div class="ov-coverage-cat-title">Social</div>';
  h += covItem(hasXHandle, 'X / Twitter');
  h += covItem(hasInstagram, 'Instagram');
  h += covItem(hasYouTube, 'YouTube');
  h += '</div>';
  h += '<div class="ov-coverage-cat"><div class="ov-coverage-cat-title">Personal</div>';
  h += covItem(hasLocation, 'Location');
  h += covItem(hasFamilyConns, 'Family');
  h += covItem(hasFriendConns, 'Friends');
  h += '</div>';
  h += '<div class="ov-coverage-cat"><div class="ov-coverage-cat-title">Intelligence</div>';
  h += covItem(hasObservations, 'Observations (' + obs.length + ')');
  h += covItem(hasPersonality, 'Personality');
  h += covItem(hasValues, 'Values');
  h += '</div>';
  h += '</div></div>';

  // ===== 3. RECENT ACTIVITY =====
  if (obs.length > 0) {
    var recentObs = obs.slice(0, 10);
    h += '<div class="ov-section">';
    h += '<div class="ov-section-title">Recent Activity <span style="float:right;font-weight:400;text-transform:none;letter-spacing:0;">showing ' + recentObs.length + ' of ' + obs.length + '</span></div>';
    for (var i = 0; i < recentObs.length; i++) {
      var o = recentObs[i];
      var decay = calcDecay(o.observed_at);
      h += '<div class="ov-activity-item" style="opacity:' + Math.max(0.55, decay).toFixed(2) + '">';
      h += '<div class="ov-activity-dot"></div>';
      h += '<div style="flex:1;min-width:0;">';
      h += '<div class="ov-activity-text">' + esc(o.observation) + '</div>';
      h += '<div class="ov-activity-meta">';
      h += '<span>' + esc((o.observed_at || '').slice(0, 10)) + '</span>';
      if (o.source) h += '<span>' + esc(o.source) + '</span>';
      h += confidenceBadge(o.confidence, o.confidence_label);
      h += '</div></div></div>';
    }
    h += '</div>';
  }

  // ===== 4. ENTITY STATS =====
  var totalEntities = allEntities.length;
  var peopleCount = 0, orgCount = 0;
  for (var i = 0; i < allEntities.length; i++) {
    var et = allEntities[i].entity_type || '';
    if (et === 'person') peopleCount++;
    else if (et === 'organization' || et === 'business' || et === 'institution') orgCount++;
  }
  // Tier breakdown
  var innerIds = {};
  for (var i = 0; i < rels.length; i++) {
    var rName = (rels[i].name || '').toLowerCase();
    for (var j = 0; j < allEntities.length; j++) {
      if ((allEntities[j].name || '').toLowerCase() === rName) {
        innerIds[allEntities[j].entity_id] = true;
      }
    }
  }
  for (var i = 0; i < connected.length; i++) {
    if (connected[i].entity_id) innerIds[connected[i].entity_id] = true;
  }
  var selfCount = 1;
  var innerCount = Object.keys(innerIds).length;
  var outerCount = Math.max(0, totalEntities - selfCount - innerCount);

  h += '<div class="ov-section">';
  h += '<div class="ov-section-title">Entity Stats</div>';
  h += '<div class="ov-stat-grid">';
  var statCards = [
    { v: totalEntities, l: 'Total' },
    { v: peopleCount, l: 'People' },
    { v: orgCount, l: 'Orgs' },
    { v: rels.length, l: 'Connections' }
  ];
  for (var i = 0; i < statCards.length; i++) {
    h += '<div class="ov-stat-card"><div class="ov-stat-value">' + statCards[i].v + '</div><div class="ov-stat-label">' + statCards[i].l + '</div></div>';
  }
  h += '</div>';
  // Tier breakdown bar
  var tierTotal = selfCount + innerCount + outerCount;
  if (tierTotal > 0) {
    var selfPct = Math.round(selfCount / tierTotal * 100);
    var innerPct = Math.round(innerCount / tierTotal * 100);
    var outerPct = Math.max(0, 100 - selfPct - innerPct);
    h += '<div class="ov-tier-bar">';
    if (selfPct > 0) h += '<div style="width:' + selfPct + '%;background:#8b5cf6;" title="Self: ' + selfCount + '"></div>';
    if (innerPct > 0) h += '<div style="width:' + innerPct + '%;background:#6366f1;" title="Inner: ' + innerCount + '"></div>';
    if (outerPct > 0) h += '<div style="width:' + outerPct + '%;background:var(--bg-tertiary);" title="Outer: ' + outerCount + '"></div>';
    h += '</div>';
    h += '<div class="ov-tier-legend">';
    h += '<span><span class="ov-tier-dot" style="background:#8b5cf6;"></span>Self (' + selfCount + ')</span>';
    h += '<span><span class="ov-tier-dot" style="background:#6366f1;"></span>Inner (' + innerCount + ')</span>';
    h += '<span><span class="ov-tier-dot" style="background:var(--bg-tertiary);border:1px solid var(--border-primary);"></span>Outer (' + outerCount + ')</span>';
    h += '</div>';
  }
  h += '</div>';

  // ===== 5. CONNECTED ENTITIES PREVIEW =====
  var sortedRels = rels.slice().sort(function(a, b) {
    var ca = (a.confidence || 0), cb = (b.confidence || 0);
    if (cb !== ca) return cb - ca;
    return (b.context || '').length - (a.context || '').length;
  });
  var topRels = sortedRels.slice(0, 5);
  if (topRels.length > 0) {
    h += '<div class="ov-section">';
    h += '<div class="ov-section-title">Strongest Connections</div>';
    h += '<div class="ov-conn-grid">';
    for (var i = 0; i < topRels.length; i++) {
      var r = topRels[i];
      var rInit = (r.name || '').split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
      h += '<div class="ov-conn-card">';
      h += '<div class="ov-conn-avatar">' + rInit + '</div>';
      h += '<div class="ov-conn-info">';
      h += '<div class="ov-conn-name">' + esc(r.name) + '</div>';
      h += '<div class="ov-conn-type">' + esc(r.relationship_type || '') + '</div>';
      h += '</div>';
      if (r.confidence) h += confidenceBadge(r.confidence, r.confidence_label);
      h += '</div>';
    }
    h += '</div></div>';
  }

  // ===== 6. EXTRACTION SOURCES =====
  var sourceCounts = {};
  for (var i = 0; i < obs.length; i++) {
    var src = obs[i].source || 'unknown';
    var srcKey = src.split(':')[0];
    sourceCounts[srcKey] = (sourceCounts[srcKey] || 0) + 1;
  }
  if (prov.source_documents) {
    for (var i = 0; i < prov.source_documents.length; i++) {
      var ps = prov.source_documents[i].source || '';
      var psKey = ps.split(':')[0];
      if (psKey && !sourceCounts[psKey]) sourceCounts[psKey] = 0;
    }
  }
  var sourceKeys = Object.keys(sourceCounts);
  if (sourceKeys.length > 0) {
    sourceKeys.sort(function(a, b) { return sourceCounts[b] - sourceCounts[a]; });
    h += '<div class="ov-section">';
    h += '<div class="ov-section-title">Extraction Sources</div>';
    for (var i = 0; i < sourceKeys.length; i++) {
      var sk = sourceKeys[i];
      h += '<div class="ov-source-row">';
      h += '<div class="ov-source-name">' + getSourceIcon(sk) + ' ' + esc(getSourceLabel(sk)) + '</div>';
      h += '<div class="ov-source-count">' + sourceCounts[sk] + ' obs</div>';
      h += '</div>';
    }
    h += '</div>';
  }

  document.getElementById('main').innerHTML = h;
}

function renderOverview(data) {
  var e = data.entity || {};
  var type = e.entity_type || '';
  if (['role', 'organization', 'credential', 'skill'].indexOf(type) !== -1) {
    return renderConnectedDetail(data);
  }
  var name = type === 'person' ? (e.name?.full || '') : (e.name?.common || e.name?.legal || '');
  var summary = e.summary?.value || '';
  var meta = data.extraction_metadata || {};
  var h = '';

  h += '<div class="detail-header">';
  h += '<h2>' + esc(name) + '</h2>';
  h += '<span class="type-badge ' + type + '">' + type + '</span>';
  h += '<span class="entity-id-badge">' + esc(e.entity_id || '') + '</span>';
  h += confidenceBadge(meta.extraction_confidence);
  h += '</div>';

  h += '<div class="section">';
  h += '<div class="section-header"><span class="section-title">Summary</span>';
  h += '<button class="btn-sm" id="btnEditSummary" onclick="toggleSummaryEdit()">Edit</button></div>';
  h += '<div id="summaryDisplay" class="summary-text">' + esc(summary) + '</div>';
  h += '<div id="summaryEditSection" style="display:none">';
  h += '<textarea class="summary-edit" id="summaryEdit">' + esc(summary) + '</textarea>';
  h += '<div class="edit-actions"><button class="btn-save" onclick="saveSummary()">Save</button>';
  h += '<button class="btn-cancel" onclick="toggleSummaryEdit()">Cancel</button></div>';
  h += '</div></div>';

  var attrs = data.attributes || [];
  if (attrs.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Attributes</div>';
    for (var i = 0; i < attrs.length; i++) {
      var a = attrs[i];
      h += '<div class="attr-row"><span class="attr-key">' + esc(a.key) + '</span>';
      h += '<span class="attr-value">' + esc(String(a.value || '')) + '</span>';
      h += confidenceBadge(a.confidence, a.confidence_label);
      h += '</div>';
    }
    h += '</div>';
  }

  var rels = data.relationships || [];
  if (rels.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Relationships</div>';
    for (var i = 0; i < rels.length; i++) {
      var r = rels[i];
      h += '<div class="rel-row"><span class="rel-name">' + esc(r.name) + '</span>';
      h += '<span class="rel-type">' + esc(r.relationship_type || '') + '</span>';
      if (r.context) h += '<span class="rel-context">' + esc(r.context) + '</span>';
      h += sentimentBadge(r.sentiment);
      h += confidenceBadge(r.confidence, r.confidence_label);
      h += '</div>';
    }
    h += '</div>';
  }

  var vals = data.values || [];
  if (vals.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Values</div>';
    for (var i = 0; i < vals.length; i++) {
      h += '<div class="value-item"><span class="value-text">' + esc(vals[i].value || '') + '</span>';
      h += confidenceBadge(vals[i].confidence, vals[i].confidence_label);
      h += '</div>';
    }
    h += '</div>';
  }

  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  h += '<div class="section"><div class="section-title section-title-only">Observations (' + obs.length + ')</div>';
  if (obs.length === 0) {
    h += '<div style="color:#3a3a4a;font-size:0.82rem;padding:8px 0;">No observations yet</div>';
  }
  for (var i = 0; i < obs.length; i++) {
    var o = obs[i];
    var decay = calcDecay(o.observed_at);
    var opacity = Math.max(0.35, decay);
    h += '<div class="obs-card" style="opacity:' + opacity.toFixed(2) + '">';
    h += '<div class="obs-text">' + esc(o.observation) + '</div>';
    h += '<div class="obs-meta">';
    h += confidenceBadge(o.confidence, o.confidence_label);
    h += layerBadge(o.layer_number);
    if (o.source) h += '<span class="obs-source">' + esc(o.source) + '</span>';
    h += '<span class="obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</span>';
    h += '<span class="obs-decay">' + (decay * 100).toFixed(0) + '% weight</span>';
    h += '<button class="btn-delete" data-id="' + esc(o.observation_id || '') + '" onclick="deleteObs(this.dataset.id)">delete</button>';
    h += '</div></div>';
  }
  h += '</div>';

  var connected = data.connected_objects || [];
  if (connected.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Connected Objects (' + connected.length + ')</div>';
    var groups = { role: [], organization: [], institution: [], credential: [], skill: [] };
    for (var i = 0; i < connected.length; i++) {
      var c = connected[i];
      if (groups[c.entity_type]) groups[c.entity_type].push(c);
    }
    var groupLabels = { role: 'Roles', organization: 'Affiliations', institution: 'Institutions', credential: 'Credentials', skill: 'Skills' };
    var groupKeys = ['role', 'organization', 'institution', 'credential', 'skill'];
    for (var g = 0; g < groupKeys.length; g++) {
      var gk = groupKeys[g];
      var items = groups[gk];
      if (items.length === 0) continue;
      h += '<div style="margin-bottom:12px;"><div style="font-size:0.75rem;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.04em;margin-bottom:4px;">' + groupLabels[gk] + '</div>';
      for (var j = 0; j < items.length; j++) {
        h += '<div class="entity-item" style="padding:6px 10px;cursor:pointer;" onclick="selectEntity(' + "'" + esc(items[j].entity_id) + "'" + ')">';
        h += '<span class="entity-item-name">' + esc(items[j].label) + '</span>';
        h += '<span class="type-badge ' + esc(items[j].entity_type) + '">' + esc(items[j].entity_type) + '</span>';
        h += '</div>';
      }
      h += '</div>';
    }
    h += '</div>';
  }

  h += '<div class="section"><div class="section-title section-title-only">Add Observation</div>';
  h += '<div class="add-obs-form">';
  h += '<textarea class="obs-textarea" id="obsText" placeholder="What did you learn about this entity?"></textarea>';
  h += '<div class="obs-form-row">';
  h += '<select id="obsConfidence"><option value="VERIFIED">Verified</option>';
  h += '<option value="STRONG" selected>Strong</option><option value="MODERATE">Moderate</option>';
  h += '<option value="SPECULATIVE">Speculative</option><option value="UNCERTAIN">Uncertain</option></select>';
  h += '<select id="obsLayer"><option value="L1_OBJECTIVE">L1 Objective</option>';
  h += '<option value="L2_GROUP" selected>L2 Group</option><option value="L3_PERSONAL">L3 Personal</option></select>';
  h += '<button class="btn-add" id="btnAddObs" onclick="addObs()">Add Observation</button>';
  h += '</div></div></div>';

  document.getElementById('main').innerHTML = h;
}



function toggleProfileSection(id) {
  var body = document.getElementById('profile-sec-' + id);
  if (!body) return;
  var header = body.previousElementSibling;
  if (body.classList.contains('hidden')) {
    body.classList.remove('hidden');
    if (header) header.classList.remove('collapsed');
  } else {
    body.classList.add('hidden');
    if (header) header.classList.add('collapsed');
  }
}

// Capture OAuth session token from URL and store in sessionStorage
(function() {
  var params = new URLSearchParams(window.location.search);
  var sessionToken = params.get('session');
  if (sessionToken) {
    sessionStorage.setItem('ca_token', sessionToken);
    history.replaceState(null, '', '/wiki');
  }
})();

function getAuthHeaders() {
  var headers = { 'X-Agent-Id': 'wiki-dashboard' };
  if (apiKey) {
    headers['X-Context-API-Key'] = apiKey;
  } else {
    var token = sessionStorage.getItem('ca_token');
    if (token) headers['Authorization'] = 'Bearer ' + token;
  }
  return headers;
}

function api(method, path, body) {
  var opts = {
    method: method,
    headers: getAuthHeaders(),
  };
  if (body) {
    opts.headers['Content-Type'] = 'application/json';
    opts.body = JSON.stringify(body);
  }
  return fetch(path, opts).then(function(r) {
    if (!r.ok) return r.json().then(function(e) { throw new Error(e.error || 'Request failed'); });
    return r.json();
  });
}

function toast(msg) {
  var el = document.getElementById('toast');
  el.textContent = msg; el.classList.add('active');
  setTimeout(function() { el.classList.remove('active'); }, 2000);
}

function enterApp(user) {
  sessionUser = user;
  document.getElementById('login-screen').style.display = 'none';
  document.getElementById('app').style.display = 'flex';

  // Set up bottom user info
  if (user && user.name) {
    document.getElementById('userInfo').textContent = user.name;
    document.getElementById('logoutLink').innerHTML = '<a href="#" onclick="logout();return false;" style="color:#999;font-size:12px;text-decoration:none;">Logout</a>';
    var driveBtn = document.getElementById('btnDrive');
    if (driveBtn) driveBtn.style.display = 'inline';
    var driveSepEl = document.getElementById('driveSep');
    if (driveSepEl) driveSepEl.style.display = 'inline';
    // User avatar
    var avatarEl = document.getElementById('userAvatar');
    if (user.picture) {
      avatarEl.innerHTML = '<img src="' + esc(user.picture) + '" alt="" />';
    } else {
      var initials = user.name.split(/\\s+/).map(function(w) { return w[0]; }).join('').toUpperCase().slice(0, 2);
      avatarEl.textContent = initials;
    }
  }

  // Check if URL has a deep-link path (e.g. /wiki/entity/:id/connections)
  var connMatch = window.location.pathname.match(/\\/wiki\\/entity\\/([^\\/]+)\\/connections/);

  function handleInitialRoute() {
    if (connMatch) {
      var deepEntityId = decodeURIComponent(connMatch[1]);
      selectEntity(deepEntityId);
      // Wait a tick for selectedData to load, then show connections
      setTimeout(function() { if (selectedData) showConnectionsPage(deepEntityId); }, 300);
    }
  }

  // Two-phase load: fetch tenant config first, then all entities
  api('GET', '/api/tenant/config').then(function(config) {
    return api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      // Use self_entity_id from tenant config; fall back to name-matching
      primaryEntityId = (config && config.self_entity_id) || findPrimaryUser(allEntities, sessionUser);
      if (primaryEntityId) {
        return api('GET', '/api/entity/' + primaryEntityId).then(function(fullData) {
          primaryEntityData = fullData;
          renderSidebar();
          if (connMatch) { handleInitialRoute(); } else { selectView('overview'); }
        });
      } else {
        renderSidebar();
        handleInitialRoute();
      }
    });
  }).catch(function() {
    // Fallback if tenant/config fails
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      primaryEntityId = findPrimaryUser(allEntities, sessionUser);
      if (primaryEntityId) {
        return api('GET', '/api/entity/' + primaryEntityId).then(function(fullData) {
          primaryEntityData = fullData;
          renderSidebar();
          if (connMatch) { handleInitialRoute(); } else { selectView('overview'); }
        });
      } else {
        renderSidebar();
        handleInitialRoute();
      }
    });
  });
  // Load review queue badge count
  refreshReviewQueueBadge();
  // Load spoke list (clients) and templates
  loadSpokes();
  loadTemplates();
}

function logout() {
  sessionStorage.removeItem('ca_token');
  fetch('/auth/logout', { method: 'POST' }).then(function() {
    window.location.reload();
  });
}

/* --- Login --- */
// Auto-login: check for existing session (Bearer token from sessionStorage)
(function() {
  var token = sessionStorage.getItem('ca_token');
  if (!token) return; // No token — show login screen
  fetch('/auth/me', { headers: { 'Authorization': 'Bearer ' + token } }).then(function(r) {
    if (r.ok) return r.json();
    throw new Error('auth failed: ' + r.status);
  }).then(function(user) {
    if (user && user.tenant_id) {
      enterApp(user);
    }
  }).catch(function(err) {
    sessionStorage.removeItem('ca_token');
  });
})();

// Manual API key login
function login() {
  apiKey = document.getElementById('apiKeyInput').value.trim();
  if (!apiKey) return;
  document.getElementById('btnLogin').disabled = true;
  api('GET', '/api/search?q=*').then(function(data) {
    allEntities = data.results || [];
    entities = allEntities.slice();
    document.getElementById('login-screen').style.display = 'none';
    document.getElementById('app').style.display = 'flex';
    renderSidebar();
    loadSpokes();
    loadTemplates();
  }).catch(function(err) {
    var el = document.getElementById('loginError');
    el.textContent = err.message; el.classList.add('active');
    document.getElementById('btnLogin').disabled = false;
  });
}
document.getElementById('apiKeyInput').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') login();
});

/* --- Sidebar --- */
function isQuestion(q) {
  var lower = q.toLowerCase().trim();
  if (q.includes('?')) return true;
  if (/^(who|what|how|tell me|describe|summarize|profile|list all|count|show all|find all|which|any)\\b/.test(lower)) return true;
  return false;
}

function onSearch(immediate) {
  clearTimeout(searchTimeout);
  var delay = immediate ? 0 : 250;
  searchTimeout = setTimeout(function() {
    var q = document.getElementById('searchInput').value.trim();
    if (!q) {
      // Empty search — restore all entities and clear search state
      entities = allEntities.slice();
      renderSidebar();
      // Restore previous main panel state
      if (selectedCategory) {
        selectCategoryPage(selectedCategory);
      } else if (selectedId) {
        selectEntity(selectedId);
      } else {
        breadcrumbs = [];
        renderBreadcrumbs();
        var empty = document.getElementById('emptyState');
        if (empty) empty.style.display = '';
      }
      return;
    }

    // Route to query engine if this looks like a question
    if (isQuestion(q)) {
      selectedCategory = null;
      selectedId = null;
      selectedView = null;
      breadcrumbs = [{ label: 'Query: ' + q }];
      renderBreadcrumbs();
      document.getElementById('main').innerHTML = '<div style="padding:24px 28px;color:var(--text-muted);">Thinking...</div>';
      api('GET', '/api/query?q=' + encodeURIComponent(q) + spokeParam()).then(function(data) {
        renderQueryResult(data, q);
      }).catch(function(err) {
        document.getElementById('main').innerHTML = '<div style="padding:24px 28px;color:#c0392b;">Query failed: ' + esc(err.message || 'Unknown error') + '</div>';
      });
      return;
    }

    var url = '/api/search?q=' + encodeURIComponent(q) + spokeParam();
    api('GET', url).then(function(data) {
      var results = data.results || [];
      entities = results;
      selectedCategory = null;
      selectedId = null;
      selectedView = null;
      breadcrumbs = [{ label: 'Search: ' + q }];
      renderBreadcrumbs();
      renderSearchResults(results, q);
      renderSidebar();
    });
  }, delay);
}

function renderSearchResults(results, query) {
  var html = '<div style="padding: 24px 28px;">';
  html += '<div class="cat-page-header">';
  html += 'Search results for ' + "'" + esc(query) + "'";
  html += '<span class="cat-page-count">&middot; ' + results.length + ' ' + (results.length === 1 ? 'result' : 'results') + '</span>';
  html += '</div>';
  if (results.length === 0) {
    html += '<div style="padding:24px;color:var(--text-muted);text-align:center;">No results found</div>';
  } else {
    html += '<div class="cat-card-grid">';
    for (var i = 0; i < results.length; i++) {
      var r = results[i];
      var rName = r.name || r.entity_id || '';
      var rType = r.entity_type || '';
      var rSummary = (r.summary || '').substring(0, 120);
      if ((r.summary || '').length > 120) rSummary += '...';
      html += '<div class="cat-card" onclick="selectEntity(' + "'" + esc(r.entity_id) + "'" + ')">';
      html += '<div class="cat-card-name">' + esc(rName) + ' <span class="type-badge ' + rType + '">' + esc(rType) + '</span></div>';
      if (rSummary) html += '<div class="cat-card-summary">' + esc(rSummary) + '</div>';
      html += '</div>';
    }
    html += '</div>';
  }
  html += '</div>';
  document.getElementById('main').innerHTML = html;
}

function renderQueryResult(data, question) {
  var html = '<div style="padding: 24px 28px;">';

  // Header
  html += '<div class="cat-page-header" style="margin-bottom:16px;">';
  html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:middle;margin-right:8px;"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>';
  html += esc(question);
  html += '<span class="type-badge" style="margin-left:8px;font-size:11px;background:var(--bg-surface);padding:2px 8px;border-radius:4px;">' + esc(data.query.type) + '</span>';
  html += '</div>';

  // Answer card
  html += '<div style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:20px;margin-bottom:16px;">';
  html += '<div style="font-size:15px;line-height:1.6;color:var(--text-primary);">' + esc(data.answer) + '</div>';
  if (data.confidence > 0) {
    var confPct = Math.round(data.confidence * 100);
    var confColor = confPct >= 80 ? '#27ae60' : confPct >= 50 ? '#f39c12' : '#c0392b';
    html += '<div style="margin-top:12px;font-size:12px;color:var(--text-muted);">Confidence: <span style="color:' + confColor + ';font-weight:600;">' + confPct + '%</span>';
    html += ' &middot; ' + data.timing.total_ms + 'ms</div>';
  }
  html += '</div>';

  // Paths (for RELATIONSHIP queries)
  if (data.paths && data.paths.length > 0) {
    html += '<div style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:20px;margin-bottom:16px;">';
    html += '<div style="font-weight:600;margin-bottom:12px;font-size:14px;">Connection Paths</div>';
    for (var p = 0; p < data.paths.length && p < 3; p++) {
      var path = data.paths[p];
      html += '<div style="padding:8px 0;border-top:1px solid var(--border);font-size:13px;">';
      html += '<span style="color:var(--text-muted);">Path ' + (p + 1) + ' (' + path.hops + ' hop' + (path.hops !== 1 ? 's' : '') + '):</span> ';
      for (var s = 0; s < path.path.length; s++) {
        var step = path.path[s];
        if (s > 0) html += ' <span style="color:var(--text-muted);">' + esc(step.relationship) + ' &rarr;</span> ';
        html += '<strong>' + esc(step.entity) + '</strong>';
      }
      html += '</div>';
    }
    html += '</div>';
  }

  // Entity cards
  if (data.entities && data.entities.length > 0) {
    html += '<div style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:20px;margin-bottom:16px;">';
    html += '<div style="font-weight:600;margin-bottom:12px;font-size:14px;">Entities (' + data.entities.length + ')</div>';
    html += '<div class="cat-card-grid">';
    var maxCards = Math.min(data.entities.length, 12);
    for (var i = 0; i < maxCards; i++) {
      var ent = data.entities[i];
      var entId = ent.id || '';
      var entName = ent.name || entId;
      var entType = ent.type || ent.role || '';
      html += '<div class="cat-card"' + (entId ? ' onclick="selectEntity(\\'' + esc(entId) + '\\')"' : '') + ' style="cursor:' + (entId ? 'pointer' : 'default') + ';">';
      html += '<div class="cat-card-name">' + esc(entName);
      if (entType) html += ' <span class="type-badge ' + esc(entType) + '">' + esc(entType) + '</span>';
      html += '</div></div>';
    }
    if (data.entities.length > 12) {
      html += '<div style="padding:8px;color:var(--text-muted);font-size:12px;">and ' + (data.entities.length - 12) + ' more...</div>';
    }
    html += '</div></div>';
  }

  // Gaps (for COMPLETENESS queries)
  if (data.gaps && data.gaps.length > 0) {
    html += '<div style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:20px;margin-bottom:16px;">';
    html += '<div style="font-weight:600;margin-bottom:12px;font-size:14px;">Gaps Found (' + data.gaps.length + ')</div>';
    for (var g = 0; g < data.gaps.length; g++) {
      var gap = data.gaps[g];
      html += '<div style="padding:6px 0;font-size:13px;border-top:1px solid var(--border);">';
      html += '<span style="font-weight:500;">' + esc(gap.field) + '</span>';
      html += ' &mdash; <span style="color:var(--text-muted);">' + esc(gap.status) + '</span>';
      if (gap.suggestion) html += ' <span style="color:#2980b9;">(' + esc(gap.suggestion) + ')</span>';
      html += '</div>';
    }
    html += '</div>';
  }

  // Conflicts (for CONTRADICTION queries)
  if (data.conflicts && data.conflicts.length > 0) {
    html += '<div style="background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:20px;margin-bottom:16px;">';
    html += '<div style="font-weight:600;margin-bottom:12px;font-size:14px;color:#c0392b;">Conflicts (' + data.conflicts.length + ')</div>';
    for (var c = 0; c < data.conflicts.length; c++) {
      var conflict = data.conflicts[c];
      html += '<div style="padding:6px 0;font-size:13px;border-top:1px solid var(--border);">';
      html += '<span style="font-weight:500;">' + esc(conflict.field || conflict.type || 'conflict') + '</span>';
      if (conflict.values) {
        html += ': ';
        for (var v = 0; v < conflict.values.length; v++) {
          if (v > 0) html += ' vs ';
          html += '<em>' + esc(String(conflict.values[v].value || '')) + '</em>';
        }
      }
      html += '</div>';
    }
    html += '</div>';
  }

  html += '</div>';
  document.getElementById('main').innerHTML = html;
}

function promptSetSelfEntity() {
  var name = prompt('Enter the name of your primary entity (e.g., your name):');
  if (!name) return;
  // Search for the entity
  api('GET', '/api/search?q=' + encodeURIComponent(name)).then(function(data) {
    var results = data.results || [];
    if (results.length === 0) { alert('No entity found matching "' + name + '"'); return; }
    var entity = results[0];
    var entName = entity.name || entity.entity_id;
    if (!confirm('Set "' + entName + '" as your primary user?')) return;
    api('POST', '/api/self-entity', { entity_id: entity.entity_id, entity_name: entName }).then(function() {
      primaryEntityId = entity.entity_id;
      api('GET', '/api/entity/' + entity.entity_id).then(function(fullData) {
        primaryEntityData = fullData;
        renderSidebar();
        selectView('overview');
      });
    });
  });
}

// --- Export View (Build 6 — card-based layout) ---
var _exportData = null;
var _expandedEvidence = {};

function showExportView() {
  // Route through client workspace if a spoke is selected
  if (_selectedSpoke && _selectedSpoke !== 'default') {
    showClientWorkspace(_selectedSpoke, 'export');
    return;
  }
  selectedView = 'export';
  selectedId = null;
  selectedCategory = null;
  _expandedEvidence = {};
  breadcrumbs = [{ label: 'Export View' }];
  renderBreadcrumbs();
  renderSidebar();
  document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Loading export data...</div>';
  var spokeParam = _selectedSpoke ? _selectedSpoke : '';
  if (!spokeParam) { document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Select a client first</div>'; return; }
  api('GET', '/api/spoke/' + encodeURIComponent(spokeParam) + '/export').then(function(data) {
    _exportData = data;
    renderExportView(data);
  }).catch(function(err) {
    if (err.message && err.message.indexOf('No template') >= 0) {
      document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Assign a template first via Completeness dashboard.</div>';
    } else {
      document.getElementById('main').innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load export data') + '</div>';
    }
  });
}

function _exportBadgeHtml(status) {
  var labels = { verified: 'Verified', low_confidence: 'Low Confidence', conflict: 'Conflict', missing: 'Missing' };
  return '<span class="export-badge ' + esc(status) + '">' + (labels[status] || status) + '</span>';
}

function _exportFormatLabel(item) {
  return (item || '').replace(/_/g, ' ').replace(/\\b[a-z]/g, function(l) { return l.toUpperCase(); });
}

function _exportRoleIcon(role) {
  if (role === 'business_entity') return '<div class="export-role-icon org"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></div>';
  return '<div class="export-role-icon person"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg></div>';
}

function renderExportView(data) {
  var s = data.summary || {};
  var h = '<div class="export-view">';

  // Header — matches gap-dashboard-header style
  h += '<div class="export-header">';
  h += '<div class="export-title">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>';
  h += ' ' + esc(data.spoke_name || 'Export') + ' — Data Export</div>';
  h += '<button class="export-btn-csv" onclick="downloadExportCsv()">';
  h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
  h += ' Download CSV</button>';
  h += '</div>';

  // Summary stats
  h += '<div class="export-summary">';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#191919;">' + (s.total_fields || 0) + '</div> Total</div>';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#16A34A;">' + (s.verified || 0) + '</div> Verified</div>';
  if (s.low_confidence) h += '<div class="export-stat"><div class="export-stat-count" style="color:#CA8A04;">' + s.low_confidence + '</div> Low Conf</div>';
  if (s.conflicts) h += '<div class="export-stat"><div class="export-stat-count" style="color:#DC2626;">' + s.conflicts + '</div> Conflicts</div>';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#6B7280;">' + (s.missing || 0) + '</div> Missing</div>';
  h += '</div>';

  // Role cards
  var roles = data.roles || [];
  for (var ri = 0; ri < roles.length; ri++) {
    var role = roles[ri];
    var roleVerified = 0, roleTotal = 0;
    for (var ei = 0; ei < (role.entities || []).length; ei++) {
      for (var fi = 0; fi < (role.entities[ei].fields || []).length; fi++) {
        roleTotal++;
        if (role.entities[ei].fields[fi].status === 'verified') roleVerified++;
      }
    }
    var allComplete = (roleVerified === roleTotal && roleTotal > 0);

    h += '<div class="export-role-card">';
    // Card header
    h += '<div class="export-role-header" onclick="toggleExportRole(' + ri + ')">';
    h += _exportRoleIcon(role.role);
    h += '<span class="export-role-name">' + esc(_exportFormatLabel(role.role)) + '</span>';
    h += '<span class="export-role-count' + (allComplete ? ' complete' : '') + '">' + roleVerified + '/' + roleTotal + ' fields</span>';
    h += '<span class="export-role-chevron" id="exportChevron' + ri + '"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></span>';
    h += '</div>';

    // Card body
    h += '<div class="export-role-body" id="exportBody' + ri + '">';

    var hasEntities = role.entities && role.entities.length > 0 && !(role.entities.length === 1 && !role.entities[0].entity_id);

    if (!hasEntities) {
      h += '<div class="export-not-found">No matching entity found for this role</div>';
      // Still show missing fields
      if (role.entities && role.entities[0]) {
        for (var fi = 0; fi < (role.entities[0].fields || []).length; fi++) {
          var f = role.entities[0].fields[fi];
          h += '<div class="export-field-row missing">';
          h += '<div class="export-field-label">' + esc(_exportFormatLabel(f.field)) + '</div>';
          h += '<div class="export-field-value empty">—</div>';
          h += '<div class="export-field-meta">' + _exportBadgeHtml('missing') + '</div>';
          h += '</div>';
        }
      }
    } else {
      for (var ei = 0; ei < role.entities.length; ei++) {
        var ent = role.entities[ei];
        // Entity sub-header if multiple entities
        if (role.entities.length > 1) {
          h += '<div class="export-entity-header">';
          h += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
          h += esc(ent.entity_name || '');
          h += '</div>';
        }

        for (var fi = 0; fi < (ent.fields || []).length; fi++) {
          var f = ent.fields[fi];
          var isMissing = f.status === 'missing';
          var evidKey = ri + '_' + ei + '_' + fi;

          h += '<div class="export-field-row' + (isMissing ? ' missing' : '') + '">';
          h += '<div class="export-field-label">' + esc(_exportFormatLabel(f.field)) + '</div>';

          // Value
          if (f.value) {
            h += '<div class="export-field-value">' + esc(String(f.value)) + '</div>';
          } else {
            h += '<div class="export-field-value empty">—</div>';
          }

          // Meta: badge + source pill
          h += '<div class="export-field-meta">';
          h += _exportBadgeHtml(f.status);
          if (f.provenance && f.provenance.filename) {
            h += '<span class="export-source-pill" onclick="toggleExportEvidence(event,\\''+evidKey+'\\','+ri+','+ei+','+fi+')">';
            h += '<svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> ';
            h += esc(f.provenance.filename);
            h += '</span>';
          }
          h += '</div>';
          h += '</div>';

          // Inline evidence expand area (hidden by default)
          h += '<div id="exportEvid_' + evidKey + '" style="display:none;"></div>';
        }
      }
    }

    h += '</div></div>';
  }

  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function toggleExportRole(idx) {
  var body = document.getElementById('exportBody' + idx);
  var chevron = document.getElementById('exportChevron' + idx);
  if (!body) return;
  var isCollapsed = body.classList.contains('collapsed');
  if (isCollapsed) {
    body.classList.remove('collapsed');
    if (chevron) chevron.classList.remove('collapsed');
  } else {
    body.classList.add('collapsed');
    if (chevron) chevron.classList.add('collapsed');
  }
}

function toggleExportEvidence(event, key, ri, ei, fi) {
  event.stopPropagation();
  var el = document.getElementById('exportEvid_' + key);
  if (!el) return;

  // Toggle off
  if (el.style.display !== 'none') {
    el.style.display = 'none';
    el.innerHTML = '';
    return;
  }

  if (!_exportData) return;
  var f = _exportData.roles[ri].entities[ei].fields[fi];
  if (!f || !f.provenance) return;
  var prov = f.provenance;

  var html = '<div class="export-evidence-inline">';
  if (prov.snippet) {
    html += '<div class="snippet-text">&ldquo;' + esc(prov.snippet) + '&rdquo;</div>';
  }
  html += '<div class="export-evidence-meta">';
  if (prov.location) html += 'Location: <span>' + esc(prov.location) + '</span> &middot; ';
  html += 'File: <span>' + esc(prov.filename) + '</span>';
  if (prov.file_id && _selectedSpoke) {
    html += ' &middot; <a class="export-btn-view-original" href="/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/file/' + encodeURIComponent(prov.file_id) + '" target="_blank">';
    html += '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>';
    html += ' View Original</a>';
  }
  html += '</div>';

  // Conflict sources
  if (f.status === 'conflict' && f.all_sources && f.all_sources.length > 1) {
    html += '<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(0,0,0,0.1);">';
    html += '<div style="font-weight:600;font-size:11px;color:#991B1B;margin-bottom:4px;">Conflicting Sources</div>';
    for (var si = 0; si < f.all_sources.length; si++) {
      var src = f.all_sources[si];
      html += '<div style="font-size:11px;padding:3px 0;">';
      html += '<strong>' + esc(src.filename || '') + '</strong>';
      if (src.snippet) html += ' — <em>&ldquo;' + esc(src.snippet) + '&rdquo;</em>';
      html += '</div>';
    }
    html += '</div>';
  }

  html += '</div>';
  el.innerHTML = html;
  el.style.display = 'block';
}

function downloadExportCsv() {
  if (!_selectedSpoke) return;
  var url = '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/export?format=csv';
  // Use fetch with auth headers then trigger download
  fetch(url, { headers: getAuthHeaders() })
    .then(function(resp) {
      if (!resp.ok) throw new Error('Download failed');
      return resp.blob();
    })
    .then(function(blob) {
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (_exportData && _exportData.spoke_name ? _exportData.spoke_name.replace(/[^a-zA-Z0-9 ]/g, '') : 'export') + '-export.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    })
    .catch(function(err) { toast('CSV download failed: ' + err.message); });
}

// --- Spoke Share Manager (Build 7) ---

var _spokeShares = [];

function showSpokeShareManager() {
  // Route through client workspace if a spoke is selected
  if (_selectedSpoke && _selectedSpoke !== 'default') {
    showClientWorkspace(_selectedSpoke, 'share');
    return;
  }
  selectedView = 'share_portal';
  selectedId = null;
  selectedCategory = null;
  breadcrumbs = [{ label: 'Share Portal' }];
  renderBreadcrumbs();
  renderSidebar();
  if (!_selectedSpoke) {
    document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Select a client first</div>';
    return;
  }
  document.getElementById('main').innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Loading shares...</div>';
  api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/shares').then(function(data) {
    _spokeShares = data.shares || [];
    renderSpokeShareManager();
  }).catch(function(err) {
    document.getElementById('main').innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load shares') + '</div>';
  });
}

function renderSpokeShareManager() {
  var h = '<div style="padding:24px 28px;max-width:720px;">';

  // Header
  h += '<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:24px;">';
  h += '<div style="display:flex;align-items:center;gap:10px;">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent-primary)" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>';
  h += '<span style="font-size:1.1rem;font-weight:700;color:var(--text-primary);">Share Portal</span>';
  h += '</div></div>';

  // Create new share
  h += '<div style="background:var(--bg-card);border:1px solid var(--border-primary);border-radius:12px;padding:20px;margin-bottom:24px;">';
  h += '<h3 style="font-size:0.9rem;font-weight:600;margin:0 0 16px;color:var(--text-primary);">Create Share Link</h3>';
  h += '<div style="margin-bottom:12px;">';
  h += '<label style="display:block;font-size:0.82rem;color:var(--text-secondary);margin-bottom:4px;">Label (optional)</label>';
  h += '<input type="text" id="shareLabel" placeholder="e.g. For Justin" style="width:100%;padding:8px 12px;border:1px solid var(--border-primary);border-radius:8px;font-size:0.85rem;background:var(--bg-input);color:var(--text-primary);" />';
  h += '</div>';
  h += '<div style="margin-bottom:16px;">';
  h += '<label style="display:block;font-size:0.82rem;color:var(--text-secondary);margin-bottom:8px;">Sections to include</label>';
  h += '<div style="display:flex;gap:16px;flex-wrap:wrap;">';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncGaps" checked /> Completeness</label>';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncExport" checked /> Export Data</label>';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncFiles" checked /> Source Files</label>';
  h += '</div></div>';
  h += '<button onclick="confirmSpokeShare()" style="padding:8px 20px;background:var(--accent-primary);color:#fff;border:none;border-radius:8px;font-size:0.85rem;font-weight:600;cursor:pointer;">Create Share Link</button>';
  h += '</div>';

  // Active shares list
  if (_spokeShares.length > 0) {
    h += '<div style="margin-bottom:8px;font-size:0.85rem;font-weight:600;color:var(--text-primary);">Active Links (' + _spokeShares.length + ')</div>';
    for (var i = 0; i < _spokeShares.length; i++) {
      var s = _spokeShares[i];
      var shareUrl = location.origin + '/shared/' + s.token;
      var created = s.created_at ? new Date(s.created_at).toLocaleDateString() : '';
      var incTags = (s.includes || []).map(function(inc) {
        var labels = { gaps: 'Completeness', export: 'Export', files: 'Files' };
        return '<span style="display:inline-block;padding:2px 8px;background:#ede9fe;color:#6366f1;border-radius:10px;font-size:10px;font-weight:600;">' + (labels[inc] || inc) + '</span>';
      }).join(' ');

      h += '<div style="background:var(--bg-card);border:1px solid var(--border-primary);border-radius:10px;padding:14px 16px;margin-bottom:8px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">';
      h += '<div style="flex:1;min-width:200px;">';
      if (s.label) h += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);margin-bottom:2px;">' + esc(s.label) + '</div>';
      h += '<div style="font-size:0.78rem;color:var(--text-muted);word-break:break-all;">' + esc(shareUrl) + '</div>';
      h += '<div style="margin-top:4px;display:flex;gap:4px;align-items:center;">' + incTags;
      if (created) h += '<span style="font-size:10px;color:var(--text-muted);margin-left:8px;">' + esc(created) + '</span>';
      h += '</div></div>';
      h += '<button onclick="copySpokeShareLink(\\'' + esc(s.token) + '\\')" style="padding:6px 14px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:6px;font-size:0.78rem;cursor:pointer;white-space:nowrap;">Copy</button>';
      h += '<button onclick="revokeSpokeShare(\\'' + esc(s.token) + '\\')" style="padding:6px 14px;background:#fef2f2;border:1px solid #fecaca;border-radius:6px;font-size:0.78rem;color:#DC2626;cursor:pointer;white-space:nowrap;">Revoke</button>';
      h += '</div>';
    }
  } else {
    h += '<div style="text-align:center;padding:32px;color:var(--text-muted);font-size:0.9rem;">No active share links. Create one above.</div>';
  }

  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function confirmSpokeShare() {
  if (!_selectedSpoke) return;
  var label = (document.getElementById('shareLabel') || {}).value || '';
  var includes = [];
  if (document.getElementById('shareIncGaps') && document.getElementById('shareIncGaps').checked) includes.push('gaps');
  if (document.getElementById('shareIncExport') && document.getElementById('shareIncExport').checked) includes.push('export');
  if (document.getElementById('shareIncFiles') && document.getElementById('shareIncFiles').checked) includes.push('files');
  if (includes.length === 0) { toast('Select at least one section to share'); return; }

  api('POST', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/share', { label: label, includes: includes }).then(function(data) {
    toast('Share link created!');
    // Copy to clipboard
    if (data.share_url) {
      var fullUrl = data.share_url;
      if (fullUrl.startsWith('/')) fullUrl = location.origin + fullUrl;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(fullUrl).then(function() { toast('Link copied to clipboard'); });
      } else {
        var ta = document.createElement('textarea');
        ta.value = fullUrl;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        toast('Link copied to clipboard');
      }
    }
    // Refresh — use tab system if in client workspace, else standalone
    _refreshShareView();
  }).catch(function(err) {
    toast('Failed to create share: ' + (err.message || err));
  });
}

function _refreshShareView() {
  var container = document.getElementById('clientTabContent');
  if (container && _activeClientTab === 'share') {
    // In tab mode — reload via tab
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/shares').then(function(data) {
      _spokeShares = data.shares || [];
      container.innerHTML = _buildShareHtml();
    });
  } else {
    showSpokeShareManager();
  }
}

function copySpokeShareLink(token) {
  var url = location.origin + '/shared/' + token;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(url).then(function() { toast('Link copied!'); }).catch(function() {
      _fallbackCopy(url);
    });
  } else {
    _fallbackCopy(url);
  }
}

function _fallbackCopy(text) {
  var ta = document.createElement('textarea');
  ta.value = text;
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand('copy'); toast('Link copied!'); } catch(e) { toast('Copy failed — select manually'); }
  document.body.removeChild(ta);
}

function revokeSpokeShare(token) {
  if (!confirm('Revoke this share link? Anyone with the link will no longer have access.')) return;
  api('DELETE', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/share/' + encodeURIComponent(token)).then(function() {
    toast('Share link revoked');
    _refreshShareView();
  }).catch(function(err) {
    toast('Failed to revoke: ' + (err.message || err));
  });
}

// --- Spoke Selector ---

function loadSpokes() {
  api('GET', '/api/spokes').then(function(data) {
    _spokesList = data.spokes || [];
    // Fetch gap scores for each non-default spoke (for completeness dots)
    var clientSpokes = _spokesList.filter(function(s) { return s.id !== 'default'; });
    var pending = clientSpokes.length;
    if (pending === 0) { renderSidebar(); return; }
    clientSpokes.forEach(function(s) {
      api('GET', '/api/spoke/' + encodeURIComponent(s.id) + '/gaps').then(function(gapData) {
        s._completeness = gapData.overall_score || 0;
        s._hasTemplate = true;
      }).catch(function() {
        s._completeness = -1; // no template assigned
        s._hasTemplate = false;
      }).finally(function() {
        pending--;
        if (pending <= 0) renderSidebar();
      });
    });
  }).catch(function() {
    _spokesList = [];
  });
}

function loadTemplates() {
  api('GET', '/api/templates').then(function(data) {
    _templatesList = data.templates || [];
    renderSidebar();
  }).catch(function() {
    _templatesList = [];
  });
}

function spokeParam() {
  return _selectedSpoke ? '&spoke_id=' + encodeURIComponent(_selectedSpoke) : '';
}

function renderSpokeSelector() {
  // Legacy — spoke selector dropdown is now replaced by client list in sidebar
  var el = document.getElementById('spokeSelector');
  if (el) el.innerHTML = '';
}

function onSpokeChange() {
  // Legacy — kept for backward compat. Use selectClient() instead.
  refreshEntityList();
}

function refreshEntityList(callback) {
  var url = '/api/search?q=*' + spokeParam();
  api('GET', url).then(function(data) {
    allEntities = data.results || [];
    entities = allEntities.slice();
    renderSidebar();
    if (callback) callback();
  });
}

function renderSidebar() {
  var data = buildSidebarData();
  var html = '';

  // ── ME section (Personal Graph) ──
  if (primaryEntityId && primaryEntityData) {
    var selfName = (primaryEntityData.entity && primaryEntityData.entity.name) ? (primaryEntityData.entity.name.preferred || primaryEntityData.entity.name.full || primaryEntityData.entity.name) : '';
    if (typeof selfName === 'object') selfName = selfName.full || selfName.preferred || '';
    var meActive = !_selectedSpoke || _selectedSpoke === 'default';
    html += '<div class="sb-section-label" style="display:flex;align-items:center;gap:6px;cursor:pointer;" onclick="selectPersonalGraph()">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="#f1c40f" stroke="#f1c40f" stroke-width="1.5"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26"/></svg>';
    html += esc(selfName || 'Me') + ' <span style="font-size:10px;color:#bbb;font-weight:400;">(Personal Graph)</span>';
    html += '</div>';
  } else {
    html += '<div class="sb-section-label" style="cursor:pointer;color:var(--text-muted);" onclick="promptSetSelfEntity()">';
    html += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26"/></svg> ';
    html += 'Set primary user</div>';
  }

  // About
  var aboutActive = (!_selectedSpoke || _selectedSpoke === 'default') && (selectedId === primaryEntityId && window._liActiveTab === 'overview');
  html += '<div class="sb-nav-item' + (aboutActive ? ' active' : '') + '" onclick="selectPersonalGraph();selectView(\\'overview\\')">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
  html += 'About</div>';

  // Career
  var careerActive = (!_selectedSpoke || _selectedSpoke === 'default') && (selectedId === primaryEntityId && window._liActiveTab === 'career');
  html += '<div class="sb-nav-item' + (careerActive ? ' active' : '') + '" onclick="selectPersonalGraph();selectView(\\'career\\')">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"/><path d="M16 7V5a2 2 0 00-2-2h-4a2 2 0 00-2 2v2"/></svg>';
  html += 'Career</div>';

  // Family
  var familyActive = (!_selectedSpoke || _selectedSpoke === 'default') && (selectedCategory === 'people_hub' && window._peopleHubTab === 'family');
  html += '<div class="sb-nav-item' + (familyActive ? ' active' : '') + '" onclick="selectPersonalGraph();showPeopleHub(\\'family\\')">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg>';
  html += 'Family</div>';

  // Friends
  var friendsActive = (!_selectedSpoke || _selectedSpoke === 'default') && (selectedCategory === 'people_hub' && window._peopleHubTab === 'friends');
  html += '<div class="sb-nav-item' + (friendsActive ? ' active' : '') + '" onclick="selectPersonalGraph();showPeopleHub(\\'friends\\')">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 00-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 00-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 000-7.78z"/></svg>';
  html += 'Friends</div>';

  // Affiliations
  var affilActive = (!_selectedSpoke || _selectedSpoke === 'default') && (selectedCategory === 'affiliations_hub');
  html += '<div class="sb-nav-item' + (affilActive ? ' active' : '') + '" onclick="selectPersonalGraph();showAffiliationsHub()">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>';
  html += 'Affiliations</div>';

  // ── CLIENTS section ──
  var clientSpokes = _spokesList.filter(function(s) { return s.id !== 'default'; });
  if (clientSpokes.length > 0 || true) { // Always show CLIENTS header
    html += '<div class="sb-section-label">Clients</div>';
    for (var ci = 0; ci < clientSpokes.length; ci++) {
      var cs = clientSpokes[ci];
      var isActive = (_selectedSpoke === cs.id);
      var dotClass = 'gray';
      if (cs._hasTemplate) {
        if (cs._completeness >= 0.8) dotClass = 'green';
        else if (cs._completeness >= 0.5) dotClass = 'yellow';
        else dotClass = 'red';
      }
      html += '<div class="sb-client-item' + (isActive ? ' active' : '') + '" onclick="selectClient(\\'' + esc(cs.id) + '\\')">';
      html += '<span class="sb-client-name">' + esc(cs.name) + '</span>';
      html += '<span class="sb-client-meta">';
      html += '<span class="sb-client-count">' + (cs.entity_count || 0) + '</span>';
      html += '<span class="sb-client-dot ' + dotClass + '" title="' + (cs._hasTemplate ? Math.round((cs._completeness || 0) * 100) + '% complete' : 'No template') + '"></span>';
      html += '</span>';
      html += '</div>';
    }
    // + New Client button
    html += '<div class="sb-add-btn" onclick="promptNewClient()">';
    html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';
    html += '+ New Client</div>';
  }

  // ── TEMPLATES section ──
  html += '<div class="sb-section-label">Templates</div>';
  if (_templatesList && _templatesList.length > 0) {
    for (var ti = 0; ti < _templatesList.length; ti++) {
      var tpl = _templatesList[ti];
      var tplActive = (selectedView === 'template_detail' && window._selectedTemplate === tpl.id);
      html += '<div class="sb-template-item' + (tplActive ? ' active' : '') + '" onclick="showTemplateDetail(\\'' + esc(tpl.id) + '\\')">';
      html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      html += esc(tpl.label) + '</div>';
    }
  }
  html += '<div class="sb-add-btn" onclick="showTemplateEditor(null)">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';
  html += '+ New Template</div>';

  // ── PROJECTS section ──
  var allProjects = [].concat(data.projects.active || [], data.projects.rnd || [], data.projects.archive || []);
  html += '<div class="sb-section-label">Projects</div>';

  // + New Project
  html += '<div class="sb-nav-item add-item" onclick="toast(\\'Project creation coming soon\\');">';
  html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';
  html += '+ New Project</div>';

  var showMax = _sbProjectsExpanded ? allProjects.length : 5;
  for (var i = 0; i < Math.min(showMax, allProjects.length); i++) {
    var p = allProjects[i];
    var pActive = (p.entity_id === selectedId && selectedView === null);
    html += '<div class="sb-nav-item' + (pActive ? ' active' : '') + '" onclick="selectEntity(\\'' + esc(p.entity_id) + '\\')">';
    html += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>';
    html += esc(p.name) + '</div>';
  }
  if (!_sbProjectsExpanded && allProjects.length > 5) {
    html += '<div class="sb-see-more" onclick="_sbProjectsExpanded=true;renderSidebar();">... see ' + (allProjects.length - 5) + ' more</div>';
  }

  // ── RECENT section ──
  if (recentEntities.length > 0) {
    html += '<div class="sb-section-label">Recent</div>';
    var recentMax = Math.min(recentEntities.length, 8);
    for (var i = 0; i < recentMax; i++) {
      var r = recentEntities[i];
      var initials = (r.name || '').split(/\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
      html += '<div class="sb-recent-item" onclick="selectEntity(\\'' + esc(r.id) + '\\')">';
      html += '<div class="sb-recent-avatar">' + esc(initials) + '</div>';
      html += '<span>' + esc(r.name) + '</span>';
      html += '</div>';
    }
  }

  document.getElementById('entityList').innerHTML = html || '<div style="padding:16px;color:#3a3a4a;font-size:0.82rem;">No entities found</div>';
}

// Backward-compat alias
function renderEntityList() { renderSidebar(); }

/* --- Client Selection & Navigation (Build 8) --- */

function selectClient(spokeId) {
  _selectedSpoke = spokeId;
  selectedId = null;
  selectedView = 'client_workspace';
  selectedCategory = null;
  _activeClientTab = 'completeness';
  renderSidebar();

  // Load the client workspace — default to Completeness tab
  showClientWorkspace(spokeId, 'completeness');
}

function selectPersonalGraph() {
  if (!_selectedSpoke && selectedView !== 'client_workspace') return; // Already on personal graph
  _selectedSpoke = null;
  selectedView = null;
  selectedCategory = null;
  // Don't re-render sidebar here — let the nav item onclick handler do that
}

// --- HTML builders for tab content (return string, don't write to DOM) ---

function _buildCompletenessHtml(data) {
  var pct = Math.round((data.overall_score || 0) * 100);
  var color = _gapScoreColor(data.overall_score || 0);
  var h = '<div class="gap-dashboard">';

  h += '<div class="gap-dashboard-header">';
  h += '<div class="gap-dashboard-title">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>';
  h += ' ' + esc(data.template_name || 'Completeness') + '</div>';
  h += '<div class="gap-dashboard-controls">';
  h += '<select id="gapTemplateSelect" onchange="setMatterType(this.value)">';
  h += '<option value="' + esc(data.template_type || '') + '">' + esc(data.template_name || '') + '</option>';
  h += '</select>';
  h += '<button onclick="refreshGapAnalysis()">Refresh Analysis</button>';
  h += '</div></div>';

  h += '<div class="gap-ring-container">';
  var deg = Math.round(pct * 3.6);
  h += '<div class="gap-ring" style="background: conic-gradient(' + color + ' 0deg, ' + color + ' ' + deg + 'deg, #e8e8e8 ' + deg + 'deg);">';
  h += '<div class="gap-ring-label" style="background:#fff;width:140px;height:140px;border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;">';
  h += '<div class="gap-ring-pct" style="color:' + color + ';">' + pct + '%</div>';
  h += '<div class="gap-ring-sub">Complete</div>';
  h += '</div></div>';

  h += '<div class="gap-score-bars">';
  var bars = [
    { label: 'Documents', score: data.document_score || 0, weight: '40%' },
    { label: 'Entities', score: data.entity_score || 0, weight: '40%' },
    { label: 'Relationships', score: data.relationship_score || 0, weight: '20%' }
  ];
  for (var b = 0; b < bars.length; b++) {
    var bar = bars[b];
    var bPct = Math.round(bar.score * 100);
    var bColor = _gapScoreColor(bar.score);
    h += '<div class="gap-score-bar">';
    h += '<div class="gap-score-bar-header"><span>' + bar.label + ' <span style="color:var(--text-muted);font-size:11px;">(' + bar.weight + ' weight)</span></span><span style="font-weight:600;color:' + bColor + ';">' + bPct + '%</span></div>';
    h += '<div class="gap-score-bar-track"><div class="gap-score-bar-fill" style="width:' + bPct + '%;background:' + bColor + ';"></div></div>';
    h += '</div>';
  }
  h += '</div></div>';

  // Request Missing Documents button (Build 13)
  var totalMissing = (data.missing_documents || []).length + (data.missing_entity_fields || []).length;
  if (totalMissing > 0) {
    h += '<div style="display:flex;gap:10px;margin-bottom:20px;">';
    h += '<button onclick="generateRequestEmail()" style="display:flex;align-items:center;gap:8px;padding:10px 20px;border:none;border-radius:8px;background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;font-size:13px;font-weight:600;cursor:pointer;transition:opacity 0.2s;" onmouseover="this.style.opacity=\\'0.9\\'" onmouseout="this.style.opacity=\\'1\\'">';
    h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>';
    h += 'Request Missing Documents (' + totalMissing + ')</button>';
    h += '</div>';
  }

  var missingDocs = data.missing_documents || [];
  if (missingDocs.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#DC2626" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> Missing Documents (' + missingDocs.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var d = 0; d < missingDocs.length; d++) {
      var doc = missingDocs[d];
      h += '<div class="gap-missing-item" style="cursor:pointer;" onclick="switchClientTab(\\'documents\\')">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(doc.item)) + '</div>';
      h += '<div class="gap-item-detail">' + esc(_gapFormatLabel(doc.category)) + '</div></div>';
      h += '<span class="gap-priority-badge ' + (doc.priority || 'medium') + '">' + (doc.priority || 'medium') + '</span>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  var missingFields = data.missing_entity_fields || [];
  if (missingFields.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#CA8A04" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg> Missing Entity Fields (' + missingFields.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var f = 0; f < missingFields.length; f++) {
      var field = missingFields[f];
      h += '<div class="gap-missing-item" style="cursor:pointer;" onclick="switchClientTab(\\'export\\')">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(field.missing)) + '</div>';
      h += '<div class="gap-item-detail">' + esc(_gapFormatLabel(field.role)) + (field.entity ? ' &middot; ' + esc(field.entity) : '') + '</div></div>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  var missingRels = data.missing_relationships || [];
  if (missingRels.length > 0) {
    h += '<div class="gap-category">';
    h += '<div class="gap-category-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#7C3AED" stroke-width="2"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg> Missing Relationships (' + missingRels.length + ')</div>';
    h += '<div class="gap-category-grid">';
    for (var r = 0; r < missingRels.length; r++) {
      var rel = missingRels[r];
      h += '<div class="gap-missing-item">';
      h += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg>';
      h += '<div><div class="gap-item-name">' + esc(_gapFormatLabel(rel.expected)) + '</div>';
      h += '<div class="gap-item-detail">Expected connection</div></div>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  var foundDocs = data.found_documents || [];
  if (foundDocs.length > 0) {
    h += '<div class="gap-found-section">';
    h += '<div class="gap-category-title" style="color:#065F46;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#16A34A" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> Found Documents (' + foundDocs.length + ')</div>';
    h += '<div>';
    for (var fd = 0; fd < foundDocs.length; fd++) {
      var fdoc = foundDocs[fd];
      h += '<span class="gap-found-item" style="cursor:pointer;" onclick="switchClientTab(\\'documents\\')"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> ' + esc(_gapFormatLabel(fdoc.item)) + '</span>';
    }
    h += '</div></div>';
  }

  var suggestions = data.suggestions || [];
  if (suggestions.length > 0) {
    h += '<div class="gap-suggestions">';
    h += '<div class="gap-suggestions-title">Suggested Next Steps</div>';
    h += '<ul>';
    for (var s = 0; s < suggestions.length; s++) {
      h += '<li>' + esc(suggestions[s]) + '</li>';
    }
    h += '</ul></div>';
  }

  h += '<div style="margin-top:20px;font-size:11px;color:var(--text-muted);">';
  h += (data.entity_count || 0) + ' entities &middot; ' + (data.source_documents || []).length + ' source documents';
  if (data.cached) h += ' &middot; <span style="color:#CA8A04;">cached</span>';
  if (data.analyzed_at) h += ' &middot; analyzed ' + new Date(data.analyzed_at).toLocaleString();
  h += '</div>';

  h += '</div>';
  return h;
}

function _buildExportHtml(data) {
  var s = data.summary || {};
  var h = '<div class="export-view">';

  h += '<div class="export-header">';
  h += '<div class="export-title">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>';
  h += ' ' + esc(data.spoke_name || 'Export') + ' — Data Export</div>';
  h += '<button class="export-btn-csv" onclick="downloadExportCsv()">';
  h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
  h += ' Download CSV</button>';
  h += '</div>';

  h += '<div class="export-summary">';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#191919;">' + (s.total_fields || 0) + '</div> Total</div>';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#16A34A;">' + (s.verified || 0) + '</div> Verified</div>';
  if (s.low_confidence) h += '<div class="export-stat"><div class="export-stat-count" style="color:#CA8A04;">' + s.low_confidence + '</div> Low Conf</div>';
  if (s.conflicts) h += '<div class="export-stat"><div class="export-stat-count" style="color:#DC2626;">' + s.conflicts + '</div> Conflicts</div>';
  h += '<div class="export-stat"><div class="export-stat-count" style="color:#6B7280;">' + (s.missing || 0) + '</div> Missing</div>';
  h += '</div>';

  var roles = data.roles || [];
  for (var ri = 0; ri < roles.length; ri++) {
    var role = roles[ri];
    var roleVerified = 0, roleTotal = 0;
    for (var ei = 0; ei < (role.entities || []).length; ei++) {
      for (var fi = 0; fi < (role.entities[ei].fields || []).length; fi++) {
        roleTotal++;
        if (role.entities[ei].fields[fi].status === 'verified') roleVerified++;
      }
    }
    var allComplete = (roleVerified === roleTotal && roleTotal > 0);

    h += '<div class="export-role-card">';
    h += '<div class="export-role-header" onclick="toggleExportRole(' + ri + ')">';
    h += _exportRoleIcon(role.role);
    h += '<span class="export-role-name">' + esc(_exportFormatLabel(role.role)) + '</span>';
    h += '<span class="export-role-count' + (allComplete ? ' complete' : '') + '">' + roleVerified + '/' + roleTotal + ' fields</span>';
    h += '<span class="export-role-chevron" id="exportChevron' + ri + '"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></span>';
    h += '</div>';

    h += '<div class="export-role-body" id="exportBody' + ri + '">';

    var hasEntities = role.entities && role.entities.length > 0 && !(role.entities.length === 1 && !role.entities[0].entity_id);

    if (!hasEntities) {
      h += '<div class="export-not-found">No matching entity found for this role</div>';
      if (role.entities && role.entities[0]) {
        for (var fi = 0; fi < (role.entities[0].fields || []).length; fi++) {
          var f = role.entities[0].fields[fi];
          h += '<div class="export-field-row missing">';
          h += '<div class="export-field-label">' + esc(_exportFormatLabel(f.field)) + '</div>';
          h += '<div class="export-field-value empty">—</div>';
          h += '<div class="export-field-meta">' + _exportBadgeHtml('missing') + '</div>';
          h += '</div>';
        }
      }
    } else {
      for (var ei = 0; ei < role.entities.length; ei++) {
        var ent = role.entities[ei];
        if (role.entities.length > 1) {
          h += '<div class="export-entity-header">';
          h += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>';
          h += esc(ent.entity_name || '');
          h += '</div>';
        }

        for (var fi = 0; fi < (ent.fields || []).length; fi++) {
          var f = ent.fields[fi];
          var isMissing = f.status === 'missing';
          var evidKey = ri + '_' + ei + '_' + fi;

          h += '<div class="export-field-row' + (isMissing ? ' missing' : '') + '" onclick="showFieldInRightPanel(' + ri + ',' + ei + ',' + fi + ')">';
          h += '<div class="export-field-label">' + esc(_exportFormatLabel(f.field)) + '</div>';

          if (f.value) {
            h += '<div class="export-field-value">' + esc(String(f.value)) + '</div>';
          } else {
            h += '<div class="export-field-value empty">—</div>';
          }

          h += '<div class="export-field-meta">';
          h += _exportBadgeHtml(f.status);
          if (f.provenance && f.provenance.filename) {
            h += '<span class="export-source-pill" onclick="toggleExportEvidence(event,\\'' + evidKey + '\\',' + ri + ',' + ei + ',' + fi + ')">';
            h += '<svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg> ';
            h += esc(f.provenance.filename);
            h += '</span>';
          }
          h += '</div>';
          h += '</div>';

          h += '<div id="exportEvid_' + evidKey + '" style="display:none;"></div>';
        }
      }
    }

    h += '</div></div>';
  }

  h += '</div>';
  return h;
}

function _buildShareHtml() {
  var h = '<div style="padding:24px 28px;max-width:720px;">';

  h += '<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:24px;">';
  h += '<div style="display:flex;align-items:center;gap:10px;">';
  h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent-primary)" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>';
  h += '<span style="font-size:1.1rem;font-weight:700;color:var(--text-primary);">Share Portal</span>';
  h += '</div></div>';

  h += '<div style="background:var(--bg-card);border:1px solid var(--border-primary);border-radius:12px;padding:20px;margin-bottom:24px;">';
  h += '<h3 style="font-size:0.9rem;font-weight:600;margin:0 0 16px;color:var(--text-primary);">Create Share Link</h3>';
  h += '<div style="margin-bottom:12px;">';
  h += '<label style="display:block;font-size:0.82rem;color:var(--text-secondary);margin-bottom:4px;">Label (optional)</label>';
  h += '<input type="text" id="shareLabel" placeholder="e.g. For Justin" style="width:100%;padding:8px 12px;border:1px solid var(--border-primary);border-radius:8px;font-size:0.85rem;background:var(--bg-input);color:var(--text-primary);" />';
  h += '</div>';
  h += '<div style="margin-bottom:16px;">';
  h += '<label style="display:block;font-size:0.82rem;color:var(--text-secondary);margin-bottom:8px;">Sections to include</label>';
  h += '<div style="display:flex;gap:16px;flex-wrap:wrap;">';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncGaps" checked /> Completeness</label>';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncExport" checked /> Export Data</label>';
  h += '<label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;cursor:pointer;"><input type="checkbox" id="shareIncFiles" checked /> Source Files</label>';
  h += '</div></div>';
  h += '<button onclick="confirmSpokeShare()" style="padding:8px 20px;background:var(--accent-primary);color:#fff;border:none;border-radius:8px;font-size:0.85rem;font-weight:600;cursor:pointer;">Create Share Link</button>';
  h += '</div>';

  if (_spokeShares.length > 0) {
    h += '<div style="margin-bottom:8px;font-size:0.85rem;font-weight:600;color:var(--text-primary);">Active Links (' + _spokeShares.length + ')</div>';
    for (var i = 0; i < _spokeShares.length; i++) {
      var s = _spokeShares[i];
      var shareUrl = location.origin + '/shared/' + s.token;
      var created = s.created_at ? new Date(s.created_at).toLocaleDateString() : '';
      var incTags = (s.includes || []).map(function(inc) {
        var labels = { gaps: 'Completeness', export: 'Export', files: 'Files' };
        return '<span style="display:inline-block;padding:2px 8px;background:#ede9fe;color:#6366f1;border-radius:10px;font-size:10px;font-weight:600;">' + (labels[inc] || inc) + '</span>';
      }).join(' ');

      h += '<div style="background:var(--bg-card);border:1px solid var(--border-primary);border-radius:10px;padding:14px 16px;margin-bottom:8px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">';
      h += '<div style="flex:1;min-width:200px;">';
      if (s.label) h += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);margin-bottom:2px;">' + esc(s.label) + '</div>';
      h += '<div style="font-size:0.78rem;color:var(--text-muted);word-break:break-all;">' + esc(shareUrl) + '</div>';
      h += '<div style="margin-top:4px;display:flex;gap:4px;align-items:center;">' + incTags;
      if (created) h += '<span style="font-size:10px;color:var(--text-muted);margin-left:8px;">' + esc(created) + '</span>';
      h += '</div></div>';
      h += '<button onclick="copySpokeShareLink(\\'' + esc(s.token) + '\\')" style="padding:6px 14px;background:var(--bg-tertiary);border:1px solid var(--border-primary);border-radius:6px;font-size:0.78rem;cursor:pointer;white-space:nowrap;">Copy</button>';
      h += '<button onclick="revokeSpokeShare(\\'' + esc(s.token) + '\\')" style="padding:6px 14px;background:#fef2f2;border:1px solid #fecaca;border-radius:6px;font-size:0.78rem;color:#DC2626;cursor:pointer;white-space:nowrap;">Revoke</button>';
      h += '</div>';
    }
  } else {
    h += '<div style="text-align:center;padding:32px;color:var(--text-muted);font-size:0.9rem;">No active share links. Create one above.</div>';
  }

  h += '</div>';
  return h;
}

function showClientWorkspace(spokeId, tab) {
  if (!spokeId) return;
  _selectedSpoke = spokeId;
  _activeClientTab = tab || 'completeness';
  selectedView = 'client_workspace';

  // Find spoke name
  var spokeName = spokeId;
  for (var i = 0; i < _spokesList.length; i++) {
    if (_spokesList[i].id === spokeId) { spokeName = _spokesList[i].name; break; }
  }

  // Build breadcrumb + tab header
  breadcrumbs = [
    { label: 'Clients', action: 'showClientDashboard()' },
    { label: spokeName }
  ];
  renderBreadcrumbs();

  // Render breadcrumb bar + tab bar + content
  var mainEl = document.getElementById('main');
  var tabHtml = '<div class="client-breadcrumb">';
  tabHtml += '<a onclick="showClientDashboard()">Clients</a>';
  tabHtml += '<span class="cb-sep">&gt;</span>';
  tabHtml += '<span class="cb-current">' + esc(spokeName) + '</span>';
  tabHtml += '</div>';
  tabHtml += '<div class="client-tab-bar">';
  var tabs = [
    { id: 'completeness', label: 'Completeness', icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>' },
    { id: 'export', label: 'Data Export', icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>' },
    { id: 'documents', label: 'Documents', icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>' },
    { id: 'share', label: 'Share', icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>' }
  ];
  for (var t = 0; t < tabs.length; t++) {
    var isActive = (_activeClientTab === tabs[t].id);
    tabHtml += '<div class="client-tab' + (isActive ? ' active' : '') + '" onclick="switchClientTab(\\'' + tabs[t].id + '\\')">';
    tabHtml += tabs[t].icon + ' ' + tabs[t].label;
    tabHtml += '</div>';
  }
  tabHtml += '</div>';
  tabHtml += '<div id="spokeReviewProgress"></div>';
  tabHtml += '<div id="clientTabContent"></div>';
  mainEl.innerHTML = tabHtml;

  // Load tab content
  loadClientTabContent(tab);
}

function switchClientTab(tab) {
  _activeClientTab = tab;
  // Update active tab visual
  var tabEls = document.querySelectorAll('.client-tab');
  for (var i = 0; i < tabEls.length; i++) {
    tabEls[i].classList.remove('active');
    if (tabEls[i].textContent.toLowerCase().indexOf(tab === 'export' ? 'data' : tab) >= 0) {
      tabEls[i].classList.add('active');
    }
  }
  // Simpler: rebuild tabs
  showClientWorkspace(_selectedSpoke, tab);
}

function loadClientTabContent(tab) {
  var container = document.getElementById('clientTabContent');
  if (!container) return;
  container.innerHTML = '<div style="padding:40px;text-align:center;color:var(--text-muted);">Loading...</div>';

  // Update right panel context based on tab
  if (tab === 'completeness' || tab === 'export') {
    // Load export data for review queue (needed by both tabs)
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/export').then(function(data) {
      _exportData = data;
      if (tab === 'completeness') updateContextRightPanel('review_queue');
      renderSpokeReviewProgress();
    }).catch(function() {});
  }

  if (tab === 'completeness') {
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/gaps').then(function(data) {
      _gapData = data;
      container.innerHTML = _buildCompletenessHtml(data);
      // Populate template selector async
      api('GET', '/api/templates').then(function(tData) {
        var sel = document.getElementById('gapTemplateSelect');
        if (!sel) return;
        var templates = tData.templates || [];
        sel.innerHTML = '';
        for (var i = 0; i < templates.length; i++) {
          var opt = document.createElement('option');
          opt.value = templates[i].id;
          opt.textContent = templates[i].label;
          if (templates[i].id === data.template_type) opt.selected = true;
          sel.appendChild(opt);
        }
      });
    }).catch(function(err) {
      if (err.message && err.message.indexOf('No template') >= 0) {
        api('GET', '/api/templates').then(function(tData) {
          var templates = tData.templates || [];
          var h = '<div class="gap-dashboard"><div class="gap-dashboard-title">';
          h += '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>';
          h += ' Completeness Analysis</div>';
          h += '<p style="color:var(--text-muted);margin:16px 0 24px;">Select a matter type to begin analyzing completeness for this client.</p>';
          h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px;">';
          for (var i = 0; i < templates.length; i++) {
            var t = templates[i];
            h += '<div class="gap-missing-item" style="cursor:pointer;transition:border-color 0.15s;" onclick="setMatterType(\\'' + esc(t.id) + '\\')" onmouseover="this.style.borderColor=\\'#0a66c2\\'" onmouseout="this.style.borderColor=\\'#e0e0e0\\'">';
            h += '<svg viewBox="0 0 24 24" fill="none" stroke="#0a66c2" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
            h += '<div><div class="gap-item-name">' + esc(t.label) + '</div>';
            h += '<div class="gap-item-detail">' + t.category_count + ' categories &middot; ' + t.entity_roles + ' roles</div></div>';
            h += '</div>';
          }
          h += '</div></div>';
          container.innerHTML = h;
        });
      } else {
        container.innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load') + '</div>';
      }
    });
  } else if (tab === 'export') {
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/export').then(function(data) {
      _exportData = data;
      container.innerHTML = _buildExportHtml(data);
    }).catch(function(err) {
      container.innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load export') + '</div>';
    });
  } else if (tab === 'documents') {
    // Show file list + upload zone for this spoke
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/files').then(function(data) {
      renderDocumentsTab(container, data.files || []);
    }).catch(function(err) {
      container.innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load files') + '</div>';
    });
  } else if (tab === 'share') {
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/shares').then(function(data) {
      _spokeShares = data.shares || [];
      container.innerHTML = _buildShareHtml();
    }).catch(function(err) {
      container.innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load shares') + '</div>';
    });
  }
}

function renderDocumentsTab(container, files) {
  var h = '<div style="padding:24px 28px;">';

  // Upload zone
  h += '<div class="pp-dropzone" id="docTabDropzone" onclick="document.getElementById(\\'docTabFileInput\\').click()">';
  h += '<div class="pp-drop-icon"><svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></div>';
  h += '<div>Drop files here or click to upload</div>';
  h += '<div class="pp-drop-sub">PDF, DOCX, CSV, TXT, JSON, and more</div>';
  h += '</div>';
  h += '<input type="file" id="docTabFileInput" multiple accept=".pdf,.docx,.doc,.xlsx,.xls,.csv,.txt,.md,.json" style="display:none" onchange="handleDocTabUpload(event)" />';

  // File list
  if (files.length > 0) {
    h += '<div style="margin-top:24px;">';
    h += '<div style="font-size:15px;font-weight:600;color:var(--text-primary);margin-bottom:12px;">Uploaded Documents (' + files.length + ')</div>';
    for (var i = 0; i < files.length; i++) {
      var f = files[i];
      var fName = f.original_name || f.filename || f.id;
      var fDate = f.uploaded_at ? new Date(f.uploaded_at).toLocaleDateString() : '';
      var fSize = f.size ? (f.size > 1024*1024 ? (f.size/(1024*1024)).toFixed(1) + ' MB' : (f.size/1024).toFixed(1) + ' KB') : '';
      h += '<div class="doc-file-item" onclick="selectDocumentDetail(\\'' + esc(f.id || f.filename) + '\\')" style="display:flex;align-items:center;gap:12px;padding:12px 14px;border:1px solid #e8e8e8;border-radius:8px;margin-bottom:6px;cursor:pointer;transition:border-color 0.15s;" onmouseover="this.style.borderColor=\\'#0a66c2\\'" onmouseout="this.style.borderColor=\\'#e8e8e8\\'">';
      h += '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
      h += '<div style="flex:1;min-width:0;">';
      h += '<div style="font-size:14px;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + esc(fName) + '</div>';
      h += '<div style="font-size:12px;color:var(--text-muted);">' + esc(fDate) + (fSize ? ' &middot; ' + esc(fSize) : '') + '</div>';
      h += '</div></div>';
    }
    h += '</div>';
  } else {
    h += '<div style="text-align:center;padding:32px;color:var(--text-muted);font-size:14px;margin-top:16px;">No documents uploaded yet. Drop files above to get started.</div>';
  }

  h += '</div>';
  container.innerHTML = h;

  // Set up drag and drop
  var dz = document.getElementById('docTabDropzone');
  if (dz) {
    dz.addEventListener('dragover', function(e) { e.preventDefault(); dz.classList.add('dragover'); });
    dz.addEventListener('dragleave', function() { dz.classList.remove('dragover'); });
    dz.addEventListener('drop', function(e) {
      e.preventDefault(); dz.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) uploadFilesToSpoke(e.dataTransfer.files);
    });
  }
}

function handleDocTabUpload(event) {
  var files = event.target.files;
  if (files && files.length > 0) uploadFilesToSpoke(files);
}

function uploadFilesToSpoke(files) {
  if (!_selectedSpoke) { toast('No client selected'); return; }
  var formData = new FormData();
  for (var i = 0; i < files.length; i++) {
    formData.append('files', files[i]);
  }
  formData.append('spoke_id', _selectedSpoke);
  toast('Uploading ' + files.length + ' file(s)...');
  fetch('/api/ingest/files', {
    method: 'POST',
    headers: getAuthHeaders(),
    body: formData
  }).then(function(r) { return r.json(); }).then(function(data) {
    toast('Upload complete! ' + (data.clusters_created || 0) + ' signals created.');
    // Refresh documents tab
    if (_activeClientTab === 'documents') {
      loadClientTabContent('documents');
    }
    refreshReviewQueueBadge();
  }).catch(function(err) {
    toast('Upload failed: ' + (err.message || err));
  });
}

function selectDocumentDetail(fileId) {
  if (!_selectedSpoke) return;
  api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/files').then(function(data) {
    var files = data.files || [];
    var file = files.find(function(f) { return (f.id || f.filename) === fileId; });
    if (file) {
      updateContextRightPanel('document_detail', file);
    }
  });
}

function promptNewClient() {
  // Build and show onboarding modal
  api('GET', '/api/templates').then(function(tData) {
    var templates = tData.templates || [];
    var overlay = document.createElement('div');
    overlay.id = 'onboard-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.4);z-index:1000;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(4px);';

    var modal = document.createElement('div');
    modal.style.cssText = 'background:#fff;border-radius:16px;width:520px;max-width:90vw;max-height:85vh;overflow-y:auto;box-shadow:0 24px 64px rgba(0,0,0,0.2);';

    var mh = '<div style="padding:28px 28px 0;">';
    mh += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">';
    mh += '<div style="font-size:20px;font-weight:700;">New Client</div>';
    mh += '<div onclick="closeOnboardModal()" style="cursor:pointer;width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:8px;color:#666;font-size:18px;" onmouseover="this.style.background=\\'#f0f0f0\\'" onmouseout="this.style.background=\\'\\'">&#10005;</div>';
    mh += '</div>';

    // Client name
    mh += '<div style="margin-bottom:20px;">';
    mh += '<label style="display:block;font-size:13px;font-weight:600;color:#555;margin-bottom:6px;">Client Name</label>';
    mh += '<input id="onboard-name" type="text" placeholder="e.g. Acme Corp" style="width:100%;padding:10px 14px;border:1px solid #ddd;border-radius:8px;font-size:14px;outline:none;transition:border 0.2s;" onfocus="this.style.borderColor=\\'#6366f1\\'" onblur="this.style.borderColor=\\'#ddd\\'" />';
    mh += '</div>';

    // Template dropdown
    mh += '<div style="margin-bottom:20px;">';
    mh += '<label style="display:block;font-size:13px;font-weight:600;color:#555;margin-bottom:6px;">Template Type</label>';
    mh += '<select id="onboard-template" style="width:100%;padding:10px 14px;border:1px solid #ddd;border-radius:8px;font-size:14px;outline:none;background:#fff;cursor:pointer;">';
    for (var i = 0; i < templates.length; i++) {
      mh += '<option value="' + esc(templates[i].id) + '">' + esc(templates[i].label) + '</option>';
    }
    mh += '</select>';
    mh += '</div>';

    // File drop zone
    mh += '<div style="margin-bottom:24px;">';
    mh += '<label style="display:block;font-size:13px;font-weight:600;color:#555;margin-bottom:6px;">Initial Documents (optional)</label>';
    mh += '<div id="onboard-dropzone" style="border:2px dashed #ddd;border-radius:10px;padding:32px 20px;text-align:center;cursor:pointer;transition:all 0.2s;background:#fafafa;" onclick="document.getElementById(\\'onboard-file-input\\').click()" ondragover="event.preventDefault();this.style.borderColor=\\'#6366f1\\';this.style.background=\\'#f0f0ff\\'" ondragleave="this.style.borderColor=\\'#ddd\\';this.style.background=\\'#fafafa\\'" ondrop="handleOnboardDrop(event)">';
    mh += '<svg viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="1.5" style="width:32px;height:32px;margin-bottom:8px;"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>';
    mh += '<div style="font-size:14px;color:#666;">Drop files here or click to browse</div>';
    mh += '<div style="font-size:12px;color:#999;margin-top:4px;">PDF, DOC, XLSX, CSV, TXT</div>';
    mh += '</div>';
    mh += '<input id="onboard-file-input" type="file" multiple style="display:none" onchange="handleOnboardFiles(this.files)" />';
    mh += '<div id="onboard-file-list" style="margin-top:8px;"></div>';
    mh += '</div>';

    // Create button
    mh += '<div style="padding-bottom:28px;">';
    mh += '<button id="onboard-btn" onclick="submitOnboard()" style="width:100%;padding:12px;border:none;border-radius:10px;background:var(--accent-gradient, linear-gradient(135deg,#6366f1,#8b5cf6));color:#fff;font-size:15px;font-weight:600;cursor:pointer;transition:opacity 0.2s;" onmouseover="this.style.opacity=\\'0.9\\'" onmouseout="this.style.opacity=\\'1\\'">Create Client</button>';
    mh += '</div></div>';

    modal.innerHTML = mh;
    overlay.appendChild(modal);
    overlay.onclick = function(e) { if (e.target === overlay) closeOnboardModal(); };
    document.body.appendChild(overlay);

    // Focus the name input
    setTimeout(function() { document.getElementById('onboard-name').focus(); }, 100);
  });
}

window._onboardFiles = [];

function closeOnboardModal() {
  var overlay = document.getElementById('onboard-overlay');
  if (overlay) overlay.remove();
  window._onboardFiles = [];
}

function handleOnboardDrop(e) {
  e.preventDefault();
  e.currentTarget.style.borderColor = '#ddd';
  e.currentTarget.style.background = '#fafafa';
  if (e.dataTransfer && e.dataTransfer.files) {
    handleOnboardFiles(e.dataTransfer.files);
  }
}

function handleOnboardFiles(files) {
  for (var i = 0; i < files.length; i++) {
    window._onboardFiles.push(files[i]);
  }
  renderOnboardFileList();
}

function removeOnboardFile(idx) {
  window._onboardFiles.splice(idx, 1);
  renderOnboardFileList();
}

function renderOnboardFileList() {
  var el = document.getElementById('onboard-file-list');
  if (!el) return;
  if (window._onboardFiles.length === 0) { el.innerHTML = ''; return; }
  var h = '';
  for (var i = 0; i < window._onboardFiles.length; i++) {
    var f = window._onboardFiles[i];
    var sizeKB = Math.round(f.size / 1024);
    h += '<div style="display:flex;align-items:center;justify-content:space-between;padding:6px 10px;background:#f8f8fa;border-radius:6px;margin-bottom:4px;font-size:13px;">';
    h += '<span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:340px;">' + esc(f.name) + ' <span style="color:#999;">(' + sizeKB + ' KB)</span></span>';
    h += '<span onclick="removeOnboardFile(' + i + ')" style="cursor:pointer;color:#999;padding:2px 6px;border-radius:4px;" onmouseover="this.style.color=\\'#dc2626\\'" onmouseout="this.style.color=\\'#999\\'">&#10005;</span>';
    h += '</div>';
  }
  el.innerHTML = h;
}

function submitOnboard() {
  var nameEl = document.getElementById('onboard-name');
  var templateEl = document.getElementById('onboard-template');
  var btn = document.getElementById('onboard-btn');
  var clientName = (nameEl.value || '').trim();
  var templateType = templateEl.value;
  if (!clientName) { nameEl.style.borderColor = '#dc2626'; nameEl.focus(); return; }

  btn.textContent = 'Creating...';
  btn.disabled = true;
  btn.style.opacity = '0.6';

  // Build FormData if files present, otherwise JSON
  if (window._onboardFiles.length > 0) {
    var fd = new FormData();
    fd.append('client_name', clientName);
    fd.append('template_type', templateType);
    for (var i = 0; i < window._onboardFiles.length; i++) {
      fd.append('files', window._onboardFiles[i]);
    }
    fetch('/api/onboard', {
      method: 'POST',
      headers: { 'X-Context-API-Key': window._apiKey },
      body: fd
    }).then(function(r) { return r.json(); }).then(function(data) {
      if (data.error) throw new Error(data.error);
      closeOnboardModal();
      toast('Client "' + clientName + '" created with ' + (data.entities_created || 0) + ' entities!');
      loadSpokes().then(function() {
        selectClient(data.spoke_id);
      });
    }).catch(function(err) {
      btn.textContent = 'Create Client';
      btn.disabled = false;
      btn.style.opacity = '1';
      toast('Error: ' + (err.message || err));
    });
  } else {
    api('POST', '/api/onboard', { client_name: clientName, template_type: templateType }).then(function(data) {
      closeOnboardModal();
      toast('Client "' + clientName + '" created!');
      loadSpokes().then(function() {
        selectClient(data.spoke_id);
      });
    }).catch(function(err) {
      btn.textContent = 'Create Client';
      btn.disabled = false;
      btn.style.opacity = '1';
      toast('Error: ' + (err.message || err));
    });
  }
}

function showTemplateDetail(templateId) {
  showTemplateEditor(templateId);
}

// ── Template Builder State ──
window._tplEdit = null;        // current template being edited (mutable copy)
window._tplIsNew = false;      // true if creating new template
window._tplExpandedDt = {};    // which doc type accordions are expanded
window._tplExpandedRole = {};  // which role accordions are expanded
window._tplExpandedRule = {};  // which rule accordions are expanded

function showTemplateEditor(templateId) {
  selectedView = 'template_detail';
  window._selectedTemplate = templateId;
  _selectedSpoke = null;
  window._tplExpandedDt = {};
  window._tplExpandedRole = {};
  window._tplExpandedRule = {};
  renderSidebar();

  if (!templateId) {
    // New template
    window._tplIsNew = true;
    window._tplEdit = {
      template_id: '',
      display_name: '',
      description: '',
      version: '1.0.0',
      document_types: [],
      entity_roles: [],
      cross_doc_rules: []
    };
    breadcrumbs = [{ label: 'Templates' }, { label: 'New Template' }];
    renderBreadcrumbs();
    renderTemplateEditor();
  } else {
    // Edit existing
    window._tplIsNew = false;
    api('GET', '/api/templates/' + encodeURIComponent(templateId)).then(function(data) {
      window._tplEdit = JSON.parse(JSON.stringify(data));
      if (!window._tplEdit.document_types) window._tplEdit.document_types = [];
      if (!window._tplEdit.entity_roles) window._tplEdit.entity_roles = [];
      if (!window._tplEdit.cross_doc_rules) window._tplEdit.cross_doc_rules = [];
      breadcrumbs = [{ label: 'Templates' }, { label: data.display_name || data.label || templateId }];
      renderBreadcrumbs();
      renderTemplateEditor();
    }).catch(function(err) {
      document.getElementById('main').innerHTML = '<div style="padding:40px;color:#991B1B;">' + esc(err.message || 'Failed to load template') + '</div>';
    });
  }
}

function renderTemplateEditor() {
  var t = window._tplEdit;
  if (!t) return;
  var h = '<div style="padding:24px 28px;max-width:900px;">';

  // ── Header row: title + Save button ──
  h += '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:24px;">';
  h += '<div style="font-size:22px;font-weight:700;color:var(--text-primary);">' + (window._tplIsNew ? 'New Template' : 'Edit Template') + '</div>';
  h += '<div style="display:flex;gap:8px;">';
  if (!window._tplIsNew) {
    h += '<button onclick="deleteCurrentTemplate()" style="padding:8px 16px;border:1px solid #fca5a5;border-radius:8px;background:#fff;color:#dc2626;font-size:13px;font-weight:600;cursor:pointer;">Delete</button>';
  }
  h += '<button onclick="saveCurrentTemplate()" style="padding:8px 20px;border:none;border-radius:8px;background:var(--accent-gradient, linear-gradient(135deg,#6366f1,#8b5cf6));color:#fff;font-size:13px;font-weight:600;cursor:pointer;">Save Template</button>';
  h += '</div></div>';

  // ── Metadata section ──
  var inputStyle = 'width:100%;padding:10px 14px;border:1px solid #ddd;border-radius:8px;font-size:14px;outline:none;background:#fff;font-family:inherit;';
  var labelStyle = 'display:block;font-size:12px;font-weight:600;color:#555;margin-bottom:6px;text-transform:uppercase;letter-spacing:0.5px;';

  h += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:24px;">';
  // Template ID
  h += '<div><label style="' + labelStyle + '">Template ID</label>';
  h += '<input id="tpl-id" value="' + esc(t.template_id || '') + '" placeholder="e.g. estate_planning" style="' + inputStyle + '"' + (window._tplIsNew ? '' : ' disabled style="' + inputStyle + 'background:#f5f5f5;color:#999;"') + '/></div>';
  // Display Name
  h += '<div><label style="' + labelStyle + '">Display Name</label>';
  h += '<input id="tpl-name" value="' + esc(t.display_name || '') + '" placeholder="e.g. Estate Planning" style="' + inputStyle + '"/></div>';
  h += '</div>';

  // Description
  h += '<div style="margin-bottom:24px;"><label style="' + labelStyle + '">Description</label>';
  h += '<textarea id="tpl-desc" rows="2" placeholder="What this template is for..." style="' + inputStyle + 'resize:vertical;">' + esc(t.description || '') + '</textarea></div>';

  // Version badge
  h += '<div style="margin-bottom:24px;display:flex;gap:16px;align-items:center;">';
  h += '<span style="padding:4px 12px;background:#ede9fe;color:#6366f1;border-radius:16px;font-size:12px;font-weight:600;">v' + esc(t.version || '1.0.0') + '</span>';
  var dtCount = (t.document_types || []).length;
  var fieldCount = 0;
  for (var fc = 0; fc < (t.document_types || []).length; fc++) fieldCount += ((t.document_types[fc] || {}).extraction_spec || []).length;
  var roleCount = (t.entity_roles || []).length;
  var ruleCount = (t.cross_doc_rules || []).length;
  h += '<span style="font-size:12px;color:var(--text-muted);">' + dtCount + ' doc types &middot; ' + fieldCount + ' fields &middot; ' + roleCount + ' roles &middot; ' + ruleCount + ' rules</span>';
  h += '</div>';

  // ── Document Types Section ──
  h += _renderDocTypesSection(t);

  // ── Entity Roles Section ──
  h += _renderRolesSection(t);

  // ── Cross-Doc Rules Section ──
  h += _renderRulesSection(t);

  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

// ── Document Types Accordion ──
function _renderDocTypesSection(t) {
  var sectionHdr = 'font-size:16px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;';
  var cardStyle = 'border:1px solid #e5e7eb;border-radius:10px;margin-bottom:10px;overflow:hidden;background:#fff;';
  var cardHdr = 'padding:14px 16px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:background 0.15s;';
  var addBtn = 'display:inline-flex;align-items:center;gap:4px;padding:6px 14px;border:1px dashed #d1d5db;border-radius:8px;font-size:12px;color:#6366f1;cursor:pointer;background:transparent;font-weight:600;';

  var h = '<div style="margin-bottom:32px;">';
  h += '<div style="' + sectionHdr + '"><span>Document Types (' + (t.document_types || []).length + ')</span>';
  h += '<button onclick="tplAddDocType()" style="' + addBtn + '">+ Add Document Type</button></div>';

  for (var i = 0; i < (t.document_types || []).length; i++) {
    var dt = t.document_types[i];
    var expanded = window._tplExpandedDt[i];
    var specCount = (dt.extraction_spec || []).length;
    var sigCount = (dt.classification_signals || []).length;
    var priColor = dt.priority === 'HIGH' ? '#dc2626' : (dt.priority === 'MEDIUM' ? '#d97706' : '#6b7280');

    h += '<div style="' + cardStyle + '">';
    // Card header
    h += '<div style="' + cardHdr + (expanded ? 'background:#fafafe;border-bottom:1px solid #e5e7eb;' : '') + '" onclick="tplToggleDt(' + i + ')">';
    h += '<div style="display:flex;align-items:center;gap:10px;">';
    h += '<svg viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="1.5" style="width:18px;height:18px;transform:rotate(' + (expanded ? '90' : '0') + 'deg);transition:transform 0.2s;"><polyline points="9 18 15 12 9 6"/></svg>';
    h += '<div><div style="font-size:14px;font-weight:600;">' + esc(dt.display_name || dt.type_id || 'Unnamed') + '</div>';
    h += '<div style="font-size:11px;color:var(--text-muted);">' + esc(dt.type_id || '') + ' &middot; ' + esc(dt.category || '') + ' &middot; ' + specCount + ' fields &middot; ' + sigCount + ' signals</div></div>';
    h += '</div>';
    h += '<div style="display:flex;align-items:center;gap:8px;">';
    h += '<span style="padding:2px 8px;border-radius:10px;font-size:10px;font-weight:600;color:' + priColor + ';background:' + priColor + '15;">' + esc(dt.priority || 'MEDIUM') + '</span>';
    h += '<button onclick="event.stopPropagation();tplRemoveDocType(' + i + ')" style="border:none;background:none;cursor:pointer;color:#d1d5db;font-size:16px;" title="Remove">&times;</button>';
    h += '</div></div>';

    // Expanded body
    if (expanded) {
      h += '<div style="padding:16px;">';
      // Doc type metadata row
      h += '<div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;margin-bottom:16px;">';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Type ID</label><input value="' + esc(dt.type_id || '') + '" onchange="tplUpdateDt(' + i + ',\\'type_id\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Display Name</label><input value="' + esc(dt.display_name || '') + '" onchange="tplUpdateDt(' + i + ',\\'display_name\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Category</label><input value="' + esc(dt.category || '') + '" onchange="tplUpdateDt(' + i + ',\\'category\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Priority</label><select onchange="tplUpdateDt(' + i + ',\\'priority\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;">';
      var pris = ['HIGH', 'MEDIUM', 'LOW'];
      for (var pi = 0; pi < pris.length; pi++) {
        h += '<option value="' + pris[pi] + '"' + (dt.priority === pris[pi] ? ' selected' : '') + '>' + pris[pi] + '</option>';
      }
      h += '</select></div></div>';

      // Classification signals
      h += '<div style="margin-bottom:16px;">';
      h += '<label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Classification Signals (comma-separated)</label>';
      h += '<input value="' + esc((dt.classification_signals || []).join(', ')) + '" onchange="tplUpdateDtSignals(' + i + ',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;" placeholder="w2, form w-2, wage and tax statement"/>';
      h += '</div>';

      // Extraction spec fields table
      h += '<div style="margin-bottom:8px;display:flex;justify-content:space-between;align-items:center;">';
      h += '<span style="font-size:13px;font-weight:600;">Extraction Fields (' + specCount + ')</span>';
      h += '<button onclick="tplAddField(' + i + ')" style="border:1px dashed #d1d5db;border-radius:6px;background:transparent;padding:4px 10px;font-size:11px;color:#6366f1;cursor:pointer;font-weight:600;">+ Add Field</button>';
      h += '</div>';

      if (specCount > 0) {
        h += '<div style="border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;">';
        h += '<table style="width:100%;border-collapse:collapse;font-size:12px;">';
        h += '<thead><tr style="background:#f9fafb;"><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Field ID</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Display Name</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Type</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Tier</th><th style="padding:8px 10px;width:30px;"></th></tr></thead>';
        h += '<tbody>';
        for (var fi = 0; fi < specCount; fi++) {
          var field = dt.extraction_spec[fi];
          var tierBg = field.necessity_tier === 'BLOCKING' ? '#fef2f2' : (field.necessity_tier === 'EXPECTED' ? '#fffbeb' : '#f0fdf4');
          var tierColor = field.necessity_tier === 'BLOCKING' ? '#991B1B' : (field.necessity_tier === 'EXPECTED' ? '#92400E' : '#065F46');
          h += '<tr style="border-top:1px solid #f0f0f0;">';
          h += '<td style="padding:6px 10px;"><input value="' + esc(field.field_id || '') + '" onchange="tplUpdateField(' + i + ',' + fi + ',\\'field_id\\',this.value)" style="width:100%;padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;font-family:monospace;"/></td>';
          h += '<td style="padding:6px 10px;"><input value="' + esc(field.display_name || '') + '" onchange="tplUpdateField(' + i + ',' + fi + ',\\'display_name\\',this.value)" style="width:100%;padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;"/></td>';
          h += '<td style="padding:6px 10px;"><select onchange="tplUpdateField(' + i + ',' + fi + ',\\'type\\',this.value)" style="padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;">';
          var ftypes = ['string', 'number', 'currency', 'date', 'percentage', 'boolean', 'ssn', 'ein', 'phone', 'email', 'address'];
          for (var ft = 0; ft < ftypes.length; ft++) {
            h += '<option value="' + ftypes[ft] + '"' + ((field.type || 'string') === ftypes[ft] ? ' selected' : '') + '>' + ftypes[ft] + '</option>';
          }
          h += '</select></td>';
          h += '<td style="padding:6px 10px;"><select onchange="tplUpdateField(' + i + ',' + fi + ',\\'necessity_tier\\',this.value)" style="padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;background:' + tierBg + ';color:' + tierColor + ';font-weight:600;">';
          var tiers = ['BLOCKING', 'EXPECTED', 'ENRICHING'];
          for (var tt = 0; tt < tiers.length; tt++) {
            h += '<option value="' + tiers[tt] + '"' + ((field.necessity_tier || 'EXPECTED') === tiers[tt] ? ' selected' : '') + '>' + tiers[tt].charAt(0) + '</option>';
          }
          h += '</select></td>';
          h += '<td style="padding:6px 10px;text-align:center;"><button onclick="tplRemoveField(' + i + ',' + fi + ')" style="border:none;background:none;cursor:pointer;color:#d1d5db;font-size:14px;" title="Remove">&times;</button></td>';
          h += '</tr>';
        }
        h += '</tbody></table></div>';
      } else {
        h += '<div style="padding:16px;text-align:center;color:var(--text-muted);font-size:13px;border:1px dashed #e5e7eb;border-radius:8px;">No extraction fields yet. Click "+ Add Field" to define what data to extract from this document type.</div>';
      }

      h += '</div>'; // end expanded body
    }
    h += '</div>'; // end card
  }

  if ((t.document_types || []).length === 0) {
    h += '<div style="padding:24px;text-align:center;color:var(--text-muted);font-size:13px;border:1px dashed #e5e7eb;border-radius:10px;">No document types defined yet. Click "+ Add Document Type" to start building your template.</div>';
  }
  h += '</div>';
  return h;
}

// ── Entity Roles Accordion ──
function _renderRolesSection(t) {
  var sectionHdr = 'font-size:16px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;';
  var cardStyle = 'border:1px solid #e5e7eb;border-radius:10px;margin-bottom:10px;overflow:hidden;background:#fff;';
  var cardHdr = 'padding:14px 16px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:background 0.15s;';
  var addBtn = 'display:inline-flex;align-items:center;gap:4px;padding:6px 14px;border:1px dashed #d1d5db;border-radius:8px;font-size:12px;color:#6366f1;cursor:pointer;background:transparent;font-weight:600;';
  var tiers = ['BLOCKING', 'EXPECTED', 'ENRICHING'];

  var h = '<div style="margin-bottom:32px;">';
  h += '<div style="' + sectionHdr + '"><span>Entity Roles (' + (t.entity_roles || []).length + ')</span>';
  h += '<button onclick="tplAddRole()" style="' + addBtn + '">+ Add Role</button></div>';

  for (var i = 0; i < (t.entity_roles || []).length; i++) {
    var role = t.entity_roles[i];
    var expanded = window._tplExpandedRole[i];
    var rfCount = (role.required_fields || []).length;

    h += '<div style="' + cardStyle + '">';
    h += '<div style="' + cardHdr + (expanded ? 'background:#fafafe;border-bottom:1px solid #e5e7eb;' : '') + '" onclick="tplToggleRole(' + i + ')">';
    h += '<div style="display:flex;align-items:center;gap:10px;">';
    h += '<svg viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="1.5" style="width:18px;height:18px;transform:rotate(' + (expanded ? '90' : '0') + 'deg);transition:transform 0.2s;"><polyline points="9 18 15 12 9 6"/></svg>';
    h += '<div><div style="font-size:14px;font-weight:600;">' + esc(role.display_name || role.role_id || 'Unnamed Role') + '</div>';
    h += '<div style="font-size:11px;color:var(--text-muted);">' + esc(role.role_id || '') + ' &middot; ' + esc(role.type || 'person') + ' &middot; ' + rfCount + ' fields' + (role.optional ? ' &middot; optional' : '') + '</div></div>';
    h += '</div>';
    h += '<button onclick="event.stopPropagation();tplRemoveRole(' + i + ')" style="border:none;background:none;cursor:pointer;color:#d1d5db;font-size:16px;" title="Remove">&times;</button>';
    h += '</div>';

    if (expanded) {
      h += '<div style="padding:16px;">';
      // Role metadata
      h += '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-bottom:16px;">';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Role ID</label><input value="' + esc(role.role_id || '') + '" onchange="tplUpdateRole(' + i + ',\\'role_id\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Display Name</label><input value="' + esc(role.display_name || '') + '" onchange="tplUpdateRole(' + i + ',\\'display_name\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Entity Type</label><select onchange="tplUpdateRole(' + i + ',\\'type\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;">';
      var etypes = ['person', 'business', 'institution'];
      for (var ei = 0; ei < etypes.length; ei++) {
        h += '<option value="' + etypes[ei] + '"' + ((role.type || 'person') === etypes[ei] ? ' selected' : '') + '>' + etypes[ei] + '</option>';
      }
      h += '</select></div></div>';

      // Optional checkbox
      h += '<div style="margin-bottom:16px;"><label style="font-size:12px;color:#555;cursor:pointer;display:inline-flex;align-items:center;gap:6px;"><input type="checkbox"' + (role.optional ? ' checked' : '') + ' onchange="tplUpdateRole(' + i + ',\\'optional\\',this.checked)"/> This role is optional</label></div>';

      // Required fields
      h += '<div style="margin-bottom:8px;display:flex;justify-content:space-between;align-items:center;">';
      h += '<span style="font-size:13px;font-weight:600;">Required Fields (' + rfCount + ')</span>';
      h += '<button onclick="tplAddRoleField(' + i + ')" style="border:1px dashed #d1d5db;border-radius:6px;background:transparent;padding:4px 10px;font-size:11px;color:#6366f1;cursor:pointer;font-weight:600;">+ Add Field</button>';
      h += '</div>';

      if (rfCount > 0) {
        h += '<div style="border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;">';
        h += '<table style="width:100%;border-collapse:collapse;font-size:12px;">';
        h += '<thead><tr style="background:#f9fafb;"><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Field ID</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Display Name</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Type</th><th style="padding:8px 10px;text-align:left;font-weight:600;color:#6b7280;">Tier</th><th style="padding:8px 10px;width:30px;"></th></tr></thead>';
        h += '<tbody>';
        for (var ri = 0; ri < rfCount; ri++) {
          var rf = role.required_fields[ri];
          var rfObj = typeof rf === 'string' ? { field_id: role.role_id + '.' + rf, display_name: rf.replace(/_/g, ' '), field_type: 'text' } : rf;
          var rtierBg = (rfObj.necessity_tier || 'EXPECTED') === 'BLOCKING' ? '#fef2f2' : ((rfObj.necessity_tier || 'EXPECTED') === 'EXPECTED' ? '#fffbeb' : '#f0fdf4');
          var rtierColor = (rfObj.necessity_tier || 'EXPECTED') === 'BLOCKING' ? '#991B1B' : ((rfObj.necessity_tier || 'EXPECTED') === 'EXPECTED' ? '#92400E' : '#065F46');
          h += '<tr style="border-top:1px solid #f0f0f0;">';
          h += '<td style="padding:6px 10px;"><input value="' + esc(rfObj.field_id || '') + '" onchange="tplUpdateRoleField(' + i + ',' + ri + ',\\'field_id\\',this.value)" style="width:100%;padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;font-family:monospace;"/></td>';
          h += '<td style="padding:6px 10px;"><input value="' + esc(rfObj.display_name || '') + '" onchange="tplUpdateRoleField(' + i + ',' + ri + ',\\'display_name\\',this.value)" style="width:100%;padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;"/></td>';
          h += '<td style="padding:6px 10px;"><select onchange="tplUpdateRoleField(' + i + ',' + ri + ',\\'field_type\\',this.value)" style="padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;">';
          var rftypes = ['text', 'number', 'date', 'ssn', 'ein', 'phone', 'email', 'address'];
          for (var rft = 0; rft < rftypes.length; rft++) {
            h += '<option value="' + rftypes[rft] + '"' + ((rfObj.field_type || 'text') === rftypes[rft] ? ' selected' : '') + '>' + rftypes[rft] + '</option>';
          }
          h += '</select></td>';
          h += '<td style="padding:6px 10px;"><select onchange="tplUpdateRoleField(' + i + ',' + ri + ',\\'necessity_tier\\',this.value)" style="padding:4px 6px;border:1px solid #e5e7eb;border-radius:4px;font-size:12px;background:' + rtierBg + ';color:' + rtierColor + ';font-weight:600;">';
          for (var rtt = 0; rtt < tiers.length; rtt++) {
            h += '<option value="' + tiers[rtt] + '"' + ((rfObj.necessity_tier || 'EXPECTED') === tiers[rtt] ? ' selected' : '') + '>' + tiers[rtt].charAt(0) + '</option>';
          }
          h += '</select></td>';
          h += '<td style="padding:6px 10px;text-align:center;"><button onclick="tplRemoveRoleField(' + i + ',' + ri + ')" style="border:none;background:none;cursor:pointer;color:#d1d5db;font-size:14px;" title="Remove">&times;</button></td>';
          h += '</tr>';
        }
        h += '</tbody></table></div>';
      } else {
        h += '<div style="padding:12px;text-align:center;color:var(--text-muted);font-size:12px;border:1px dashed #e5e7eb;border-radius:8px;">No fields yet.</div>';
      }
      h += '</div>';
    }
    h += '</div>';
  }

  if ((t.entity_roles || []).length === 0) {
    h += '<div style="padding:24px;text-align:center;color:var(--text-muted);font-size:13px;border:1px dashed #e5e7eb;border-radius:10px;">No entity roles defined. Click "+ Add Role" to define required parties (e.g., Plaintiff, Business Entity).</div>';
  }
  h += '</div>';
  return h;
}

// ── Cross-Doc Rules Section ──
function _renderRulesSection(t) {
  var sectionHdr = 'font-size:16px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;';
  var cardStyle = 'border:1px solid #e5e7eb;border-radius:10px;margin-bottom:10px;overflow:hidden;background:#fff;';
  var cardHdr = 'padding:14px 16px;display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:background 0.15s;';
  var addBtn = 'display:inline-flex;align-items:center;gap:4px;padding:6px 14px;border:1px dashed #d1d5db;border-radius:8px;font-size:12px;color:#6366f1;cursor:pointer;background:transparent;font-weight:600;';

  var h = '<div style="margin-bottom:32px;">';
  h += '<div style="' + sectionHdr + '"><span>Cross-Document Rules (' + (t.cross_doc_rules || []).length + ')</span>';
  h += '<button onclick="tplAddRule()" style="' + addBtn + '">+ Add Rule</button></div>';

  for (var i = 0; i < (t.cross_doc_rules || []).length; i++) {
    var rule = t.cross_doc_rules[i];
    var expanded = window._tplExpandedRule[i];
    var sevColor = (rule.severity || 'WARNING') === 'CRITICAL' ? '#dc2626' : '#d97706';

    h += '<div style="' + cardStyle + '">';
    h += '<div style="' + cardHdr + (expanded ? 'background:#fafafe;border-bottom:1px solid #e5e7eb;' : '') + '" onclick="tplToggleRule(' + i + ')">';
    h += '<div style="display:flex;align-items:center;gap:10px;">';
    h += '<svg viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="1.5" style="width:18px;height:18px;transform:rotate(' + (expanded ? '90' : '0') + 'deg);transition:transform 0.2s;"><polyline points="9 18 15 12 9 6"/></svg>';
    h += '<div><div style="font-size:14px;font-weight:600;">' + esc(rule.rule_id || 'Unnamed Rule') + '</div>';
    h += '<div style="font-size:11px;color:var(--text-muted);">' + esc(rule.description || '') + '</div></div>';
    h += '</div>';
    h += '<div style="display:flex;align-items:center;gap:8px;">';
    h += '<span style="padding:2px 8px;border-radius:10px;font-size:10px;font-weight:600;color:' + sevColor + ';background:' + sevColor + '15;">' + esc(rule.severity || 'WARNING') + '</span>';
    h += '<button onclick="event.stopPropagation();tplRemoveRule(' + i + ')" style="border:none;background:none;cursor:pointer;color:#d1d5db;font-size:16px;" title="Remove">&times;</button>';
    h += '</div></div>';

    if (expanded) {
      h += '<div style="padding:16px;">';
      h += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;">';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Rule ID</label><input value="' + esc(rule.rule_id || '') + '" onchange="tplUpdateRule(' + i + ',\\'rule_id\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Severity</label><select onchange="tplUpdateRule(' + i + ',\\'severity\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;">';
      h += '<option value="CRITICAL"' + (rule.severity === 'CRITICAL' ? ' selected' : '') + '>CRITICAL</option>';
      h += '<option value="WARNING"' + (rule.severity === 'WARNING' || !rule.severity ? ' selected' : '') + '>WARNING</option>';
      h += '</select></div></div>';
      h += '<div style="margin-bottom:12px;"><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Description</label><input value="' + esc(rule.description || '') + '" onchange="tplUpdateRule(' + i + ',\\'description\\',this.value)" style="width:100%;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;"/></div>';

      h += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;">';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Document A &middot; Field</label>';
      h += '<div style="display:flex;gap:6px;"><input value="' + esc(rule.doc_a || '') + '" onchange="tplUpdateRule(' + i + ',\\'doc_a\\',this.value)" placeholder="doc_type_id" style="flex:1;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:12px;font-family:monospace;"/>';
      h += '<input value="' + esc(rule.field_a || '') + '" onchange="tplUpdateRule(' + i + ',\\'field_a\\',this.value)" placeholder="field_id" style="flex:1;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:12px;font-family:monospace;"/></div></div>';
      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Document B &middot; Field</label>';
      h += '<div style="display:flex;gap:6px;"><input value="' + esc(rule.doc_b || '') + '" onchange="tplUpdateRule(' + i + ',\\'doc_b\\',this.value)" placeholder="doc_type_id" style="flex:1;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:12px;font-family:monospace;"/>';
      h += '<input value="' + esc(rule.field_b || '') + '" onchange="tplUpdateRule(' + i + ',\\'field_b\\',this.value)" placeholder="field_id" style="flex:1;padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:12px;font-family:monospace;"/></div></div></div>';

      h += '<div><label style="font-size:11px;font-weight:600;color:#888;display:block;margin-bottom:4px;">Check Type</label><select onchange="tplUpdateRule(' + i + ',\\'check_type\\',this.value)" style="padding:6px 10px;border:1px solid #e5e7eb;border-radius:6px;font-size:13px;">';
      var checks = ['values_must_match', 'mutual_exclusion', 'date_must_precede', 'sum_must_equal', 'expiration_check'];
      for (var ci = 0; ci < checks.length; ci++) {
        h += '<option value="' + checks[ci] + '"' + ((rule.check_type || 'values_must_match') === checks[ci] ? ' selected' : '') + '>' + checks[ci].replace(/_/g, ' ') + '</option>';
      }
      h += '</select></div>';
      h += '</div>';
    }
    h += '</div>';
  }

  if ((t.cross_doc_rules || []).length === 0) {
    h += '<div style="padding:24px;text-align:center;color:var(--text-muted);font-size:13px;border:1px dashed #e5e7eb;border-radius:10px;">No cross-document validation rules. Click "+ Add Rule" to define integrity checks across document types.</div>';
  }
  h += '</div>';
  return h;
}

// ── Template Builder Action Functions ──

function tplToggleDt(i) { window._tplExpandedDt[i] = !window._tplExpandedDt[i]; renderTemplateEditor(); }
function tplToggleRole(i) { window._tplExpandedRole[i] = !window._tplExpandedRole[i]; renderTemplateEditor(); }
function tplToggleRule(i) { window._tplExpandedRule[i] = !window._tplExpandedRule[i]; renderTemplateEditor(); }

function tplAddDocType() {
  var t = window._tplEdit;
  t.document_types.push({ type_id: '', display_name: '', category: '', priority: 'MEDIUM', classification_signals: [], extraction_spec: [] });
  window._tplExpandedDt[t.document_types.length - 1] = true;
  renderTemplateEditor();
}
function tplRemoveDocType(i) { window._tplEdit.document_types.splice(i, 1); delete window._tplExpandedDt[i]; renderTemplateEditor(); }
function tplUpdateDt(i, key, val) { window._tplEdit.document_types[i][key] = val; }
function tplUpdateDtSignals(i, val) { window._tplEdit.document_types[i].classification_signals = val.split(',').map(function(s) { return s.trim(); }).filter(Boolean); }

function tplAddField(dtIdx) {
  var spec = window._tplEdit.document_types[dtIdx].extraction_spec;
  spec.push({ field_id: '', display_name: '', type: 'string', necessity_tier: 'EXPECTED' });
  renderTemplateEditor();
}
function tplRemoveField(dtIdx, fIdx) { window._tplEdit.document_types[dtIdx].extraction_spec.splice(fIdx, 1); renderTemplateEditor(); }
function tplUpdateField(dtIdx, fIdx, key, val) { window._tplEdit.document_types[dtIdx].extraction_spec[fIdx][key] = val; }

function tplAddRole() {
  var t = window._tplEdit;
  t.entity_roles.push({ role_id: '', display_name: '', type: 'person', optional: false, required_fields: [] });
  window._tplExpandedRole[t.entity_roles.length - 1] = true;
  renderTemplateEditor();
}
function tplRemoveRole(i) { window._tplEdit.entity_roles.splice(i, 1); delete window._tplExpandedRole[i]; renderTemplateEditor(); }
function tplUpdateRole(i, key, val) { window._tplEdit.entity_roles[i][key] = val; }

function tplAddRoleField(roleIdx) {
  var role = window._tplEdit.entity_roles[roleIdx];
  if (!role.required_fields) role.required_fields = [];
  var prefix = role.role_id ? role.role_id + '.' : '';
  role.required_fields.push({ field_id: prefix, display_name: '', field_type: 'text', necessity_tier: 'EXPECTED' });
  renderTemplateEditor();
}
function tplRemoveRoleField(roleIdx, fIdx) { window._tplEdit.entity_roles[roleIdx].required_fields.splice(fIdx, 1); renderTemplateEditor(); }
function tplUpdateRoleField(roleIdx, fIdx, key, val) {
  var rf = window._tplEdit.entity_roles[roleIdx].required_fields[fIdx];
  if (typeof rf === 'string') {
    window._tplEdit.entity_roles[roleIdx].required_fields[fIdx] = { field_id: rf, display_name: rf.replace(/_/g, ' '), field_type: 'text', necessity_tier: 'EXPECTED' };
    rf = window._tplEdit.entity_roles[roleIdx].required_fields[fIdx];
  }
  rf[key] = val;
  // Auto-flag sensitive field types as BLOCKING
  if (key === 'field_type' && ['ssn', 'ein'].indexOf(val) >= 0) {
    rf.necessity_tier = 'BLOCKING';
    rf.sensitivity = 'CRITICAL';
    renderTemplateEditor();
  }
}

function tplAddRule() {
  var t = window._tplEdit;
  t.cross_doc_rules.push({ rule_id: '', description: '', severity: 'WARNING', doc_a: '', field_a: '', doc_b: '', field_b: '', check_type: 'values_must_match' });
  window._tplExpandedRule[t.cross_doc_rules.length - 1] = true;
  renderTemplateEditor();
}
function tplRemoveRule(i) { window._tplEdit.cross_doc_rules.splice(i, 1); delete window._tplExpandedRule[i]; renderTemplateEditor(); }
function tplUpdateRule(i, key, val) { window._tplEdit.cross_doc_rules[i][key] = val; }

function saveCurrentTemplate() {
  var t = window._tplEdit;
  // Read metadata from DOM inputs
  var idEl = document.getElementById('tpl-id');
  var nameEl = document.getElementById('tpl-name');
  var descEl = document.getElementById('tpl-desc');
  if (idEl) t.template_id = idEl.value.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_');
  if (nameEl) t.display_name = nameEl.value.trim();
  if (descEl) t.description = descEl.value.trim();

  if (!t.template_id) { toast('Template ID is required'); return; }
  if (!t.display_name) { toast('Display name is required'); return; }

  var method = window._tplIsNew ? 'POST' : 'PUT';
  var url = window._tplIsNew ? '/api/templates' : '/api/templates/' + encodeURIComponent(t.template_id);

  api(method, url, t).then(function(data) {
    toast('Template saved! v' + (data.version || t.version));
    window._tplIsNew = false;
    window._selectedTemplate = t.template_id;
    if (data.version) t.version = data.version;
    loadTemplates();
    renderTemplateEditor();
  }).catch(function(err) {
    toast('Error: ' + (err.message || err));
  });
}

function deleteCurrentTemplate() {
  var t = window._tplEdit;
  if (!t || !t.template_id) return;
  if (!confirm('Delete template "' + (t.display_name || t.template_id) + '"? This cannot be undone.')) return;
  api('DELETE', '/api/templates/' + encodeURIComponent(t.template_id)).then(function() {
    toast('Template deleted');
    window._tplEdit = null;
    window._selectedTemplate = null;
    selectedView = null;
    loadTemplates();
    showClientDashboard();
  }).catch(function(err) {
    toast('Error: ' + (err.message || err));
  });
}

function showClientDashboard() {
  _selectedSpoke = null;
  selectedView = 'client_dashboard';
  selectedId = null;
  selectedCategory = null;
  breadcrumbs = [{ label: 'Dashboard' }];
  renderBreadcrumbs();
  renderSidebar();
  renderClientDashboard();
}

window._dashboardSortCol = 'completeness';
window._dashboardSortAsc = true;
window._dashboardActiveChip = null;
window._dashboardData = null;

function renderClientDashboard() {
  var mainEl = document.getElementById('main');

  // Fetch from the dashboard API for rich data
  api('GET', '/api/dashboard').then(function(data) {
    window._dashboardData = data;
    renderDashboardContent(data);
  }).catch(function(err) {
    // Fallback to local spoke data
    var clientSpokes = _spokesList.filter(function(s) { return s.id !== 'default'; });
    if (clientSpokes.length === 0) {
      mainEl.innerHTML = '<div class="empty-state"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" opacity="0.2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg><div>No clients yet.<br/><span style="color:var(--accent-primary);cursor:pointer;" onclick="promptNewClient()">+ Add your first client</span></div></div>';
    }
  });
}

function renderDashboardContent(data) {
  var spokes = data.spokes || [];
  var stats = data.stats || {};
  var filterChips = data.filter_chips || [];
  var mainEl = document.getElementById('main');

  if (spokes.length === 0) {
    mainEl.innerHTML = '<div class="empty-state"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" opacity="0.2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg><div>No clients yet.<br/><span style="color:var(--accent-primary);cursor:pointer;" onclick="promptNewClient()">+ Add your first client</span></div></div>';
    return;
  }

  var h = '<div style="padding:24px 28px;">';

  // Header row with title + New Client button
  h += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">';
  h += '<div style="font-size:22px;font-weight:700;">Client Dashboard</div>';
  h += '<button onclick="promptNewClient()" style="display:flex;align-items:center;gap:6px;padding:8px 16px;border:none;border-radius:8px;background:var(--accent-gradient, linear-gradient(135deg,#6366f1,#8b5cf6));color:#fff;font-size:13px;font-weight:600;cursor:pointer;transition:opacity 0.2s;" onmouseover="this.style.opacity=\\'0.9\\'" onmouseout="this.style.opacity=\\'1\\'"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>New Client</button>';
  h += '</div>';

  // Summary stats header (Build 11 + 11.5)
  h += '<div style="display:flex;gap:12px;margin-bottom:20px;flex-wrap:wrap;">';
  h += '<div style="padding:14px 20px;background:#f8f8fa;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:var(--text-primary);">' + stats.total + '</strong><span style="color:var(--text-muted);">Total Clients</span></div>';
  if (stats.filing_not_ready > 0) h += '<div style="padding:14px 20px;background:#fef2f2;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:#991B1B;">' + stats.filing_not_ready + '</strong><span style="color:#991B1B;">Filing Not Ready</span></div>';
  if (stats.critical > 0) h += '<div style="padding:14px 20px;background:#fff7ed;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:#9A3412;">' + stats.critical + '</strong><span style="color:#9A3412;">Critical (&lt;50%)</span></div>';
  if (stats.in_progress > 0) h += '<div style="padding:14px 20px;background:#fefce8;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:#92400E;">' + stats.in_progress + '</strong><span style="color:#92400E;">In Progress</span></div>';
  if (stats.filing_ready > 0) h += '<div style="padding:14px 20px;background:#f0fdf4;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:#065F46;">' + stats.filing_ready + '</strong><span style="color:#065F46;">Filing Ready</span></div>';
  if (stats.fully_reviewed > 0) h += '<div style="padding:14px 20px;background:#eff6ff;border-radius:10px;font-size:13px;flex:1;min-width:100px;text-align:center;"><strong style="font-size:22px;display:block;color:#1D4ED8;">' + stats.fully_reviewed + '</strong><span style="color:#1D4ED8;">Fully Reviewed</span></div>';
  h += '</div>';

  // Filter chips (Build 11 + 11.5)
  if (filterChips.length > 0) {
    h += '<div style="display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;">';
    for (var ci = 0; ci < filterChips.length; ci++) {
      var chip = filterChips[ci];
      var isActive = (window._dashboardActiveChip === chip.id);
      var chipBg = isActive ? 'var(--accent-primary)' : (chip.type === 'universal' ? '#f0f0f2' : '#ede9fe');
      var chipColor = isActive ? '#fff' : (chip.type === 'universal' ? 'var(--text-secondary)' : '#6366f1');
      h += '<span data-chip="' + esc(chip.id) + '" onclick="toggleDashboardChip(\\'' + esc(chip.id) + '\\')" style="display:inline-flex;align-items:center;padding:5px 14px;border-radius:20px;font-size:12px;font-weight:500;cursor:pointer;background:' + chipBg + ';color:' + chipColor + ';transition:all 0.15s;border:1px solid ' + (isActive ? 'var(--accent-primary)' : 'transparent') + ';">' + esc(chip.label) + '</span>';
    }
    h += '</div>';
  }

  // Apply filter (Build 11 + 11.5 tier-aware filters)
  var filtered = spokes;
  if (window._dashboardActiveChip && window._dashboardData) {
    var activeChip = filterChips.find(function(c) { return c.id === window._dashboardActiveChip; });
    if (activeChip && activeChip.filter) {
      filtered = spokes.filter(function(s) {
        if (activeChip.filter.completeness_max != null && (s.completeness_pct == null || s.completeness_pct > activeChip.filter.completeness_max)) return false;
        if (activeChip.filter.completeness_min != null && (s.completeness_pct == null || s.completeness_pct < activeChip.filter.completeness_min)) return false;
        if (activeChip.filter.review_incomplete && s.total_reviewable > 0 && s.reviewed_count >= s.total_reviewable) return false;
        if (activeChip.filter.missing_document && !s.missing_documents.includes(activeChip.filter.missing_document)) return false;
        if (activeChip.filter.has_cross_doc_violations && s.cross_doc_violations === 0) return false;
        if (activeChip.filter.filing_not_ready && (s.filing_readiness_pct == null || s.filing_readiness_pct >= 100)) return false;
        if (activeChip.filter.quality_max != null && (s.quality_score_pct == null || s.quality_score_pct > activeChip.filter.quality_max)) return false;
        if (activeChip.template_type && s.template_type !== activeChip.template_type) return false;
        return true;
      });
    }
  }

  // Sort
  var sortCol = window._dashboardSortCol;
  var sortAsc = window._dashboardSortAsc;
  filtered.sort(function(a, b) {
    var av, bv;
    if (sortCol === 'name') { av = (a.name || '').toLowerCase(); bv = (b.name || '').toLowerCase(); return sortAsc ? (av < bv ? -1 : 1) : (bv < av ? -1 : 1); }
    if (sortCol === 'template') { av = (a.template_label || '').toLowerCase(); bv = (b.template_label || '').toLowerCase(); return sortAsc ? (av < bv ? -1 : 1) : (bv < av ? -1 : 1); }
    if (sortCol === 'filing') { av = a.filing_readiness_pct != null ? a.filing_readiness_pct : -1; bv = b.filing_readiness_pct != null ? b.filing_readiness_pct : -1; return sortAsc ? av - bv : bv - av; }
    if (sortCol === 'quality') { av = a.quality_score_pct != null ? a.quality_score_pct : -1; bv = b.quality_score_pct != null ? b.quality_score_pct : -1; return sortAsc ? av - bv : bv - av; }
    if (sortCol === 'completeness') { av = a.completeness_pct != null ? a.completeness_pct : -1; bv = b.completeness_pct != null ? b.completeness_pct : -1; return sortAsc ? av - bv : bv - av; }
    if (sortCol === 'review') { av = a.reviewed_count || 0; bv = b.reviewed_count || 0; return sortAsc ? av - bv : bv - av; }
    if (sortCol === 'entities') { av = a.entity_count || 0; bv = b.entity_count || 0; return sortAsc ? av - bv : bv - av; }
    if (sortCol === 'updated') { av = a.last_updated || ''; bv = b.last_updated || ''; return sortAsc ? (av < bv ? -1 : 1) : (bv < av ? -1 : 1); }
    return 0;
  });

  // Helper: render a mini tier bar
  function tierBar(pct, color, label) {
    if (pct == null) return '<span style="color:var(--text-muted);font-size:10px;">\\u2014</span>';
    var w = Math.min(pct, 100);
    return '<div style="display:flex;align-items:center;gap:4px;margin-bottom:2px;" title="' + label + ': ' + pct + '%">' +
      '<div style="width:60px;height:5px;background:#e8e8e8;border-radius:3px;overflow:hidden;"><div style="width:' + w + '%;height:100%;background:' + color + ';border-radius:3px;"></div></div>' +
      '<span style="font-size:10px;font-weight:600;color:' + color + ';min-width:28px;">' + pct + '%</span>' +
      '</div>';
  }

  // Table (Build 11.5 — three-tier columns)
  h += '<table style="width:100%;border-collapse:collapse;font-size:14px;">';
  h += '<thead><tr style="border-bottom:2px solid #e8e8e8;text-align:left;">';
  var cols = [
    { key: 'name', label: 'Client' },
    { key: 'template', label: 'Template' },
    { key: 'filing', label: 'Filing Ready' },
    { key: 'quality', label: 'Quality' },
    { key: 'completeness', label: 'Complete' },
    { key: 'review', label: 'Review' },
    { key: 'entities', label: 'Ent.' },
    { key: 'updated', label: 'Updated' }
  ];
  for (var ci = 0; ci < cols.length; ci++) {
    var col = cols[ci];
    var arrow = (sortCol === col.key) ? (sortAsc ? ' \\u25B2' : ' \\u25BC') : '';
    h += '<th style="padding:10px 8px;font-weight:600;color:var(--text-secondary);cursor:pointer;user-select:none;white-space:nowrap;font-size:12px;" onclick="sortDashboard(\\'' + col.key + '\\')">' + col.label + arrow + '</th>';
  }
  h += '</tr></thead><tbody>';

  for (var i = 0; i < filtered.length; i++) {
    var s = filtered[i];
    var updated = s.last_updated ? new Date(s.last_updated).toLocaleDateString() : '\\u2014';
    var templateLabel = s.template_label || '\\u2014';

    // Filing readiness color: red if <100, green if 100
    var frPct = s.filing_readiness_pct;
    var frColor = frPct == null ? '#999' : (frPct >= 100 ? '#16A34A' : frPct >= 80 ? '#CA8A04' : '#DC2626');
    // Quality color
    var qPct = s.quality_score_pct;
    var qColor = qPct == null ? '#999' : (qPct >= 80 ? '#16A34A' : qPct >= 50 ? '#CA8A04' : '#DC2626');
    // Completeness color
    var cPct = s.completeness_score_pct != null ? s.completeness_score_pct : s.completeness_pct;
    var cColor = cPct == null ? '#999' : (cPct >= 80 ? '#16A34A' : cPct >= 50 ? '#CA8A04' : '#DC2626');

    h += '<tr style="border-bottom:1px solid #f0f0f0;cursor:pointer;transition:background 0.15s;" onclick="selectClient(\\'' + esc(s.spoke_id) + '\\')" onmouseover="this.style.background=\\'#f8f8fa\\'" onmouseout="this.style.background=\\'\\'">';
    h += '<td style="padding:10px 8px;font-weight:500;max-width:160px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + esc(s.name) + '</td>';
    h += '<td style="padding:10px 8px;"><span style="display:inline-block;padding:2px 8px;border-radius:10px;font-size:11px;background:#f0f0f2;color:var(--text-secondary);white-space:nowrap;max-width:120px;overflow:hidden;text-overflow:ellipsis;">' + esc(templateLabel) + '</span></td>';
    // Filing Readiness
    h += '<td style="padding:10px 8px;">' + tierBar(frPct, frColor, 'Filing Readiness') + '</td>';
    // Quality Score
    h += '<td style="padding:10px 8px;">' + tierBar(qPct, qColor, 'Quality Score') + '</td>';
    // Completeness
    h += '<td style="padding:10px 8px;">' + tierBar(cPct, cColor, 'Completeness') + '</td>';
    h += '<td style="padding:10px 8px;"><span style="font-size:12px;color:var(--text-muted);">' + esc(s.review_status) + '</span></td>';
    h += '<td style="padding:10px 8px;text-align:center;"><span style="display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:50%;background:#f0f0f2;font-size:11px;font-weight:600;color:var(--text-secondary);">' + (s.entity_count || 0) + '</span></td>';
    h += '<td style="padding:10px 8px;color:var(--text-muted);font-size:12px;">' + esc(updated) + '</td>';
    h += '</tr>';
  }

  h += '</tbody></table>';
  if (filtered.length === 0 && spokes.length > 0) {
    h += '<div style="padding:40px;text-align:center;color:var(--text-muted);font-size:14px;">No clients match this filter.</div>';
  }
  h += '</div>';

  mainEl.innerHTML = h;
}

function sortDashboard(col) {
  if (window._dashboardSortCol === col) {
    window._dashboardSortAsc = !window._dashboardSortAsc;
  } else {
    window._dashboardSortCol = col;
    window._dashboardSortAsc = (col === 'filing' || col === 'completeness' || col === 'quality'); // tier cols default asc
  }
  if (window._dashboardData) renderDashboardContent(window._dashboardData);
}

function toggleDashboardChip(chipId) {
  window._dashboardActiveChip = (window._dashboardActiveChip === chipId) ? null : chipId;
  if (window._dashboardData) renderDashboardContent(window._dashboardData);
}

/* --- End Client Navigation (Build 8) --- */

/* --- Entity Detail --- */
function confirmDeleteEntity(id, name) {
  if (id === primaryEntityId) { toast('Cannot delete the self entity'); return; }
  if (!confirm('Delete "' + name + '" (' + id + ') and all connected objects? This cannot be undone.')) return;
  api('DELETE', '/api/entity/' + id).then(function(result) {
    toast('Deleted ' + id + (result.connected_deleted && result.connected_deleted.length > 0 ? ' + ' + result.connected_deleted.length + ' connected objects' : ''));
    selectedId = null;
    selectedData = null;
    breadcrumbs = [];
    renderBreadcrumbs();
    document.getElementById('main').innerHTML = '<div class="empty-state">Entity deleted. Select another entity.</div>';
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  }).catch(function(err) {
    toast('Delete failed: ' + err.message);
  });
}

function selectEntity(id, fromCategory) {
  // FIX 1: CJ Mitchell connection links redirect to People Hub
  if (id === primaryEntityId) { showPeopleHub('all'); return; }
  var prevCategory = fromCategory || selectedCategory;
  selectedId = id;
  selectedView = null;
  selectedCategory = null;
  window._liActiveTab = 'overview'; // Reset tab when selecting new entity
  var mainEl = document.getElementById('main');
  if (mainEl) mainEl.className = ''; // Reset background class
  var empty = document.getElementById('emptyState');
  if (empty) empty.style.display = 'none';
  api('GET', '/api/entity/' + id).then(function(data) {
    selectedData = data;
    var type = (data.entity || {}).entity_type || '';
    var eName = type === 'person' ? ((data.entity.name || {}).full || '') : ((data.entity.name || {}).common || (data.entity.name || {}).legal || '');
    trackRecentEntity(id, eName || id);
    // Build breadcrumbs based on entity type and navigation context
    var catLabels = { family: 'Family', friends: 'Friends', professional: 'Professional', community: 'Communities', other: 'Other' };
    if (type === 'person' && prevCategory && catLabels[prevCategory]) {
      breadcrumbs = [
        { label: 'People', action: '' },
        { label: catLabels[prevCategory], action: 'selectCategoryPage(' + "'" + prevCategory + "'" + ')' },
        { label: eName || id }
      ];
    } else if (type === 'organization' || type === 'business' || type === 'institution') {
      var orgCatLabels = { org_career: 'Career', org_education: 'Education', org_affiliations: 'Organizations', org_services: 'Services', org_other: 'Other' };
      if (prevCategory && orgCatLabels[prevCategory]) {
        var orgCatKey = prevCategory.replace('org_', '');
        breadcrumbs = [
          { label: 'Affiliations', action: 'showAffiliationsHub()' },
          { label: orgCatLabels[prevCategory], action: 'showAffiliationsHub(' + "'" + orgCatKey + "'" + ')' },
          { label: eName || id }
        ];
      } else {
        breadcrumbs = [
          { label: 'Affiliations', action: 'showAffiliationsHub()' },
          { label: eName || id }
        ];
      }
    } else if (type === 'person') {
      breadcrumbs = [
        { label: 'People', action: '' },
        { label: eName || id }
      ];
    } else {
      breadcrumbs = [
        { label: eName || id }
      ];
    }
    renderBreadcrumbs();
    if (type === 'organization' || type === 'business' || type === 'institution') {
      return api('GET', '/api/entity/' + id + '/dossier').then(function(dossier) {
        renderOrgDossier(dossier);
        renderRightPanel(data);
        renderSidebar();
      });
    }
    renderDetail(data);
    renderSidebar();
  }).catch(function(err) {
    document.getElementById('main').innerHTML = '<div class="empty-state">Error loading entity: ' + esc(err.message) + '</div>';
  });
}

function confidenceBadge(conf, label) {
  if (conf == null && !label) return '';
  var lbl = label || '';
  if (conf >= 0.90 || lbl === 'VERIFIED') { lbl = lbl || 'VERIFIED'; }
  else if (conf >= 0.75 || lbl === 'STRONG') { lbl = lbl || 'STRONG'; }
  else if (conf >= 0.50 || lbl === 'MODERATE') { lbl = lbl || 'MODERATE'; }
  else if (conf >= 0.25 || lbl === 'SPECULATIVE') { lbl = lbl || 'SPECULATIVE'; }
  else { lbl = lbl || 'UNCERTAIN'; }
  // Color-coded: green >0.7, orange 0.4-0.7, red <0.4
  var confCls = 'conf-mid';
  var numConf = (conf != null) ? conf : (lbl === 'VERIFIED' ? 0.95 : lbl === 'STRONG' ? 0.8 : lbl === 'MODERATE' ? 0.6 : lbl === 'SPECULATIVE' ? 0.3 : 0.15);
  if (numConf > 0.7) confCls = 'conf-high';
  else if (numConf < 0.4) confCls = 'conf-low';
  return ' <span class="conf-badge ' + confCls + '"><span class="conf-dot"></span>' + lbl + (conf != null ? ' ' + conf.toFixed(2) : '') + '</span>';
}

function layerBadge(layer) {
  if (!layer) return '';
  var labels = { 1: 'Objective', 2: 'Group', 3: 'Personal' };
  return ' <span class="badge badge-layer badge-layer-' + layer + '">L' + layer + ' ' + (labels[layer] || '') + '</span>';
}

function sentimentBadge(s) {
  if (!s) return '';
  var cls = 'sentiment-neutral';
  if (s === 'positive') cls = 'sentiment-positive';
  else if (s === 'strained') cls = 'sentiment-strained';
  return ' <span class="rel-sentiment ' + cls + '">' + esc(s) + '</span>';
}

function computeEntityTier(entityId) {
  if (entityId === primaryEntityId) return 'self';
  // Check if entity has direct relationship to self
  if (primaryEntityData && primaryEntityData.relationships) {
    for (var i = 0; i < primaryEntityData.relationships.length; i++) {
      var r = primaryEntityData.relationships[i];
      if (r.target_entity_id === entityId || r.name === entityId) return 'inner';
    }
  }
  return 'outer';
}

function computeEntityHealth(data) {
  // Score based on: observations count, attributes count, relationships count, recency
  var score = 0;
  var obs = data.observations || [];
  var attrs = data.attributes || [];
  var rels = data.relationships || [];
  var cl = data.career_lite || {};

  score += Math.min(obs.length * 0.5, 2);  // max 2 from observations
  score += Math.min(attrs.length * 0.3, 1.5); // max 1.5 from attributes
  score += Math.min(rels.length * 0.3, 1); // max 1 from relationships
  // Career lite data richness
  if (cl.work_history && cl.work_history.length > 0) score += 0.5;
  if (cl.education && cl.education.length > 0) score += 0.5;
  if (cl.skills && cl.skills.length > 0) score += 0.5;
  if (cl.headline) score += 0.2;
  if (cl.location) score += 0.2;
  // Summary
  if (data.entity && data.entity.summary && data.entity.summary.value) score += 0.5;
  // Conflict penalty: -0.1 per active FACTUAL conflict
  var activeConflicts = (data.conflicts || []).filter(function(c) { return c.conflict_type === 'FACTUAL'; });
  score = Math.max(0, score - (activeConflicts.length * 0.1));
  // Normalize: thin <2, developing 2-4, strong >4
  if (score >= 4) return { level: 'strong', label: 'Strong', score: score };
  if (score >= 2) return { level: 'developing', label: 'Developing', score: score };
  return { level: 'thin', label: 'Thin', score: score };
}

function renderHealthIndicator(health) {
  var dots = health.level === 'strong' ? 3 : health.level === 'developing' ? 2 : 1;
  var h = '<span class="health-indicator health-' + health.level + '">';
  h += '<span class="health-dots">';
  for (var i = 0; i < 3; i++) {
    h += '<span class="health-dot' + (i < dots ? ' filled' : '') + '"></span>';
  }
  h += '</span>' + esc(health.label) + '</span>';
  return h;
}

function renderTierBadge(entityId) {
  var tier = computeEntityTier(entityId);
  return '<span class="tier-badge tier-' + tier + '">' + tier.toUpperCase() + '</span>';
}

function classifyRelTier(r) {
  var type = (r.relationship_type || '').toLowerCase();
  var context = (r.context || '').toLowerCase();
  var combined = ' ' + type + ' ' + context + ' ';
  var tiers = {
    5: ['spouse','wife','husband','son','daughter','sister','brother',
      'mother','father','parent','child','ex-spouse','ex-wife','ex-husband',
      'godparent','godmother','godfather','godson','goddaughter','sibling',
      'uncle','aunt','cousin','nephew','niece','family','in-law'],
    4: ['friend','close friend','best friend','groomsman','bridesmaid',
      'homie','mba homie','buddy','confidant','collaborator','trivia'],
    3: ['colleague','coworker','professional contact','professional',
      'architect','engineer','manager','director','works at','same company',
      'employer','employed','team','peer','mba peer','business'],
    2: ['school','from your school','met during','acquaintance',
      'classmate','alumni','met at','introduced','generic'],
    1: ['following','follow','3rd degree','2nd degree','1st degree',
      'connection','follower','linkedin']
  };
  var order = [5, 4, 3, 2, 1];
  for (var t = 0; t < order.length; t++) {
    var tid = order[t];
    var kws = tiers[tid];
    for (var k = 0; k < kws.length; k++) {
      var kw = kws[k];
      if (kw.indexOf(' ') !== -1) {
        if (combined.indexOf(kw) !== -1) return tid;
      } else {
        var re = new RegExp('\\\\b' + kw + '\\\\b');
        if (re.test(combined)) return tid;
      }
    }
  }
  return 2;
}

function computeConnectionIntel(rels) {
  var result = { duplicates: [], phantoms: [], followsCount: 0 };
  if (!rels || rels.length === 0) return result;
  var phantomNames = ['blossom','buttercup','claudine','gemma ai','chatgpt','claude ai'];
  var phantomTypes = ['ai assistant','ai collaborator','ai assistant/collaborator'];
  var phantomContext = ['ai assistant','ai collaborator','ai agent','language model'];
  // Duplicates: group by normalized name
  var nameGroups = {};
  for (var i = 0; i < rels.length; i++) {
    var rn = (rels[i].name || '').toLowerCase().replace(/[^a-z\\s]/g, '').replace(/\\s+/g, ' ').trim();
    if (!rn) continue;
    if (!nameGroups[rn]) nameGroups[rn] = [];
    nameGroups[rn].push(rels[i]);
  }
  for (var n in nameGroups) {
    if (nameGroups[n].length >= 2) {
      result.duplicates.push({ name: nameGroups[n][0].name, count: nameGroups[n].length });
    }
  }
  // Phantoms
  for (var i = 0; i < rels.length; i++) {
    var rname = (rels[i].name || '').toLowerCase();
    var rtype = (rels[i].relationship_type || '').toLowerCase();
    var rctx = (rels[i].context || '').toLowerCase();
    var isPhantom = false;
    for (var p = 0; p < phantomNames.length; p++) { if (rname.indexOf(phantomNames[p]) !== -1) { isPhantom = true; break; } }
    if (!isPhantom) { for (var p = 0; p < phantomTypes.length; p++) { if (rtype.indexOf(phantomTypes[p]) !== -1) { isPhantom = true; break; } } }
    if (!isPhantom) { for (var p = 0; p < phantomContext.length; p++) { if (rctx.indexOf(phantomContext[p]) !== -1) { isPhantom = true; break; } } }
    if (isPhantom) result.phantoms.push(rels[i].name);
  }
  // Follows count
  for (var i = 0; i < rels.length; i++) {
    if (classifyRelTier(rels[i]) === 1) result.followsCount++;
  }
  return result;
}

function getEntityDensity(data) {
  // Count filled attributes
  var attrCount = 0;
  var attrs = data.attributes || [];
  attrCount += attrs.length;
  // Count career_lite fields as attributes
  var cl = data.career_lite || {};
  if (cl.headline) attrCount++;
  if (cl.location) attrCount++;
  if (cl.current_title || cl.current_role) attrCount++;
  if (cl.current_company) attrCount++;
  if (cl.linkedin_url) attrCount++;
  if (cl.email) attrCount++;
  if (cl.phone) attrCount++;
  if (cl.summary) attrCount++;
  if (cl.work_history && cl.work_history.length > 0) attrCount += Math.min(cl.work_history.length, 3);
  if (cl.education && cl.education.length > 0) attrCount += Math.min(cl.education.length, 2);
  if (cl.skills && cl.skills.length > 0) attrCount++;
  // Count entity-level fields
  var e = data.entity || {};
  if (e.summary && e.summary.value) attrCount++;
  // Count relationships as partial attributes
  var rels = data.relationships || [];
  if (rels.length > 0) attrCount += Math.min(rels.length, 3);

  // Count distinct sources
  var sourceSet = {};
  var obs = data.observations || [];
  for (var i = 0; i < obs.length; i++) {
    var src = obs[i].source || '';
    if (src) sourceSet[src] = true;
  }
  var prov = data.provenance_chain || {};
  var docs = prov.source_documents || [];
  for (var i = 0; i < docs.length; i++) {
    var src = (docs[i].source || '').split(':')[0];
    if (src) sourceSet[src] = true;
  }
  var sourceCount = Object.keys(sourceSet).length;

  // Calculate average confidence
  var totalConf = 0;
  var confCount = 0;
  for (var i = 0; i < attrs.length; i++) {
    if (attrs[i].confidence) { totalConf += attrs[i].confidence; confCount++; }
  }
  for (var i = 0; i < obs.length; i++) {
    if (obs[i].confidence) { totalConf += obs[i].confidence; confCount++; }
  }
  var avgConf = confCount > 0 ? totalConf / confCount : 0;

  // Apply MECE-007 thresholds
  if (attrCount >= 12 && sourceCount >= 3 && avgConf > 0.7) {
    return { level: 'comprehensive', label: 'Comprehensive', attrCount: attrCount, sourceCount: sourceCount, avgConf: avgConf };
  }
  if (attrCount >= 8 && sourceCount >= 2) {
    return { level: 'rich', label: 'Rich', attrCount: attrCount, sourceCount: sourceCount, avgConf: avgConf };
  }
  if (attrCount >= 3) {
    return { level: 'partial', label: 'Partial', attrCount: attrCount, sourceCount: sourceCount, avgConf: avgConf };
  }
  return { level: 'skeleton', label: 'Skeleton', attrCount: attrCount, sourceCount: sourceCount, avgConf: avgConf };
}

function renderDensityBadge(data) {
  var d = getEntityDensity(data);
  return '<span class="density-badge density-' + d.level + '"><span class="density-dot"></span>' + d.label + '</span>';
}

function getAvailableLenses(data) {
  var lenses = [];
  var e = data.entity || {};
  var type = e.entity_type || '';
  var cl = data.career_lite || {};
  var obs = data.observations || [];
  var rels = data.relationships || [];
  var attrs = data.attributes || [];
  var connected = data.connected_objects || [];

  // Overview — always available
  lenses.push({ id: 'overview', icon: '\\uD83D\\uDCCB', label: 'Overview' });

  // Career — person with work_history 1+ entry
  if (type === 'person') {
    var hasWork = (cl.work_history && cl.work_history.length > 0) ||
                  (cl.experience && cl.experience.length > 0);
    if (hasWork) {
      lenses.push({ id: 'career', icon: '\\uD83D\\uDCBC', label: 'Career' });
    }
  }

  // Network Map — 3+ connections (rels + connected objects)
  var connCount = rels.length + connected.length;
  if (connCount >= 3) {
    lenses.push({ id: 'network-map', icon: '\\uD83D\\uDD78\\uFE0F', label: 'Network Map' });
  }

  // Intelligence Brief — person with 5+ observations from 2+ sources
  if (type === 'person' && obs.length >= 5) {
    var obsSources = {};
    for (var i = 0; i < obs.length; i++) {
      var src = obs[i].source || '';
      if (src) obsSources[src] = true;
    }
    if (Object.keys(obsSources).length >= 2) {
      lenses.push({ id: 'intelligence-brief', icon: '\\uD83D\\uDCC4', label: 'Intelligence Brief' });
    }
  }

  // Org Brief — organization with 3+ attributes and connected people
  if (['organization', 'business', 'institution'].indexOf(type) !== -1) {
    var hasPeople = false;
    for (var i = 0; i < rels.length; i++) {
      if (rels[i].relationship_type === 'employed' || rels[i].relationship_type === 'member') { hasPeople = true; break; }
    }
    if (!hasPeople) {
      for (var i = 0; i < connected.length; i++) {
        if (connected[i].entity_type === 'person') { hasPeople = true; break; }
      }
    }
    if (attrs.length >= 3 && hasPeople) {
      lenses.push({ id: 'org-brief', icon: '\\uD83C\\uDFE2', label: 'Org Brief' });
    }
  }

  // Source Provenance — always available
  lenses.push({ id: 'source-provenance', icon: '\\uD83D\\uDD0D', label: 'Source Provenance' });

  return lenses;
}

function renderEnrichPrompt(icon, text, actionLabel, actionOnclick) {
  var h = '<div class="enrich-prompt">';
  h += '<span class="enrich-prompt-icon">' + icon + '</span>';
  h += '<span class="enrich-prompt-text">' + text + '</span>';
  if (actionLabel && actionOnclick) {
    h += '<button class="enrich-prompt-action" onclick="' + actionOnclick + '">' + actionLabel + '</button>';
  }
  h += '</div>';
  return h;
}

function getSourceIcon(sourceType) {
  if (!sourceType) return '';
  var s = sourceType.toLowerCase();
  if (s.indexOf('linkedin') !== -1) return '<svg viewBox="0 0 24 24" fill="#0A66C2"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg>';
  if (s.indexOf('file') !== -1) return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6"/></svg>';
  if (s.indexOf('web') !== -1 || s.indexOf('url') !== -1) return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/></svg>';
  if (s.indexOf('chatgpt') !== -1) return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/></svg>';
  return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>';
}

function getSourceLabel(sourceType) {
  if (!sourceType) return 'Unknown';
  var s = sourceType.toLowerCase();
  if (s.indexOf('linkedin_api') !== -1) return 'LinkedIn API';
  if (s.indexOf('linkedin_pdf') !== -1) return 'LinkedIn PDF';
  if (s.indexOf('linkedin') !== -1) return 'LinkedIn';
  if (s.indexOf('file_import') !== -1 || s.indexOf('file_upload') !== -1) return 'File Import';
  if (s.indexOf('chatgpt') !== -1) return 'ChatGPT Import';
  if (s.indexOf('drive') !== -1) return 'Google Drive';
  if (s.indexOf('web') !== -1 || s.indexOf('url') !== -1) return 'Web';
  return sourceType;
}

function renderSourceFooter(data) {
  var sources = {};
  var pc = data.provenance_chain;
  if (pc && pc.source_documents) {
    for (var i = 0; i < pc.source_documents.length; i++) {
      var src = pc.source_documents[i].source || '';
      var type = src.split(':')[0] || src;
      sources[type] = true;
    }
  }
  // Also check observations for source types
  var obs = data.observations || [];
  for (var i = 0; i < obs.length; i++) {
    if (obs[i].source) {
      var type = obs[i].source.split(':')[0] || obs[i].source;
      sources[type] = true;
    }
  }
  var keys = Object.keys(sources);
  if (keys.length === 0) return '';
  var h = '<div class="source-footer">';
  h += '<span class="source-footer-label">Sources</span>';
  for (var i = 0; i < keys.length; i++) {
    h += '<span class="source-tag">' + getSourceIcon(keys[i]) + ' ' + esc(getSourceLabel(keys[i])) + '</span>';
  }
  h += '</div>';
  return h;
}

function calcDecay(observedAt) {
  if (!observedAt) return 1;
  var days = Math.max(0, (Date.now() - new Date(observedAt).getTime()) / 86400000);
  return Math.exp(-0.03 * days);
}

/* --- Entity Pipeline Panel (Collect / Review / Confirm) --- */
var ppCollapsed = {};

function toggleRightPanel() {
  var rp = document.getElementById('rightPanel');
  if (rp.classList.contains('force-show')) {
    rp.classList.remove('force-show');
  } else {
    rp.classList.add('force-show');
  }
}

function toggleCollapseRightPanel() {
  var rp = document.getElementById('rightPanel');
  rp.classList.toggle('collapsed');
}

function togglePpSection(secId) {
  ppCollapsed[secId] = !ppCollapsed[secId];
  var body = document.getElementById('pp-body-' + secId);
  var chev = document.getElementById('pp-chev-' + secId);
  if (body) body.classList.toggle('collapsed', !!ppCollapsed[secId]);
  if (chev) chev.classList.toggle('collapsed', !!ppCollapsed[secId]);
}

/* --- Context-Sensitive Right Panel (Build 8) --- */
var _rpContext = 'pipeline'; // 'pipeline' | 'review_queue' | 'field_detail' | 'document_detail'
var _rpSelectedField = null; // {ri, ei, fi, field, value, status, provenance, entity_id, entity_name}

function updateContextRightPanel(context, detail) {
  _rpContext = context;
  var rp = document.getElementById('rightPanelContent');
  if (!rp) return;

  if (context === 'review_queue') {
    renderReviewQueuePanel(rp);
  } else if (context === 'field_detail' && detail) {
    _rpSelectedField = detail;
    renderFieldDetailPanel(rp, detail);
  } else if (context === 'document_detail' && detail) {
    renderDocumentDetailPanel(rp, detail);
  } else {
    // Fall back to pipeline
    renderRightPanel(null);
  }
}

// renderSpokeReviewProgress — spoke header progress bar (Build 9)
function renderSpokeReviewProgress() {
  var el = document.getElementById('spokeReviewProgress');
  if (!el || !_exportData) return;
  var rs = _exportData.review_summary;
  if (!rs || !rs.total) { el.innerHTML = ''; return; }
  var reviewed = rs.approved + rs.rejected + rs.corrected;
  var pct = Math.round((reviewed / rs.total) * 100);
  var h = '<div class="rp-spoke-progress">';
  h += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">';
  h += '<span style="font-size:12px;font-weight:600;color:var(--text-primary);">Review Progress</span>';
  h += '<span style="font-size:12px;color:var(--text-muted);">' + pct + '%</span>';
  h += '</div>';
  h += '<div class="rp-progress-bar"><div class="rp-progress-fill" style="width:' + pct + '%"></div></div>';
  h += '<div style="font-size:11px;color:var(--text-muted);margin-top:4px;">';
  h += reviewed + ' of ' + rs.total + ' fields reviewed';
  if (reviewed === rs.total) h += ' &mdash; <strong style="color:#059669;">Complete</strong>';
  h += '</div></div>';
  el.innerHTML = h;
}

function renderReviewQueuePanel(rp) {
  if (!_selectedSpoke || !_exportData) {
    rp.innerHTML = '<div style="padding:24px;color:var(--text-muted);font-size:13px;">Select a client to view review queue.</div>';
    return;
  }

  var roles = _exportData.roles || [];
  var pending = [], verified = [], flagged = [], corrected = [];
  var criticalKeys = ['ssn', 'ein', 'tax_id', 'account_number', 'bank', 'social_security', 'routing_number'];
  var totalReviewable = 0;
  var bulkEligible = 0;
  var criticalPending = 0;

  // Scan all fields into 4 buckets
  for (var ri = 0; ri < roles.length; ri++) {
    var role = roles[ri];
    for (var ei = 0; ei < (role.entities || []).length; ei++) {
      var ent = role.entities[ei];
      for (var fi = 0; fi < (ent.fields || []).length; fi++) {
        var f = ent.fields[fi];
        if (f.status === 'missing') continue;
        totalReviewable++;
        var fieldLower = (f.field || '').toLowerCase();
        var isCritical = criticalKeys.some(function(k) { return fieldLower.indexOf(k) >= 0; });
        var item = {
          ri: ri, ei: ei, fi: fi,
          field: f.field, value: f.value, status: f.status,
          confidence: f.confidence,
          provenance: f.provenance || {},
          entity_id: ent.entity_id, entity_name: ent.entity_name,
          review: f.review || null,
          isCritical: isCritical
        };
        if (f.review && f.review.status === 'approved') {
          verified.push(item);
        } else if (f.review && f.review.status === 'rejected') {
          flagged.push(item);
        } else if (f.review && f.review.status === 'corrected') {
          corrected.push(item);
        } else {
          pending.push(item);
          if (isCritical) criticalPending++;
          else if (f.confidence != null && f.confidence >= 0.85 && f.value) bulkEligible++;
        }
      }
    }
  }

  // Sort pending: critical fields first
  pending.sort(function(a, b) {
    if (a.isCritical && !b.isCritical) return -1;
    if (!a.isCritical && b.isCritical) return 1;
    return 0;
  });

  var reviewed = verified.length + flagged.length + corrected.length;
  var h = '<div style="padding:4px 0;">';

  // Header
  h += '<div class="rp-section-title">';
  h += '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#d97706" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>';
  h += 'REVIEW QUEUE</div>';

  // Progress bar
  var pct = totalReviewable > 0 ? Math.round((reviewed / totalReviewable) * 100) : 0;
  h += '<div class="rp-progress-bar"><div class="rp-progress-fill" style="width:' + pct + '%"></div></div>';
  h += '<div class="rp-progress-summary">';
  h += reviewed + ' of ' + totalReviewable + ' reviewed.';
  if (verified.length > 0) h += ' ' + verified.length + ' approved.';
  if (corrected.length > 0) h += ' ' + corrected.length + ' corrected.';
  if (flagged.length > 0) h += ' ' + flagged.length + ' rejected.';
  h += '</div>';

  // Bulk Approve button
  if (bulkEligible > 0) {
    h += '<button class="rp-bulk-approve" onclick="showBulkApproveModal(' + bulkEligible + ',' + criticalPending + ',' + totalReviewable + ')">';
    h += '&#9889; Bulk Approve ' + bulkEligible + ' High-Confidence Field' + (bulkEligible !== 1 ? 's' : '') + '</button>';
  }

  // PENDING section
  if (pending.length > 0) {
    h += '<div class="rp-section-title" style="margin-top:8px;">';
    h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#d97706" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>';
    h += 'PENDING (' + pending.length + ')</div>';

    for (var i = 0; i < Math.min(pending.length, 15); i++) {
      var p = pending[i];
      h += '<div class="rp-review-item" onclick="showFieldInRightPanel(' + p.ri + ',' + p.ei + ',' + p.fi + ')">';
      h += '<div class="rp-review-field">' + esc(_exportFormatLabel(p.field));
      if (p.isCritical) h += '<span class="rp-critical-badge">CRITICAL</span>';
      h += '</div>';
      if (p.value) h += '<div class="rp-review-value">' + esc(String(p.value)) + '</div>';
      if (p.provenance && p.provenance.filename) {
        h += '<div class="rp-review-source">';
        h += '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
        h += esc(p.provenance.filename);
        h += '</div>';
      }
      h += '<div class="rp-actions">';
      h += '<button class="rp-btn approve" title="Approve" onclick="event.stopPropagation();reviewField(' + p.ri + ',' + p.ei + ',' + p.fi + ',\\'approved\\')"><span class="rp-btn-icon">&#10003;</span></button>';
      h += '<button class="rp-btn reject" title="Reject" onclick="event.stopPropagation();promptRejectField(' + p.ri + ',' + p.ei + ',' + p.fi + ')"><span class="rp-btn-icon">&#10007;</span></button>';
      h += '<button class="rp-btn edit" title="Edit" onclick="event.stopPropagation();showFieldInRightPanel(' + p.ri + ',' + p.ei + ',' + p.fi + ')"><span class="rp-btn-icon">&#9998;</span></button>';
      h += '</div></div>';
    }
    if (pending.length > 15) {
      h += '<div style="text-align:center;padding:8px;font-size:12px;color:var(--text-muted);">+ ' + (pending.length - 15) + ' more items</div>';
    }
  } else if (reviewed === totalReviewable && totalReviewable > 0) {
    h += '<div style="text-align:center;padding:20px;color:#059669;font-size:13px;font-weight:600;">All fields reviewed!</div>';
  }

  // VERIFIED section
  if (verified.length > 0) {
    h += '<div class="rp-section-title" style="margin-top:24px;">';
    h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#059669" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
    h += 'VERIFIED (' + verified.length + ')</div>';
    h += '<div style="max-height:200px;overflow-y:auto;">';
    for (var v = 0; v < verified.length; v++) {
      var vi = verified[v];
      h += '<div class="rp-verified-item">';
      h += '<span class="rp-verified-check">&#10003;</span>';
      h += '<span>' + esc(_exportFormatLabel(vi.field)) + '</span>';
      if (vi.review && vi.review.reviewed_at) {
        h += '<span style="margin-left:auto;font-size:10px;">' + new Date(vi.review.reviewed_at).toLocaleDateString() + '</span>';
      }
      h += '</div>';
    }
    h += '</div>';
  }

  // FLAGGED (rejected) section
  if (flagged.length > 0) {
    h += '<div class="rp-section-title" style="margin-top:24px;">';
    h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#dc2626" stroke-width="2"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" y1="22" x2="4" y2="15"/></svg>';
    h += 'FLAGGED (' + flagged.length + ')</div>';
    for (var fg = 0; fg < flagged.length; fg++) {
      var fi2 = flagged[fg];
      h += '<div class="rp-flagged-item" onclick="showFieldInRightPanel(' + fi2.ri + ',' + fi2.ei + ',' + fi2.fi + ')">';
      h += '<div class="rp-review-field">' + esc(_exportFormatLabel(fi2.field)) + '</div>';
      if (fi2.value) h += '<div style="font-size:13px;color:#991b1b;margin-bottom:4px;">' + esc(String(fi2.value)) + '</div>';
      if (fi2.review && fi2.review.notes) {
        h += '<div style="font-size:11px;color:#b91c1c;font-style:italic;">Note: ' + esc(fi2.review.notes) + '</div>';
      }
      h += '</div>';
    }
  }

  // CORRECTED section
  if (corrected.length > 0) {
    h += '<div class="rp-section-title" style="margin-top:24px;">';
    h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#1d4ed8" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>';
    h += 'CORRECTED (' + corrected.length + ')</div>';
    for (var ci = 0; ci < corrected.length; ci++) {
      var cr = corrected[ci];
      h += '<div class="rp-corrected-item" onclick="showFieldInRightPanel(' + cr.ri + ',' + cr.ei + ',' + cr.fi + ')">';
      h += '<div class="rp-review-field">' + esc(_exportFormatLabel(cr.field)) + '</div>';
      if (cr.review && cr.review.correction) {
        h += '<div style="font-size:12px;color:var(--text-muted);text-decoration:line-through;">' + esc(String(cr.review.correction.original_value || '')) + '</div>';
        h += '<div style="font-size:14px;color:#1d4ed8;font-weight:600;">' + esc(String(cr.review.correction.corrected_value || cr.value || '')) + '</div>';
      } else if (cr.value) {
        h += '<div style="font-size:14px;color:#1d4ed8;font-weight:600;">' + esc(String(cr.value)) + '</div>';
      }
      h += '</div>';
    }
  }

  h += '</div>';
  rp.innerHTML = h;
}

function renderFieldDetailPanel(rp, detail) {
  var h = '<div class="rp-field-detail" style="padding:4px 0;">';

  h += '<div class="rp-section-title">';
  h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#0a66c2" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
  h += 'FIELD DETAIL</div>';

  h += '<div class="rp-field-header">' + esc(_exportFormatLabel(detail.field)) + '</div>';

  // Value
  if (detail.value) {
    h += '<div class="rp-field-value" id="rpFieldValue">' + esc(String(detail.value)) + '</div>';
  } else {
    h += '<div class="rp-field-value" style="color:var(--text-muted);font-style:italic;">No value</div>';
  }

  // Status badge (Build 9: added corrected/rejected)
  var statusLabel = { verified: 'Verified', low_confidence: 'Low Confidence', conflict: 'Conflict', missing: 'Missing', corrected: 'Corrected', rejected: 'Rejected' };
  var displayStatus = detail.status;
  if (detail.review && detail.review.status === 'corrected') displayStatus = 'corrected';
  if (detail.review && detail.review.status === 'rejected') displayStatus = 'rejected';
  if (detail.review && detail.review.status === 'approved') displayStatus = 'verified';
  h += '<div class="rp-field-status ' + esc(displayStatus || '') + '">' + (statusLabel[displayStatus] || displayStatus || 'Unknown') + '</div>';

  // Confidence (Build 9: use detail.confidence directly)
  var conf = detail.confidence || (detail.provenance && detail.provenance.confidence);
  if (conf) {
    h += '<div style="font-size:12px;color:var(--text-muted);margin-bottom:16px;">Confidence: <strong>' + (conf * 100).toFixed(0) + '%</strong></div>';
  }

  // Review state info (Build 9)
  if (detail.review) {
    h += '<div style="font-size:11px;color:var(--text-muted);margin-bottom:12px;padding:8px;background:#f9fafb;border-radius:6px;">';
    h += 'Reviewed by <strong>' + esc(detail.review.reviewed_by || 'user') + '</strong>';
    if (detail.review.reviewed_at) h += ' on ' + new Date(detail.review.reviewed_at).toLocaleDateString();
    if (detail.review.notes) h += '<br/>Note: <em>' + esc(detail.review.notes) + '</em>';
    if (detail.review.correction && detail.review.correction.original_value) {
      h += '<br/>Original: <span style="text-decoration:line-through;">' + esc(String(detail.review.correction.original_value)) + '</span>';
    }
    h += '</div>';
  }

  // Evidence
  if (detail.provenance && (detail.provenance.snippet || detail.provenance.filename)) {
    h += '<div class="rp-evidence-label">SOURCE EVIDENCE</div>';
    h += '<div class="rp-evidence">';
    if (detail.provenance.snippet) {
      h += '<div class="rp-evidence-snippet">&ldquo;' + esc(detail.provenance.snippet) + '&rdquo;</div>';
    }
    h += '<div class="rp-evidence-file">';
    h += '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
    h += esc(detail.provenance.filename || '');
    if (detail.provenance.location) h += ' &middot; ' + esc(detail.provenance.location);
    h += '</div>';
    if (detail.provenance.file_id && _selectedSpoke) {
      h += '<a href="/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/file/' + encodeURIComponent(detail.provenance.file_id) + '" target="_blank" style="display:inline-flex;align-items:center;gap:4px;font-size:12px;color:#0a66c2;margin-top:8px;text-decoration:none;">';
      h += '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>';
      h += 'View Original</a>';
    }
    h += '</div>';
  }

  // Action buttons
  h += '<div style="margin-top:20px;">';
  h += '<div class="rp-actions" style="margin-bottom:12px;">';
  h += '<button class="rp-btn approve" onclick="reviewField(' + detail.ri + ',' + detail.ei + ',' + detail.fi + ',\\'approved\\')">&#10003; Approve</button>';
  h += '<button class="rp-btn reject" onclick="promptRejectField(' + detail.ri + ',' + detail.ei + ',' + detail.fi + ')">&#10007; Reject</button>';
  h += '</div>';

  // Edit inline
  h += '<div id="rpEditSection">';
  h += '<button class="rp-btn edit" onclick="showFieldEditInline()" style="width:100%;">&#9998; Edit Value</button>';
  h += '</div>';
  h += '</div>';

  // Back to review queue
  h += '<div style="margin-top:24px;padding-top:16px;border-top:1px solid #e8e8e8;">';
  h += '<span style="font-size:12px;color:#0a66c2;cursor:pointer;" onclick="updateContextRightPanel(\\'review_queue\\')">&larr; Back to Review Queue</span>';
  h += '</div>';

  h += '</div>';
  rp.innerHTML = h;
}

function renderDocumentDetailPanel(rp, detail) {
  var h = '<div style="padding:4px 0;">';

  h += '<div class="rp-section-title">';
  h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
  h += 'DOCUMENT DETAIL</div>';

  var fName = detail.original_name || detail.filename || detail.id || '';
  h += '<div style="font-size:16px;font-weight:600;margin-bottom:12px;">' + esc(fName) + '</div>';

  // Meta
  h += '<div style="font-size:12px;color:var(--text-muted);margin-bottom:16px;">';
  if (detail.uploaded_at) h += 'Uploaded: ' + new Date(detail.uploaded_at).toLocaleDateString() + '<br/>';
  if (detail.size) {
    var sz = detail.size > 1024*1024 ? (detail.size/(1024*1024)).toFixed(1) + ' MB' : (detail.size/1024).toFixed(1) + ' KB';
    h += 'Size: ' + sz + '<br/>';
  }
  if (detail.content_type) h += 'Type: ' + esc(detail.content_type);
  h += '</div>';

  // Extracted fields from this file (scan export data)
  if (_exportData) {
    var extractedFromFile = [];
    var roles = _exportData.roles || [];
    for (var ri = 0; ri < roles.length; ri++) {
      for (var ei = 0; ei < (roles[ri].entities || []).length; ei++) {
        for (var fi = 0; fi < (roles[ri].entities[ei].fields || []).length; fi++) {
          var f = roles[ri].entities[ei].fields[fi];
          if (f.provenance && (f.provenance.file_id === detail.id || f.provenance.filename === fName)) {
            extractedFromFile.push({
              field: f.field, value: f.value, status: f.status,
              ri: ri, ei: ei, fi: fi
            });
          }
        }
      }
    }

    if (extractedFromFile.length > 0) {
      h += '<div class="rp-section-title" style="margin-top:8px;">EXTRACTED FROM THIS FILE</div>';
      for (var i = 0; i < extractedFromFile.length; i++) {
        var ef = extractedFromFile[i];
        var statusIcon = ef.status === 'verified' ? '&#10003;' : (ef.status === 'conflict' ? '&#9888;' : '&#9679;');
        var statusColor = ef.status === 'verified' ? '#059669' : (ef.status === 'conflict' ? '#dc2626' : '#6b7280');
        h += '<div style="display:flex;align-items:center;gap:8px;padding:6px 0;font-size:13px;border-bottom:1px solid #f0f0f0;cursor:pointer;" onclick="showFieldInRightPanel(' + ef.ri + ',' + ef.ei + ',' + ef.fi + ')">';
        h += '<span style="color:' + statusColor + ';">' + statusIcon + '</span>';
        h += '<span style="font-weight:500;">' + esc(_exportFormatLabel(ef.field)) + ':</span> ';
        h += '<span style="color:var(--text-secondary);">' + esc(String(ef.value || '—')) + '</span>';
        h += '</div>';
      }
    } else {
      h += '<div style="font-size:12px;color:var(--text-muted);margin-top:16px;">No fields extracted from this file yet.</div>';
    }
  }

  // Action buttons
  h += '<div style="margin-top:20px;display:flex;flex-direction:column;gap:8px;">';
  if (detail.id && _selectedSpoke) {
    h += '<a href="/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/file/' + encodeURIComponent(detail.id) + '" target="_blank" class="rp-btn" style="text-align:center;text-decoration:none;display:block;">View Full Document</a>';
  }
  h += '</div>';

  h += '</div>';
  rp.innerHTML = h;
}

function showFieldInRightPanel(ri, ei, fi) {
  if (!_exportData) return;
  var f = _exportData.roles[ri].entities[ei].fields[fi];
  if (!f) return;
  updateContextRightPanel('field_detail', {
    ri: ri, ei: ei, fi: fi,
    field: f.field, value: f.value, status: f.status,
    confidence: f.confidence,
    provenance: f.provenance || {},
    entity_id: _exportData.roles[ri].entities[ei].entity_id,
    entity_name: _exportData.roles[ri].entities[ei].entity_name,
    review: f.review || null
  });
}

function showFieldEditInline() {
  var section = document.getElementById('rpEditSection');
  if (!section || !_rpSelectedField) return;
  var h = '<input class="rp-edit-input" id="rpEditInput" value="' + esc(String(_rpSelectedField.value || '')) + '" />';
  h += '<div class="rp-actions">';
  h += '<button class="rp-btn approve" onclick="saveFieldEdit()">Save</button>';
  h += '<button class="rp-btn" onclick="showFieldInRightPanel(' + _rpSelectedField.ri + ',' + _rpSelectedField.ei + ',' + _rpSelectedField.fi + ')">Cancel</button>';
  h += '</div>';
  section.innerHTML = h;
  var inp = document.getElementById('rpEditInput');
  if (inp) { inp.focus(); inp.select(); }
}

function saveFieldEdit() {
  if (!_rpSelectedField || !_selectedSpoke) return;
  var inp = document.getElementById('rpEditInput');
  if (!inp) return;
  var newValue = inp.value.trim();
  if (!newValue) { toast('Value cannot be empty'); return; }
  if (!_rpSelectedField.entity_id) { toast('No entity ID for this field'); return; }

  // Build 9: Use correct action instead of posting a new observation
  reviewFieldWithAction(_rpSelectedField.ri, _rpSelectedField.ei, _rpSelectedField.fi, 'correct', newValue, null);
}

// reviewField — backward-compat wrapper (Build 9)
function reviewField(ri, ei, fi, status) {
  var action = status === 'approved' ? 'approve' : status === 'rejected' ? 'reject' : 'approve';
  reviewFieldWithAction(ri, ei, fi, action, null, null);
}

// reviewFieldWithAction — action-based review (Build 9)
function reviewFieldWithAction(ri, ei, fi, action, correctedValue, reason) {
  if (!_exportData || !_selectedSpoke) return;
  var f = _exportData.roles[ri].entities[ei].fields[fi];
  if (!f) return;
  var entityId = _exportData.roles[ri].entities[ei].entity_id;
  if (!entityId) { toast('No entity ID for this field'); return; }

  // Find the observation index for this field
  api('GET', '/api/entity/' + encodeURIComponent(entityId)).then(function(entityData) {
    var obs = entityData.observations || [];
    var attrs = entityData.attributes || [];
    var fieldKey = (f.field || '').toLowerCase().replace(/\s+/g, '_');

    var obsIndex = -1;
    for (var i = 0; i < obs.length; i++) {
      var obsText = (obs[i].content || obs[i].text || '').toLowerCase();
      if (obsText.indexOf(fieldKey) >= 0 || obsText.indexOf(String(f.value || '').toLowerCase()) >= 0) {
        obsIndex = i;
        break;
      }
    }
    if (obsIndex === -1) {
      for (var i = 0; i < attrs.length; i++) {
        if ((attrs[i].key || '').toLowerCase() === fieldKey) {
          obsIndex = i;
          break;
        }
      }
    }

    var payload = {
      action: action,
      reviewed_by: (sessionUser && sessionUser.name) || 'user',
      field_key: f.field
    };
    if (correctedValue !== null && correctedValue !== undefined) payload.corrected_value = correctedValue;
    if (reason) payload.reason = reason;

    api('PATCH', '/api/entity/' + encodeURIComponent(entityId) + '/observation/' + (obsIndex >= 0 ? obsIndex : 0) + '/review', payload).then(function(resp) {
      var reviewStatus = action === 'approve' ? 'approved' : action === 'reject' ? 'rejected' : 'corrected';
      var toastMsg = action === 'approve' ? 'Field approved!' : action === 'reject' ? 'Field rejected' : 'Field corrected';
      toast(toastMsg);
      // Update local export data
      f.review = resp.review || { status: reviewStatus, reviewed_at: new Date().toISOString(), reviewed_by: (sessionUser && sessionUser.name) || 'user' };
      if (action === 'correct' && correctedValue) {
        f.value = correctedValue;
      }
      // Refresh right panel
      if (_rpContext === 'review_queue') {
        renderReviewQueuePanel(document.getElementById('rightPanelContent'));
      } else if (_rpContext === 'field_detail') {
        showFieldInRightPanel(ri, ei, fi);
      }
      // Also update spoke header progress if visible
      if (typeof renderSpokeReviewProgress === 'function') renderSpokeReviewProgress();
    }).catch(function(err) {
      toast('Review failed: ' + (err.message || err));
    });
  });
}

// promptRejectField — prompt for optional rejection reason (Build 9)
function promptRejectField(ri, ei, fi) {
  var reason = window.prompt('Rejection reason (optional):');
  if (reason === null) return; // user cancelled
  reviewFieldWithAction(ri, ei, fi, 'reject', null, reason || '');
}

// showBulkApproveModal — confirmation modal before bulk approve (Build 9)
function showBulkApproveModal(eligibleCount, criticalCount, totalCount) {
  var overlay = document.createElement('div');
  overlay.className = 'rp-modal-overlay';
  overlay.id = 'bulkApproveModal';
  overlay.onclick = function(e) { if (e.target === overlay) closeBulkApproveModal(); };
  var h = '<div class="rp-modal">';
  h += '<h3>Bulk Approve Fields</h3>';
  h += '<p>Approve <strong>' + eligibleCount + '</strong> of <strong>' + totalCount + '</strong> fields with high confidence (&ge;85%)?</p>';
  if (criticalCount > 0) {
    h += '<p style="color:#dc2626;font-size:13px;"><strong>' + criticalCount + '</strong> critical field' + (criticalCount !== 1 ? 's' : '') + ' require individual review and will be skipped.</p>';
  }
  h += '<div class="rp-modal-actions">';
  h += '<button class="cancel" onclick="closeBulkApproveModal()">Cancel</button>';
  h += '<button class="confirm" onclick="executeBulkApprove()">Approve ' + eligibleCount + ' Fields</button>';
  h += '</div></div>';
  overlay.innerHTML = h;
  document.body.appendChild(overlay);
}

function closeBulkApproveModal() {
  var modal = document.getElementById('bulkApproveModal');
  if (modal) modal.remove();
}

function executeBulkApprove() {
  closeBulkApproveModal();
  if (!_selectedSpoke) return;
  toast('Bulk approving...');
  api('POST', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/bulk-review', {
    reviewed_by: (sessionUser && sessionUser.name) || 'user'
  }).then(function(resp) {
    toast(resp.approved + ' field' + (resp.approved !== 1 ? 's' : '') + ' approved, ' + resp.skipped + ' skipped');
    // Re-fetch export data and refresh panel
    api('GET', '/api/spoke/' + encodeURIComponent(_selectedSpoke) + '/export').then(function(data) {
      _exportData = data;
      if (_rpContext === 'review_queue') {
        renderReviewQueuePanel(document.getElementById('rightPanelContent'));
      }
      if (typeof renderSpokeReviewProgress === 'function') renderSpokeReviewProgress();
    });
  }).catch(function(err) {
    toast('Bulk approve failed: ' + (err.message || err));
  });
}

// Wire right panel update on tab switch
var _origShowClientWorkspace = showClientWorkspace;

function renderRightPanel(data) {
  var rp = document.getElementById('rightPanelContent');
  if (!rp) return;
  var e = data ? (data.entity || {}) : {};
  var entityId = e.entity_id || '';
  var name = e.name ? (e.name.full || e.name.common || e.name.legal || '') : '';

  if (!entityId) {
    // Global pipeline — no specific entity
    api('GET', '/api/pipeline/global').then(function(pipeline) {
      rp.innerHTML = renderPpCollect('', '', pipeline.collect) + renderPpReview(pipeline.review, '') + renderPpConfirm(pipeline.confirm, '');
      wirePpDropzone('');
    }).catch(function() {
      rp.innerHTML = renderPpCollect('', '', { pending_count: 0 }) + renderPpReview({ clusters: [], conflict_count: 0, low_confidence_count: 0, low_confidence_attrs: [] }, '') + renderPpConfirm({ ready_clusters: [], recent_confirmations: [] }, '');
      wirePpDropzone('');
    });
    return;
  }

  // Entity-scoped pipeline
  api('GET', '/api/entity/' + entityId + '/pipeline').then(function(pipeline) {
    rp.innerHTML = renderPpCollect(entityId, name, pipeline.collect) + renderPpReview(pipeline.review, entityId) + renderPpConfirm(pipeline.confirm, entityId);
    wirePpDropzone(entityId);
  }).catch(function() {
    rp.innerHTML = renderPpCollect(entityId, name, { pending_count: 0 }) + renderPpReview({ clusters: [], conflict_count: 0, low_confidence_count: 0, low_confidence_attrs: [] }, entityId) + renderPpConfirm({ ready_clusters: [], recent_confirmations: [] }, entityId);
    wirePpDropzone(entityId);
  });
}

function wirePpDropzone(entityId) {
  var dz = document.getElementById('ppDropzone');
  if (!dz) return;
  dz.addEventListener('dragover', function(e) { e.preventDefault(); dz.classList.add('dragover'); });
  dz.addEventListener('dragleave', function() { dz.classList.remove('dragover'); });
  dz.addEventListener('drop', function(e) {
    e.preventDefault(); dz.classList.remove('dragover');
    rpHandleFiles(e.dataTransfer.files, entityId || '');
  });
}

/* --- SECTION 1: COLLECT (purple/indigo) --- */
function renderPpCollect(entityId, entityName, collectData) {
  var pending = collectData ? (collectData.pending_count || 0) : 0;
  var h = '<div class="pp-section collect">';
  h += '<div class="pp-accent collect"></div>';
  h += '<div class="pp-header" onclick="togglePpSection(' + "'" + 'collect' + "'" + ')">';
  h += '<div class="pp-header-left">';
  h += '<span class="pp-header-icon">\uD83D\uDCE5</span>';
  h += '<span class="pp-header-title">Collect</span>';
  if (pending > 0) h += '<span class="pp-badge">' + pending + '</span>';
  h += '</div>';
  h += '<span class="pp-chevron' + (ppCollapsed.collect ? ' collapsed' : '') + '" id="pp-chev-collect">&#9660;</span>';
  h += '</div>';
  h += '<div class="pp-body' + (ppCollapsed.collect ? ' collapsed' : '') + '" id="pp-body-collect">';
  if (entityName) {
    h += '<div style="font-size:14px;color:#5b21b6;margin-bottom:10px;font-weight:600;">Adding context for: ' + esc(entityName) + '</div>';
  }
  // Drop zone with large plus icon
  h += '<div class="pp-dropzone" id="ppDropzone" onclick="document.getElementById(' + "'" + 'rpFileInput' + "'" + ').click()">';
  h += '<div class="pp-drop-icon">+</div>';
  h += '<div>Drop files to add context</div>';
  if (entityName) {
    h += '<div class="pp-drop-sub">for ' + esc(entityName) + '</div>';
  }
  h += '</div>';
  h += '<input type="file" id="rpFileInput" multiple onchange="rpHandleFiles(this.files,' + "'" + esc(entityId || '') + "'" + ')" style="display:none" />';
  // Files section
  h += '<div class="pp-files-header">';
  h += '<span class="pp-files-title">Files</span>';
  h += '<button class="pp-files-add" onclick="document.getElementById(' + "'" + 'rpFileInput' + "'" + ').click()" title="Add file">+</button>';
  h += '</div>';
  h += '<div class="pp-files-empty">No files added yet</div>';
  // URL input
  h += '<div class="pp-url-row">';
  h += '<input type="text" class="pp-url-input" id="rpUrlInput" placeholder="Paste URL..." />';
  h += '<button class="pp-url-btn" onclick="rpExtractURL(' + "'" + esc(entityId || '') + "'" + ')" id="rpUrlBtn">Extract</button>';
  h += '</div>';
  // Quick actions
  if (entityId) {
    h += '<div class="pp-quick-actions">';
    h += '<button class="pp-quick-btn" onclick="ppQuickFind(' + "'" + 'linkedin' + "'" + ',' + "'" + esc(entityName || '') + "'" + ',' + "'" + esc(entityId) + "'" + ')" title="Find LinkedIn profile">';
    h += '<svg viewBox="0 0 24 24" fill="#0A66C2"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg>';
    h += ' Find LinkedIn</button>';
    h += '<button class="pp-quick-btn" onclick="ppQuickFind(' + "'" + 'x' + "'" + ',' + "'" + esc(entityName || '') + "'" + ',' + "'" + esc(entityId) + "'" + ')" title="Find X profile">';
    h += '<svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>';
    h += ' Find X</button>';
    h += '<button class="pp-quick-btn" onclick="ppQuickDiscover(' + "'" + esc(entityName || '') + "'" + ',' + "'" + esc(entityId) + "'" + ')" title="Discover connection">';
    h += '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>';
    h += ' Discover</button>';
    h += '</div>';
  }
  // Monitor toggle
  h += '<div class="pp-monitor">';
  h += '<span>Watch for updates</span>';
  h += '<div class="pp-toggle" onclick="this.classList.toggle(' + "'" + 'on' + "'" + ')" title="Automatically search for new information about this entity"></div>';
  h += '</div>';
  if (pending === 0 && !entityName) {
    h += '<div class="pp-empty">No pending extractions. Add context above.</div>';
  }
  h += '</div></div>';
  return h;
}

/* --- SECTION 2: REVIEW (amber/orange) --- */
function renderPpReview(reviewData, entityId) {
  var clusters = reviewData.clusters || [];
  var conflictCount = reviewData.conflict_count || 0;
  var lowConfCount = reviewData.low_confidence_count || 0;
  var lowConfAttrs = reviewData.low_confidence_attrs || [];
  var totalCount = clusters.length + conflictCount;

  var h = '<div class="pp-section review">';
  h += '<div class="pp-accent review"></div>';
  h += '<div class="pp-header" onclick="togglePpSection(' + "'" + 'review' + "'" + ')">';
  h += '<div class="pp-header-left">';
  h += '<span class="pp-header-icon">\u2696\uFE0F</span>';
  h += '<span class="pp-header-title">Review</span>';
  if (totalCount > 0) h += '<span class="pp-badge">' + totalCount + '</span>';
  h += '</div>';
  h += '<span class="pp-chevron' + (ppCollapsed.review ? ' collapsed' : '') + '" id="pp-chev-review">&#9660;</span>';
  h += '</div>';
  h += '<div class="pp-body' + (ppCollapsed.review ? ' collapsed' : '') + '" id="pp-body-review">';

  // Render cluster cards
  for (var i = 0; i < clusters.length; i++) {
    var c = clusters[i];
    var srcIcon = getPpSourceIcon(c.source_type || '');
    var confPct = Math.round((c.association_confidence || 0) * 100);
    var qClass = (c.quadrant || '').toLowerCase().replace('_', '');
    if (qClass === 'q1create' || qClass === 'q1_create') qClass = 'q1';
    else if (qClass === 'q2enrich' || qClass === 'q2_enrich') qClass = 'q2';
    else if (qClass === 'q3consolidate' || qClass === 'q3_consolidate') qClass = 'q3';
    else if (qClass === 'q4confirm' || qClass === 'q4_confirm') qClass = 'q4';
    var qLabel = c.quadrant_label || c.quadrant || '';

    h += '<div class="pp-cluster-card">';
    h += '<div class="pp-cluster-top">';
    h += '<span class="pp-cluster-icon">' + srcIcon + '</span>';
    h += '<span class="pp-cluster-name">' + esc(c.name || 'Unknown') + '</span>';
    h += '<span class="pp-cluster-quadrant ' + qClass + '">' + esc(qLabel) + '</span>';
    h += '</div>';
    // Confidence bar
    h += '<div class="pp-conf-bar"><div class="pp-conf-fill" style="width:' + confPct + '%;background:' + (confPct >= 60 ? '#10b981' : confPct >= 30 ? '#f59e0b' : '#ef4444') + '"></div></div>';

    // Evidence panel for ambiguous matches
    if (c.ambiguous && c.evidence && c.evidence.length > 0) {
      h += '<div class="pp-evidence">';
      for (var j = 0; j < c.evidence.length; j++) {
        var ev = c.evidence[j];
        var evClass = ev.match ? 'match' : (ev.conflict ? 'conflict' : 'partial');
        var evIcon = ev.match ? '\u2713' : (ev.conflict ? '\u2717' : '\u26A0');
        h += '<div class="pp-evidence-item ' + evClass + '">' + evIcon + ' ' + esc(ev.label || ev.field || '') + '</div>';
      }
      h += '</div>';
    }

    // Contradictions
    if (c.contradictions && c.contradictions.length > 0) {
      h += '<div class="pp-evidence">';
      for (var j = 0; j < c.contradictions.length; j++) {
        h += '<div class="pp-evidence-item conflict">\u2717 ' + esc(c.contradictions[j].field || '') + ': ' + esc(c.contradictions[j].message || '') + '</div>';
      }
      h += '</div>';
    }

    // Action buttons
    h += '<div class="pp-cluster-actions">';
    h += '<button class="pp-btn-accept" onclick="ppAcceptCluster(' + "'" + esc(c.cluster_id) + "'" + ',' + "'" + esc(entityId) + "'" + ')">Accept</button>';
    h += '<button class="pp-btn-reject" onclick="ppRejectCluster(' + "'" + esc(c.cluster_id) + "'" + ',' + "'" + esc(entityId) + "'" + ')">Reject</button>';
    h += '</div></div>';
  }

  // Low confidence attributes
  if (lowConfAttrs.length > 0) {
    h += '<div class="pp-low-conf">';
    h += '<div style="font-size:10px;color:#d97706;font-weight:600;margin-bottom:4px;">Low Confidence Attributes</div>';
    for (var i = 0; i < lowConfAttrs.length; i++) {
      var attr = lowConfAttrs[i];
      h += '<div class="pp-low-conf-item">';
      h += '<span>' + esc((attr.key || '').replace(/_/g, ' ')) + ': ' + esc(String(attr.value || '').slice(0, 20)) + ' (' + Math.round((attr.confidence || 0) * 100) + '%)</span>';
      h += '<button class="pp-btn-enrich" onclick="ppEnrich(' + "'" + esc(attr.key || '') + "'" + ')">Enrich</button>';
      h += '</div>';
    }
    h += '</div>';
  }

  if (totalCount === 0) {
    h += '<div class="pp-empty"><span class="pp-empty-check">\u2713</span>No items need review</div>';
  }
  h += '</div></div>';
  return h;
}

/* --- SECTION 3: CONFIRM (green) --- */
function renderPpConfirm(confirmData, entityId) {
  var readyClusters = confirmData.ready_clusters || [];
  var recent = confirmData.recent_confirmations || [];
  var count = readyClusters.length;

  var h = '<div class="pp-section confirm">';
  h += '<div class="pp-accent confirm"></div>';
  h += '<div class="pp-header" onclick="togglePpSection(' + "'" + 'confirm' + "'" + ')">';
  h += '<div class="pp-header-left">';
  h += '<span class="pp-header-icon">\u2713</span>';
  h += '<span class="pp-header-title">Confirm</span>';
  if (count > 0) h += '<span class="pp-badge">' + count + '</span>';
  h += '</div>';
  h += '<span class="pp-chevron' + (ppCollapsed.confirm ? ' collapsed' : '') + '" id="pp-chev-confirm">&#9660;</span>';
  h += '</div>';
  h += '<div class="pp-body' + (ppCollapsed.confirm ? ' collapsed' : '') + '" id="pp-body-confirm">';

  // Accept All button
  if (count > 1) {
    h += '<button class="pp-btn-accept-all" onclick="ppAcceptAll(' + "'" + esc(entityId) + "'" + ')">Accept All (' + count + ')</button>';
  }

  // Ready cluster cards
  for (var i = 0; i < readyClusters.length; i++) {
    var c = readyClusters[i];
    var srcIcon = getPpSourceIcon(c.source_type || '');
    var sigCount = c.signal_count || 0;
    var confPct = Math.round((c.association_confidence || 0) * 100);

    h += '<div class="pp-confirm-card">';
    h += '<div class="pp-confirm-summary">' + srcIcon + ' ' + esc(c.name || 'Data') + ': ' + sigCount + ' signal' + (sigCount !== 1 ? 's' : '') + '</div>';
    h += '<div class="pp-confirm-health">Confidence: ' + confPct + '% \u2014 ' + esc(c.quadrant_label || '') + '</div>';
    h += '<button class="pp-btn-accept" onclick="ppAcceptCluster(' + "'" + esc(c.cluster_id) + "'" + ',' + "'" + esc(entityId) + "'" + ')" style="margin-top:4px;width:100%">Accept</button>';
    h += '</div>';
  }

  // Recent confirmations
  if (recent.length > 0) {
    h += '<div class="pp-recent">';
    h += '<div class="pp-recent-title">Recent Confirmations</div>';
    for (var i = 0; i < Math.min(recent.length, 3); i++) {
      var r = recent[i];
      var dateStr = r.merged_at ? new Date(r.merged_at).toLocaleDateString() : '';
      var changeDesc = (r.changes && r.changes.length > 0) ? r.changes.join(', ') : 'Data merged';
      h += '<div class="pp-recent-item">' + esc(changeDesc.slice(0, 40)) + (dateStr ? ' \u2014 ' + esc(dateStr) : '') + '</div>';
    }
    h += '</div>';
  }

  if (count === 0 && recent.length === 0) {
    h += '<div class="pp-empty"><span class="pp-empty-check">\u2713</span>All data confirmed</div>';
  }
  h += '</div></div>';
  return h;
}

function getPpSourceIcon(srcType) {
  if (/linkedin/i.test(srcType)) return '<svg width="12" height="12" viewBox="0 0 24 24" fill="#0A66C2" style="vertical-align:middle"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg>';
  if (/file|pdf|doc/i.test(srcType)) return '\uD83D\uDCC4';
  if (/url|web|http/i.test(srcType)) return '\uD83C\uDF10';
  if (/social/i.test(srcType)) return '\uD83D\uDCF1';
  if (/user/i.test(srcType)) return '\u270D\uFE0F';
  return '\uD83D\uDCCB';
}

/* --- Pipeline Actions --- */
function ppAcceptCluster(clusterId, entityId) {
  toast('Accepting cluster...');
  var action = entityId ? 'merge' : 'create_new';
  var payload = { action: action };
  if (entityId) payload.target_entity_id = entityId;
  api('POST', '/api/clusters/resolve', Object.assign({ cluster_id: clusterId }, payload)).then(function(res) {
    toast(res.message || 'Cluster accepted');
    refreshReviewQueueBadge();
    // Refresh right panel
    if (entityId && selectedId === entityId) {
      api('GET', '/api/entity/' + entityId).then(function(data) {
        selectedData = data;
        renderDetail(data);
        renderRightPanel(data);
      });
    } else {
      renderRightPanel(selectedData);
    }
  }).catch(function(err) { toast('Failed: ' + err.message); });
}

function ppRejectCluster(clusterId, entityId) {
  toast('Rejecting cluster...');
  api('POST', '/api/clusters/resolve', { cluster_id: clusterId, action: 'skip' }).then(function(res) {
    toast(res.message || 'Cluster rejected');
    refreshReviewQueueBadge();
    if (entityId && selectedId === entityId) {
      api('GET', '/api/entity/' + entityId).then(function(data) {
        selectedData = data;
        renderDetail(data);
        renderRightPanel(data);
      });
    } else {
      renderRightPanel(selectedData);
    }
  }).catch(function(err) { toast('Failed: ' + err.message); });
}

function ppAcceptAll(entityId) {
  toast('Accepting all ready clusters...');
  var endpoint = entityId ? '/api/entity/' + entityId + '/pipeline' : '/api/pipeline/global';
  api('GET', endpoint).then(function(pipeline) {
    var readyClusters = (pipeline.confirm && pipeline.confirm.ready_clusters) || [];
    if (readyClusters.length === 0) { toast('Nothing to accept'); return; }
    var promises = readyClusters.map(function(c) {
      var payload = { cluster_id: c.cluster_id, action: entityId ? 'merge' : 'create_new' };
      if (entityId) payload.target_entity_id = entityId;
      return api('POST', '/api/clusters/resolve', payload);
    });
    Promise.all(promises).then(function() {
      toast('Accepted ' + readyClusters.length + ' cluster' + (readyClusters.length > 1 ? 's' : ''));
      refreshReviewQueueBadge();
      if (entityId && selectedId === entityId) {
        api('GET', '/api/entity/' + entityId).then(function(data) {
          selectedData = data;
          renderDetail(data);
          renderRightPanel(data);
        });
      } else {
        renderRightPanel(selectedData);
      }
    });
  }).catch(function(err) { toast('Failed: ' + err.message); });
}

function ppQuickFind(platform, name, entityId) {
  if (!name) { toast('No entity name'); return; }
  toast('Searching ' + platform + ' for ' + name + '...');
  var payload = { name: name, context_for: entityId };
  if (platform === 'linkedin') payload.context = 'LinkedIn';
  if (platform === 'x') payload.context = 'Twitter/X';
  api('POST', '/api/discover-entity', payload).then(function(data) {
    if (data.candidates && data.candidates.length > 1) {
      toast('Found ' + data.candidates.length + ' candidates — check Review');
    } else if (data.found || data.status === 'staged') {
      toast('Found profile — check Review');
    } else {
      toast('No profile found for ' + name);
    }
    refreshReviewQueueBadge();
    renderRightPanel(selectedData);
  }).catch(function(err) { toast('Discovery failed: ' + err.message); });
}

function ppQuickDiscover(name, entityId) {
  if (!name) { toast('No entity name'); return; }
  toast('Discovering connections for ' + name + '...');
  api('POST', '/api/discover-entity', { name: name, context_for: entityId }).then(function(data) {
    if (data.found || data.status === 'staged') {
      toast('Found profile — check Review');
    } else {
      toast('No profile found');
    }
    refreshReviewQueueBadge();
    renderRightPanel(selectedData);
  }).catch(function(err) { toast('Discovery failed: ' + err.message); });
}

function ppEnrich(attrKey) {
  var input = document.getElementById('rpUrlInput');
  if (input) {
    input.focus();
    input.placeholder = 'Paste URL to enrich ' + attrKey.replace(/_/g, ' ') + '...';
  }
}

// Right panel file upload with entity pre-association
function rpHandleFiles(fileList, entityId) {
  if (!fileList || fileList.length === 0) return;
  var formData = new FormData();
  for (var i = 0; i < fileList.length; i++) {
    formData.append('files', fileList[i]);
  }
  var url = '/api/ingest/files?preview=false';
  if (entityId) url += '&context_for=' + encodeURIComponent(entityId);
  toast('Uploading ' + fileList.length + ' file(s)...');
  fetch(url, {
    method: 'POST',
    headers: getAuthHeaders(),
    body: formData
  }).then(function(resp) { return resp.json(); }).then(function(result) {
    var count = (result.entities_created || []).length + (result.clusters_created || []).length;
    var eName = entityId && selectedData ? (selectedData.entity && (selectedData.entity.name.full || selectedData.entity.name.common) || entityId) : '';
    if (entityId && eName) {
      toast('Added ' + count + ' data points to ' + eName);
    } else {
      toast('Extracted ' + count + ' items — check Review');
    }
    // Refresh current entity
    if (entityId && selectedId === entityId) {
      api('GET', '/api/entity/' + entityId).then(function(data) {
        selectedData = data;
        renderDetail(data);
        renderRightPanel(data);
      });
    }
    refreshReviewQueueBadge();
  }).catch(function(err) { toast('Upload failed: ' + err.message); });
  // Clear input
  var fi = document.getElementById('rpFileInput');
  if (fi) fi.value = '';
}

// Right panel URL extraction with entity pre-association
function rpExtractURL(entityId) {
  var input = document.getElementById('rpUrlInput');
  var url = (input && input.value || '').trim();
  if (!url) { toast('Enter a URL first'); return; }
  var btn = document.getElementById('rpUrlBtn');
  if (btn) { btn.disabled = true; btn.textContent = '...'; }
  var payload = { url: url };
  if (entityId) payload.context_for = entityId;
  api('POST', '/api/extract-url', payload).then(function(data) {
    var clusters = data.scored_clusters || [];
    var eName = entityId && selectedData ? (selectedData.entity && (selectedData.entity.name.full || selectedData.entity.name.common) || entityId) : '';
    if (clusters.length > 0) {
      if (entityId && eName) {
        toast('Extracted ' + clusters.length + ' signals for ' + eName + ' — check Review');
      } else {
        toast('Extracted ' + clusters.length + ' signals — check Review');
      }
    } else {
      toast('No new data found at that URL');
    }
    if (input) input.value = '';
    if (btn) { btn.disabled = false; btn.textContent = 'Extract'; }
    refreshReviewQueueBadge();
    // Refresh pipeline
    if (entityId && selectedId === entityId) {
      api('GET', '/api/entity/' + entityId).then(function(d) {
        selectedData = d;
        renderDetail(d);
        renderRightPanel(d);
      });
    } else {
      renderRightPanel(selectedData);
    }
  }).catch(function(err) {
    toast('Extraction failed: ' + err.message);
    if (btn) { btn.disabled = false; btn.textContent = 'Extract'; }
  });
}

// Right panel name discovery with entity pre-association
function rpDiscover(entityId) {
  var nameInput = document.getElementById('rpDiscoverName');
  var ctxInput = document.getElementById('rpDiscoverCtx');
  var name = (nameInput && nameInput.value || '').trim();
  var ctx = (ctxInput && ctxInput.value || '').trim();
  if (!name || name.length < 2) { toast('Name too short'); return; }
  toast('Searching for ' + name + '...');
  var payload = { name: name };
  if (ctx) payload.context = ctx;
  if (entityId) payload.context_for = entityId;
  api('POST', '/api/discover-entity', payload).then(function(data) {
    if (data.candidates && data.candidates.length > 1) {
      toast('Found ' + data.candidates.length + ' candidates — check Review');
    } else if (data.found || data.status === 'staged') {
      toast('Found profile — check Review');
    } else {
      toast('No LinkedIn profile found for ' + name);
    }
    if (nameInput) nameInput.value = '';
    if (ctxInput) ctxInput.value = '';
    refreshReviewQueueBadge();
    renderRightPanel(selectedData);
  }).catch(function(err) { toast('Discovery failed: ' + err.message); });
}

/* --- File Upload --- */
var uploadFiles = [];
var uploadInProgress = false;

function showUploadView() {
  selectedId = null;
  selectedView = null;
  renderRightPanel(null);
  uploadFiles = [];
  uploadInProgress = false;
  var h = '<div class="upload-view active">';
  h += '<h2 style="font-size:1.2rem;font-weight:700;color:var(--text-primary);margin-bottom:16px;">Upload Files</h2>';
  h += '<div class="upload-dropzone" id="uploadDropzone">';
  h += '<div class="upload-dropzone-icon">+</div>';
  h += '<div class="upload-dropzone-text">Drag & drop files here, or click to browse</div>';
  h += '<div class="upload-dropzone-hint">PDF, DOC, DOCX, XLSX, CSV, TXT, MD, JSON &mdash; up to 50 MB per file</div>';
  h += '</div>';
  h += '<div class="url-extract-section" style="margin:20px 0;padding:16px;background:var(--bg-secondary,#f5f5f7);border-radius:10px;">';
  h += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);margin-bottom:8px;">Or paste a URL</div>';
  h += '<div style="display:flex;gap:8px;">';
  h += '<input type="url" id="urlExtractInput" placeholder="https://example.com/about" style="flex:1;padding:8px 12px;border:1px solid var(--border,#e2e2e5);border-radius:6px;font-size:0.85rem;background:var(--bg-primary,#fff);color:var(--text-primary);" />';
  h += '<button onclick="extractFromURL()" id="btnExtractUrl" style="padding:8px 16px;border:none;border-radius:6px;background:#6366f1;color:#fff;font-size:0.82rem;font-weight:600;cursor:pointer;white-space:nowrap;">Extract</button>';
  h += '</div>';
  h += '<div id="urlExtractStatus" style="margin-top:8px;font-size:0.78rem;color:var(--text-muted);display:none;"></div>';
  h += '</div>';
  // === NAME DISCOVERY (Point Agent v1) ===
  h += '<div class="url-extract-section" style="margin:12px 0 20px;padding:16px;background:var(--bg-secondary,#f5f5f7);border-radius:10px;">';
  h += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);margin-bottom:8px;">Or search by name</div>';
  h += '<div style="display:flex;gap:8px;margin-bottom:6px;">';
  h += '<input type="text" id="discoverNameInput" placeholder="e.g. Andre Burgin" style="flex:1;padding:8px 12px;border:1px solid var(--border,#e2e2e5);border-radius:6px;font-size:0.85rem;background:var(--bg-primary,#fff);color:var(--text-primary);" />';
  h += '<button onclick="discoverEntity()" id="btnDiscover" style="padding:8px 16px;border:none;border-radius:6px;background:#10b981;color:#fff;font-size:0.82rem;font-weight:600;cursor:pointer;white-space:nowrap;">Discover</button>';
  h += '</div>';
  h += '<div style="display:flex;gap:8px;">';
  h += '<input type="text" id="discoverContextInput" placeholder="Optional: works at Meta, Atlanta, etc." style="flex:1;padding:6px 12px;border:1px solid var(--border,#e2e2e5);border-radius:6px;font-size:0.78rem;background:var(--bg-primary,#fff);color:var(--text-muted);" />';
  h += '</div>';
  h += '<div id="discoverStatus" style="margin-top:10px;display:none;"></div>';
  h += '<div id="discoverCandidates" style="margin-top:10px;display:none;"></div>';
  h += '</div>';
  h += '<div class="upload-file-list" id="uploadFileList"></div>';
  h += '<div id="uploadProgressLog" class="upload-progress-log" style="display:none;"></div>';
  h += '<div id="uploadSummary" style="display:none;"></div>';
  h += '<button class="btn-start-upload" id="btnStartUpload" onclick="startUpload()" style="display:none;">Upload & Extract</button>';
  h += '<button class="btn-back-upload" onclick="hideUploadView()">Back to Entities</button>';
  h += '</div>';
  document.getElementById('main').innerHTML = h;

  // Wire up drop zone
  var dz = document.getElementById('uploadDropzone');
  dz.addEventListener('click', function() { document.getElementById('uploadFileInput').click(); });
  dz.addEventListener('dragover', function(e) { e.preventDefault(); dz.classList.add('dragover'); });
  dz.addEventListener('dragleave', function() { dz.classList.remove('dragover'); });
  dz.addEventListener('drop', function(e) {
    e.preventDefault(); dz.classList.remove('dragover');
    addUploadFiles(e.dataTransfer.files);
  });
  document.getElementById('uploadFileInput').onchange = function(e) {
    addUploadFiles(e.target.files);
    e.target.value = '';
  };

  // Deselect sidebar items
  var items = document.querySelectorAll('.entity-item');
  for (var i = 0; i < items.length; i++) items[i].classList.remove('active');
}

function hideUploadView() {
  if (uploadInProgress) return;
  document.getElementById('main').innerHTML = '<div class="empty-state" id="emptyState">Select an entity from the sidebar<br/>to view its knowledge graph profile</div>';
}

/* --- URL Extraction --- */
var urlExtractInProgress = false;
function extractFromURL() {
  var urlInput = document.getElementById('urlExtractInput');
  var statusEl = document.getElementById('urlExtractStatus');
  var btn = document.getElementById('btnExtractUrl');
  if (!urlInput || urlExtractInProgress) return;
  var url = urlInput.value.trim();
  if (!url) { toast('Please enter a URL'); return; }
  if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) { toast('URL must start with http:// or https://'); return; }

  urlExtractInProgress = true;
  btn.disabled = true;
  btn.textContent = 'Extracting...';
  statusEl.style.display = 'block';
  statusEl.style.color = 'var(--text-muted)';

  // Smart URL routing: all URLs go through /api/extract-url (server-side ScrapingDog for LinkedIn)
  var isLinkedIn = url.indexOf('linkedin.com/in/') !== -1;
  var isX = url.indexOf('x.com/') !== -1 || url.indexOf('twitter.com/') !== -1;
  var isIG = url.indexOf('instagram.com/') !== -1;
  var endpoint = '/api/extract-url';
  var body = { url: url };
  var label = isLinkedIn ? 'Looking up LinkedIn profile via ScrapingDog...'
    : isX ? 'Extracting X profile...'
    : isIG ? 'Extracting Instagram profile...'
    : 'Fetching and analyzing ' + url + '...';
  statusEl.textContent = label;

  api('POST', endpoint, body).then(function(data) {
    urlExtractInProgress = false;
    btn.disabled = false;
    btn.textContent = 'Extract';

    if (!data.entities || data.entities.length === 0) {
      statusEl.textContent = 'No entities found at that URL.';
      statusEl.style.color = 'var(--warning, #d97706)';
      return;
    }

    statusEl.textContent = 'Found ' + data.entities.length + ' entities from ' + url;
    statusEl.style.color = 'var(--success, #22c55e)';

    // Feed into existing preview flow
    previewEntities = data.entities;
    previewScoredClusters = data.scored_clusters || [];
    previewSource = 'url_extract:' + url;

    // Show summary + preview checklist
    var sumEl = document.getElementById('uploadSummary');
    if (sumEl) {
      sumEl.style.display = 'block';
      sumEl.innerHTML = '';
    }
    var logEl = document.getElementById('uploadProgressLog');
    if (logEl) { logEl.style.display = 'block'; logEl.innerHTML = '<div style="padding:8px;color:var(--success);">Extracted ' + data.entity_count + ' entities from URL</div>'; }
    renderPreviewChecklist();
  }).catch(function(err) {
    urlExtractInProgress = false;
    btn.disabled = false;
    btn.textContent = 'Extract';
    statusEl.textContent = 'Error: ' + (err.message || 'Failed to extract from URL');
    statusEl.style.color = 'var(--error, #ef4444)';
    // Bug fix: clear stale preview data so user can't accidentally save old entities
    previewEntities = [];
    previewScoredClusters = [];
    var sumEl = document.getElementById('uploadSummary');
    if (sumEl) { sumEl.style.display = 'none'; sumEl.innerHTML = ''; }
  });
}

/* --- Name Discovery (Point Agent v1) --- */
var discoverInProgress = false;
function discoverEntity() {
  var nameInput = document.getElementById('discoverNameInput');
  var ctxInput = document.getElementById('discoverContextInput');
  var statusEl = document.getElementById('discoverStatus');
  var candidatesEl = document.getElementById('discoverCandidates');
  var btn = document.getElementById('btnDiscover');
  if (!nameInput || discoverInProgress) return;
  var name = nameInput.value.trim();
  if (!name) { toast('Please enter a name to discover'); return; }

  discoverInProgress = true;
  btn.disabled = true;
  btn.textContent = 'Discovering...';
  statusEl.style.display = 'block';
  candidatesEl.style.display = 'none';
  candidatesEl.innerHTML = '';

  // Show progress steps
  var stepIdx = 0;
  var stepMsgs = [
    'Searching for ' + esc(name) + '...',
    'Generating LinkedIn profile candidates...',
    'Trying LinkedIn profiles...',
    'Analyzing results...'
  ];
  statusEl.innerHTML = '<div style="display:flex;align-items:center;gap:8px;"><div class="discover-spinner"></div><span id="discoverStepText">' + stepMsgs[0] + '</span></div>';

  var stepInterval = setInterval(function() {
    stepIdx++;
    if (stepIdx < stepMsgs.length) {
      var stepText = document.getElementById('discoverStepText');
      if (stepText) stepText.textContent = stepMsgs[stepIdx];
    }
  }, 3000);

  var body = { name: name };
  var ctx = ctxInput ? ctxInput.value.trim() : '';
  if (ctx) body.context = ctx;

  api('POST', '/api/discover-entity', body).then(function(data) {
    clearInterval(stepInterval);
    discoverInProgress = false;
    btn.disabled = false;
    btn.textContent = 'Discover';

    if (data.status === 'not_found') {
      statusEl.innerHTML = '<div style="color:var(--warning,#d97706);font-size:0.82rem;">' + esc(data.message) + '</div>';
      return;
    }

    if (data.status === 'disambiguation') {
      // Multiple candidates — show picker with context highlighting
      var msgColor = data.context_warning ? 'var(--warning,#d97706)' : '#6366f1';
      statusEl.innerHTML = '<div style="color:' + msgColor + ';font-size:0.82rem;font-weight:600;">' + esc(data.message) + '</div>';
      candidatesEl.style.display = 'block';
      var ch = '';
      for (var i = 0; i < data.candidates.length; i++) {
        var c = data.candidates[i];
        var cm = c.context_matches || {};
        var hasMatch = c.context_score > 0;
        var borderColor = hasMatch ? '#10b981' : 'var(--border-primary)';
        ch += '<div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;margin-bottom:6px;background:var(--bg-card);border:1px solid ' + borderColor + ';border-radius:8px;cursor:pointer;" onclick="selectDiscoverCandidate(' + "'" + esc(c.slug) + "'" + ', ' + "'" + esc(c.linkedin_url) + "'" + ')">';
        ch += '<div style="flex:1;overflow:hidden;">';
        ch += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);">' + esc(c.name);
        if (hasMatch) ch += ' <span style="font-size:0.65rem;background:rgba(16,185,129,0.12);color:#10b981;padding:1px 6px;border-radius:8px;font-weight:700;">MATCH</span>';
        ch += '</div>';
        if (c.headline) {
          var hlColor = cm.headline ? '#10b981' : 'var(--text-muted)';
          var hlWeight = cm.headline ? '600' : '400';
          ch += '<div style="font-size:0.75rem;color:' + hlColor + ';font-weight:' + hlWeight + ';margin-top:1px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + esc(c.headline) + '</div>';
        }
        var metaParts = [];
        if (c.company) {
          var coColor = cm.company ? '#10b981' : 'var(--text-muted)';
          var coWeight = cm.company ? '600' : '400';
          metaParts.push('<span style="color:' + coColor + ';font-weight:' + coWeight + ';">' + esc(c.company) + '</span>');
        }
        if (c.location) {
          var locColor = cm.location ? '#10b981' : 'var(--text-muted)';
          var locWeight = cm.location ? '600' : '400';
          metaParts.push('<span style="color:' + locColor + ';font-weight:' + locWeight + ';">' + esc(c.location) + '</span>');
        }
        if (metaParts.length > 0) ch += '<div style="font-size:0.72rem;margin-top:1px;">' + metaParts.join(' &mdash; ') + '</div>';
        ch += '</div>';
        ch += '<button style="padding:4px 12px;border:1px solid #10b981;border-radius:6px;background:' + (hasMatch ? '#10b981' : 'transparent') + ';color:' + (hasMatch ? '#fff' : '#10b981') + ';font-size:0.72rem;font-weight:600;cursor:pointer;white-space:nowrap;margin-left:8px;">Select</button>';
        ch += '</div>';
      }
      candidatesEl.innerHTML = ch;
      return;
    }

    if (data.status === 'found') {
      statusEl.innerHTML = '<div style="color:var(--success,#22c55e);font-size:0.82rem;font-weight:600;">' + esc(data.message) + '</div>';

      // Show what was found
      var fh = '<div style="padding:10px 12px;background:var(--bg-card);border:1px solid var(--border-primary);border-radius:8px;margin-top:8px;">';
      fh += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);">' + esc(data.match.name) + '</div>';
      if (data.match.headline) fh += '<div style="font-size:0.75rem;color:var(--text-muted);">' + esc(data.match.headline) + '</div>';
      if (data.match.location) fh += '<div style="font-size:0.72rem;color:var(--text-muted);">' + esc(data.match.location) + '</div>';
      fh += '<div style="font-size:0.72rem;color:#6366f1;margin-top:4px;">' + data.cluster_count + ' clusters staged for review</div>';
      fh += '</div>';
      candidatesEl.style.display = 'block';
      candidatesEl.innerHTML = fh;

      // Refresh sidebar to show new review queue count
      loadEntities();
      refreshReviewQueueBadge();
      return;
    }
  }).catch(function(err) {
    clearInterval(stepInterval);
    discoverInProgress = false;
    btn.disabled = false;
    btn.textContent = 'Discover';
    statusEl.innerHTML = '<div style="color:var(--error,#ef4444);font-size:0.82rem;">Error: ' + esc(err.message || 'Discovery failed') + '</div>';
  });
}

function selectDiscoverCandidate(slug, linkedinUrl) {
  var statusEl = document.getElementById('discoverStatus');
  var candidatesEl = document.getElementById('discoverCandidates');
  var btn = document.getElementById('btnDiscover');
  discoverInProgress = true;
  if (btn) { btn.disabled = true; btn.textContent = 'Extracting...'; }
  statusEl.innerHTML = '<div style="display:flex;align-items:center;gap:8px;"><div class="discover-spinner"></div><span>Extracting career data from selected profile...</span></div>';
  candidatesEl.style.display = 'none';

  api('POST', '/api/discover-entity/select', { slug: slug, linkedin_url: linkedinUrl }).then(function(data) {
    discoverInProgress = false;
    if (btn) { btn.disabled = false; btn.textContent = 'Discover'; }

    if (data.status === 'found') {
      statusEl.innerHTML = '<div style="color:var(--success,#22c55e);font-size:0.82rem;font-weight:600;">' + esc(data.message) + '</div>';
      var fh = '<div style="padding:10px 12px;background:var(--bg-card);border:1px solid var(--border-primary);border-radius:8px;margin-top:8px;">';
      fh += '<div style="font-size:0.85rem;font-weight:600;color:var(--text-primary);">' + esc(data.match.name) + '</div>';
      fh += '<div style="font-size:0.72rem;color:#6366f1;margin-top:4px;">' + data.cluster_count + ' clusters staged for review</div>';
      fh += '</div>';
      candidatesEl.style.display = 'block';
      candidatesEl.innerHTML = fh;
      loadEntities();
      refreshReviewQueueBadge();
    }
  }).catch(function(err) {
    discoverInProgress = false;
    if (btn) { btn.disabled = false; btn.textContent = 'Discover'; }
    statusEl.innerHTML = '<div style="color:var(--error,#ef4444);font-size:0.82rem;">Error: ' + esc(err.message || 'Extraction failed') + '</div>';
  });
}

/* --- Org Enrichment --- */
function enrichOrgFromWeb(entityId, orgName) {
  var btn = document.getElementById('btnEnrichOrg');
  if (!btn) return;
  btn.disabled = true;
  btn.textContent = 'Enriching...';
  btn.style.color = 'var(--text-muted)';

  api('POST', '/api/enrich-org', { entity_id: entityId }).then(function(data) {
    if (data.enriched) {
      toast('Enriched ' + orgName + ': ' + (data.enrichment.industry || 'web data') + ', ' + data.enrichment.new_attributes + ' new attributes');
      btn.textContent = 'Enriched';
      btn.style.color = 'var(--success, #22c55e)';
      btn.style.borderColor = 'var(--success, #22c55e)';
      // Reload entity to show new data
      setTimeout(function() { selectEntity(entityId); }, 500);
    } else {
      toast(data.message || 'Could not enrich this organization');
      btn.textContent = 'Not Found';
      btn.style.color = 'var(--warning, #d97706)';
      btn.disabled = false;
      setTimeout(function() { btn.textContent = 'Enrich from Web'; btn.style.color = '#6366f1'; }, 3000);
    }
  }).catch(function(err) {
    toast('Enrichment error: ' + (err.message || 'Unknown error'));
    btn.disabled = false;
    btn.textContent = 'Retry';
    btn.style.color = 'var(--error, #ef4444)';
    setTimeout(function() { btn.textContent = 'Enrich from Web'; btn.style.color = '#6366f1'; }, 3000);
  });
}

/* --- Cleanup View --- */
var cleanupEntities = [];
var cleanupSelected = {};
var cleanupTypeFilter = '';
var cleanupMaxObs = '';

function showCleanupView() {
  selectedId = null;
  selectedView = null;
  cleanupEntities = [];
  cleanupSelected = {};
  cleanupTypeFilter = '';
  cleanupMaxObs = '';
  document.getElementById('main').innerHTML = '<div style="padding:40px;color:var(--text-muted);text-align:center;">Loading entities...</div>';
  api('GET', '/api/search?q=*').then(function(data) {
    cleanupEntities = (data.results || []).sort(function(a, b) {
      return (a.name || '').localeCompare(b.name || '');
    });
    renderCleanupView();
  }).catch(function(err) {
    document.getElementById('main').innerHTML = '<div style="padding:40px;color:#ef4444;">Error loading entities: ' + esc(err.message) + '</div>';
  });
}

function getCleanupVisible() {
  return cleanupEntities.filter(function(e) {
    if (cleanupTypeFilter && e.entity_type !== cleanupTypeFilter) return false;
    if (cleanupMaxObs !== '' && !isNaN(parseInt(cleanupMaxObs))) {
      if ((e.observation_count || 0) >= parseInt(cleanupMaxObs)) return false;
    }
    return true;
  });
}

function renderCleanupView() {
  var visible = getCleanupVisible();
  var selCount = 0;
  for (var k in cleanupSelected) { if (cleanupSelected[k]) selCount++; }

  var h = '<div style="padding:24px;max-width:900px;margin:0 auto;">';
  h += '<h2 style="font-size:1.2rem;font-weight:700;color:var(--text-primary);margin-bottom:16px;">Cleanup Entities</h2>';

  // Toolbar
  h += '<div class="cleanup-toolbar">';
  h += '<label>Type: <select onchange="cleanupTypeFilter=this.value;renderCleanupView()">';
  h += '<option value="">All</option>';
  h += '<option value="person"' + (cleanupTypeFilter === 'person' ? ' selected' : '') + '>Person</option>';
  h += '<option value="business"' + (cleanupTypeFilter === 'business' ? ' selected' : '') + '>Business</option>';
  h += '<option value="institution"' + (cleanupTypeFilter === 'institution' ? ' selected' : '') + '>Institution</option>';
  h += '<option value="organization"' + (cleanupTypeFilter === 'organization' ? ' selected' : '') + '>Organization</option>';
  h += '</select></label>';
  h += '<label>Max obs: <input type="number" min="0" style="width:60px" value="' + esc(cleanupMaxObs) + '" onchange="cleanupMaxObs=this.value;renderCleanupView()" placeholder="e.g. 2"></label>';
  h += '<label><input type="checkbox" class="cleanup-check" onchange="toggleAllCleanup(this.checked)"> Select all visible (' + visible.length + ')</label>';
  h += '<button style="margin-left:auto;padding:6px 14px;border-radius:var(--radius-sm);border:1px solid var(--border-primary);background:var(--bg-primary);color:var(--text-secondary);font-size:0.78rem;cursor:pointer;" onclick="runDedupRelationships()">Dedup Relationships</button>';
  h += '</div>';

  // Entity list
  h += '<div class="cleanup-entity-list">';
  if (visible.length === 0) {
    h += '<div style="padding:24px;text-align:center;color:var(--text-muted);font-size:0.85rem;">No entities match filters</div>';
  }
  for (var i = 0; i < visible.length; i++) {
    var e = visible[i];
    var checked = cleanupSelected[e.entity_id] ? ' checked' : '';
    h += '<div class="cleanup-row">';
    h += '<input type="checkbox" class="cleanup-check"' + checked + ' onchange="toggleCleanupEntity(' + "'" + esc(e.entity_id) + "'" + ')">';
    h += '<span class="cleanup-name">' + esc(e.name || e.entity_id) + '</span>';
    h += '<span class="cleanup-type-badge">' + esc(e.entity_type || '') + '</span>';
    h += '<span class="cleanup-count" title="Observations">' + (e.observation_count || 0) + ' obs</span>';
    h += '<span class="cleanup-count" title="Relationships">' + (e.relationship_count || 0) + ' rels</span>';
    h += '</div>';
  }
  h += '</div>';

  // Action bar
  h += '<div class="cleanup-actions">';
  h += '<button class="btn-danger"' + (selCount === 0 ? ' disabled' : '') + ' onclick="bulkDeleteSelected()">Delete Selected</button>';
  h += '<span class="cleanup-selection-count">' + selCount + ' selected</span>';
  h += '<button style="margin-left:auto;padding:8px 16px;border-radius:var(--radius-sm);border:1px solid var(--border-primary);background:var(--bg-primary);color:var(--text-secondary);font-size:0.82rem;cursor:pointer;" onclick="hideUploadView()">Back</button>';
  h += '</div>';

  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function toggleCleanupEntity(id) {
  cleanupSelected[id] = !cleanupSelected[id];
  renderCleanupView();
}

function toggleAllCleanup(checked) {
  var visible = getCleanupVisible();
  for (var i = 0; i < visible.length; i++) {
    cleanupSelected[visible[i].entity_id] = checked;
  }
  renderCleanupView();
}

function bulkDeleteSelected() {
  var ids = [];
  for (var k in cleanupSelected) { if (cleanupSelected[k]) ids.push(k); }
  if (ids.length === 0) return;
  if (!confirm('Delete ' + ids.length + ' entities and all their connected objects? This cannot be undone.')) return;

  api('POST', '/api/entities/bulk-delete', { entity_ids: ids }).then(function(result) {
    toast('Deleted ' + result.deleted + ' entities' + (result.failed > 0 ? ' (' + result.failed + ' not found)' : ''));
    cleanupSelected = {};
    // Refresh sidebar + cleanup view
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
      cleanupEntities = allEntities.slice().sort(function(a, b) {
        return (a.name || '').localeCompare(b.name || '');
      });
      renderCleanupView();
    });
  }).catch(function(err) {
    toast('Bulk delete failed: ' + err.message);
  });
}

function runDedupRelationships() {
  if (!confirm('Scan all entities and remove duplicate relationships?')) return;
  api('POST', '/api/dedup-relationships').then(function(result) {
    var msg = 'Removed ' + result.total_removed + ' duplicate relationships across ' + result.entities_affected + ' entities';
    toast(msg);
  }).catch(function(err) {
    toast('Dedup failed: ' + err.message);
  });
}

var ALLOWED_UPLOAD_EXT = ['.pdf', '.docx', '.xlsx', '.xls', '.csv', '.txt', '.md', '.json'];

function addUploadFiles(fileList) {
  for (var i = 0; i < fileList.length; i++) {
    var f = fileList[i];
    var ext = '.' + f.name.split('.').pop().toLowerCase();
    if (ALLOWED_UPLOAD_EXT.indexOf(ext) === -1) {
      toast('Unsupported file type: ' + ext);
      continue;
    }
    // Avoid duplicates by name
    var dup = false;
    for (var j = 0; j < uploadFiles.length; j++) {
      if (uploadFiles[j].name === f.name) { dup = true; break; }
    }
    if (!dup) uploadFiles.push(f);
  }
  renderUploadFileList();
}

function removeUploadFile(idx) {
  uploadFiles.splice(idx, 1);
  renderUploadFileList();
}

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

function renderUploadFileList() {
  var html = '';
  for (var i = 0; i < uploadFiles.length; i++) {
    var f = uploadFiles[i];
    html += '<div class="upload-file-item">';
    html += '<span class="upload-file-name">' + esc(f.name) + '</span>';
    html += '<span class="upload-file-size">' + formatFileSize(f.size) + '</span>';
    html += '<span class="upload-file-status pending" id="uploadStatus' + i + '">ready</span>';
    html += '<button class="upload-file-remove" onclick="removeUploadFile(' + i + ')">&times;</button>';
    html += '</div>';
  }
  document.getElementById('uploadFileList').innerHTML = html;
  var btn = document.getElementById('btnStartUpload');
  if (btn) btn.style.display = uploadFiles.length > 0 ? 'block' : 'none';
}

var previewEntities = [];
var previewScoredClusters = [];
var previewSource = '';

function startUpload() {
  if (uploadFiles.length === 0 || uploadInProgress) return;
  uploadInProgress = true;
  previewEntities = [];
  previewScoredClusters = [];
  document.getElementById('btnStartUpload').disabled = true;

  // Disable remove buttons
  var removeBtns = document.querySelectorAll('.upload-file-remove');
  for (var i = 0; i < removeBtns.length; i++) removeBtns[i].style.display = 'none';

  var log = document.getElementById('uploadProgressLog');
  log.style.display = 'block';
  log.innerHTML = '<div class="log-info">Extracting entities (preview mode)...</div>';

  var formData = new FormData();
  for (var i = 0; i < uploadFiles.length; i++) {
    formData.append('files', uploadFiles[i]);
  }
  previewSource = uploadFiles.length === 1 ? uploadFiles[0].name : uploadFiles.length + ' files';

  var headers = getAuthHeaders();
  headers['X-Agent-Id'] = 'wiki-upload';

  fetch('/api/ingest/files?preview=true', {
    method: 'POST',
    headers: headers,
    body: formData,
  }).then(function(response) {
    if (!response.ok) {
      return response.json().then(function(e) {
        throw new Error(e.error || 'Upload failed (' + response.status + ')');
      });
    }
    var reader = response.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';

    function read() {
      return reader.read().then(function(result) {
        if (result.done) {
          uploadComplete();
          return;
        }
        buffer += decoder.decode(result.value, { stream: true });
        var lines = buffer.split('\\n');
        buffer = lines.pop();
        for (var i = 0; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          try {
            var evt = JSON.parse(lines[i]);
            handleUploadEvent(evt);
          } catch (e) {}
        }
        return read();
      });
    }
    return read();
  }).catch(function(err) {
    log.innerHTML += '<div class="log-error">Error: ' + esc(err.message) + '</div>';
    log.scrollTop = log.scrollHeight;
    uploadInProgress = false;
    document.getElementById('btnStartUpload').disabled = false;
    document.getElementById('btnStartUpload').textContent = 'Retry';
  });
}

function handleUploadEvent(evt) {
  var log = document.getElementById('uploadProgressLog');
  if (evt.type === 'started') {
    log.innerHTML += '<div class="log-info">Extracting from ' + evt.total_files + ' file' + (evt.total_files > 1 ? 's' : '') + '...</div>';
  } else if (evt.type === 'file_preview') {
    var idx = evt.file_index - 1;
    var statusEl = document.getElementById('uploadStatus' + idx);
    if (statusEl) {
      statusEl.className = 'upload-file-status done';
      statusEl.textContent = evt.entities.length + ' found';
    }
    if (evt.full_entities) {
      for (var k = 0; k < evt.full_entities.length; k++) previewEntities.push(evt.full_entities[k]);
    }
    if (evt.scored_clusters) {
      for (var k = 0; k < evt.scored_clusters.length; k++) previewScoredClusters.push(evt.scored_clusters[k]);
    }
    log.innerHTML += '<div class="log-info">' + esc(evt.file) + ' — found ' + evt.entities.length + ' entities (pending review)</div>';
  } else if (evt.type === 'preview_complete') {
    // Show preview UI
    log.innerHTML += '<div class="log-info" style="font-weight:600;margin-top:8px;">Review extracted entities below. Uncheck any you want to reject.</div>';
  } else if (evt.type === 'file_progress') {
    var idx = evt.file_index - 1;
    var statusEl = document.getElementById('uploadStatus' + idx);
    if (evt.warning) {
      if (statusEl) {
        statusEl.className = 'upload-file-status error';
        statusEl.textContent = 'no entities';
      }
      log.innerHTML += '<div class="log-error">' + esc(evt.file) + ' — ' + esc(evt.warning) + '</div>';
    } else {
      if (statusEl) {
        statusEl.className = 'upload-file-status done';
        statusEl.textContent = evt.entities_created + ' created, ' + evt.entities_updated + ' merged';
      }
      log.innerHTML += '<div class="log-success">' + esc(evt.file) + ' — ' + evt.entities_created + ' created, ' + evt.entities_updated + ' updated</div>';
    }
  } else if (evt.type === 'file_error') {
    var idx = evt.file_index - 1;
    var statusEl = document.getElementById('uploadStatus' + idx);
    if (statusEl) {
      statusEl.className = 'upload-file-status error';
      statusEl.textContent = 'error';
    }
    log.innerHTML += '<div class="log-error">' + esc(evt.file) + ' — ' + esc(evt.error) + '</div>';
  } else if (evt.type === 'complete') {
    var s = evt.summary || {};
    var sumEl = document.getElementById('uploadSummary');
    sumEl.style.display = 'block';
    sumEl.innerHTML = '<div class="upload-summary">' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.files_processed || 0) + '</div><div class="upload-summary-label">Files</div></div>' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.entities_created || 0) + '</div><div class="upload-summary-label">Created</div></div>' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.entities_updated || 0) + '</div><div class="upload-summary-label">Merged</div></div>' +
      '</div>';
  }
  log.scrollTop = log.scrollHeight;
}

function getClusterForIndex(idx) {
  if (!previewScoredClusters || !previewScoredClusters[idx]) return null;
  return previewScoredClusters[idx];
}

function quadrantLabel(q) {
  if (q === 1) return 'NEW';
  if (q === 2) return 'ENRICH';
  if (q === 3) return 'CONSOLIDATE';
  if (q === 4) return 'DUPLICATE';
  return '';
}

function quadrantClass(q) {
  if (q === 1) return 'new-entity';
  if (q === 2) return 'merge';
  if (q === 3) return 'review';
  if (q === 4) return 'duplicate';
  return '';
}

function renderPreviewChecklist() {
  var html = '<div class="preview-checklist" style="margin-top:12px;">';
  html += '<div style="display:flex;gap:8px;margin-bottom:10px;align-items:center;">';
  html += '<button class="btn-sm" onclick="toggleAllPreview(true)">Select All</button>';
  html += '<button class="btn-sm" onclick="toggleAllPreview(false)">Deselect All</button>';
  html += '<span style="color:var(--text-secondary);font-size:0.8rem;line-height:28px;">' + previewEntities.length + ' entities found</span>';
  if (previewScoredClusters.length > 0) {
    var autoMerge = 0, flagReview = 0, createNew = 0;
    for (var s = 0; s < previewScoredClusters.length; s++) {
      var sc = previewScoredClusters[s];
      if (sc.quadrant === 2 || sc.quadrant === 4) { if (sc.confidence >= 0.8) autoMerge++; else flagReview++; }
      else if (sc.quadrant === 3) flagReview++;
      else createNew++;
    }
    html += '<span style="font-size:0.72rem;color:var(--text-muted);margin-left:auto;">';
    if (autoMerge > 0) html += '<span style="color:#15803d;">' + autoMerge + ' merge</span> ';
    if (flagReview > 0) html += '<span style="color:#92400e;">' + flagReview + ' review</span> ';
    if (createNew > 0) html += '<span style="color:#1d4ed8;">' + createNew + ' new</span>';
    html += '</span>';
  }
  html += '</div>';
  for (var i = 0; i < previewEntities.length; i++) {
    var ent = previewEntities[i].entity || {};
    var type = ent.entity_type || '';
    var name = type === 'person' ? (ent.name && ent.name.full || '') : (ent.name && (ent.name.common || ent.name.legal) || '');
    var summary = ent.summary && ent.summary.value || '';
    if (summary.length > 100) summary = summary.substring(0, 100) + '...';
    var cluster = getClusterForIndex(i);

    html += '<div class="preview-entity-row" style="display:flex;gap:8px;padding:8px;border-bottom:1px solid var(--border-subtle);align-items:flex-start;">';
    html += '<input type="checkbox" checked data-preview-idx="' + i + '" onchange="updatePreviewCount()" style="margin-top:3px;">';
    html += '<div style="flex:1;min-width:0;">';
    html += '<span style="font-weight:600;color:var(--text-primary);">' + esc(name) + '</span>';
    html += ' <span class="type-badge ' + type + '" style="font-size:0.65rem;padding:1px 6px;">' + type + '</span>';
    if (summary) html += '<div style="font-size:0.75rem;color:var(--text-secondary);margin-top:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + esc(summary) + '</div>';

    // Quadrant badge and actions
    if (cluster && cluster.quadrant) {
      var q = cluster.quadrant;
      var conf = cluster.confidence || 0;
      var cid = cluster.cluster_id || '';
      var candidateName = cluster.candidate_entity_name || '';
      var candidateId = cluster.candidate_entity_id || '';

      if (q === 2 && conf >= 0.8) {
        // Q2 high confidence — auto merge
        html += '<div class="preview-cluster-badge merge">MERGE: ' + esc(candidateName) + ' (' + Math.round(conf * 100) + '%)</div>';
        html += '<div class="preview-cluster-actions">';
        html += '<button class="primary" onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'merge' + "'" + ')">Merge into ' + esc(candidateName) + '</button>';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Keep Separate</button>';
        html += '</div>';
      } else if (q === 2 && conf >= 0.5) {
        // Q2 lower confidence — flag for review
        html += '<div class="preview-cluster-badge review">POSSIBLE MATCH: ' + esc(candidateName) + ' (' + Math.round(conf * 100) + '%)</div>';
        html += '<div class="preview-cluster-actions">';
        html += '<button class="primary" onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'merge' + "'" + ')">Link to ' + esc(candidateName) + '</button>';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Keep Separate</button>';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'hold' + "'" + ')">Hold</button>';
        html += '</div>';
      } else if (q === 4) {
        // Q4 — duplicate data
        html += '<div class="preview-cluster-badge duplicate">ALREADY CAPTURED: ' + esc(candidateName) + '</div>';
        html += '<div class="preview-cluster-actions">';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'skip' + "'" + ')">Add Source</button>';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Create Separate</button>';
        html += '</div>';
      } else if (q === 3) {
        // Q3 — consolidate
        var mentions = cluster.related_mentions || 0;
        html += '<div class="preview-cluster-badge review">FOUND ' + mentions + ' EXISTING MENTIONS</div>';
        html += '<div class="preview-cluster-actions">';
        html += '<button class="primary" onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Create Entity & Link</button>';
        html += '<button onclick="resolvePreviewCluster(' + i + ',' + "'" + cid + "'" + ',' + "'" + 'hold' + "'" + ')">Hold</button>';
        html += '</div>';
      } else {
        // Q1 — new data, new entity
        html += '<div class="preview-cluster-badge new-entity">NEW ENTITY</div>';
      }
    }

    html += '</div></div>';
  }
  html += '</div>';
  html += '<button class="btn-start-upload" onclick="confirmPreview()" style="margin-top:12px;background:#22c55e;">Save ' + previewEntities.length + ' Selected Entities</button>';
  var sumEl = document.getElementById('uploadSummary');
  sumEl.style.display = 'block';
  sumEl.innerHTML = html;
  updatePreviewCount();
}

function toggleAllPreview(checked) {
  var boxes = document.querySelectorAll('[data-preview-idx]');
  for (var i = 0; i < boxes.length; i++) boxes[i].checked = checked;
  updatePreviewCount();
}

function updatePreviewCount() {
  var boxes = document.querySelectorAll('[data-preview-idx]');
  var count = 0;
  for (var i = 0; i < boxes.length; i++) { if (boxes[i].checked) count++; }
  var btn = document.querySelector('.btn-start-upload');
  if (btn) btn.textContent = 'Save ' + count + ' Selected Entities';
}

function confirmPreview() {
  // Collect selected entities that haven't been individually resolved yet
  var boxes = document.querySelectorAll('[data-preview-idx]');
  var toResolve = [];
  for (var i = 0; i < boxes.length; i++) {
    if (boxes[i].checked && !boxes[i].disabled) {
      var idx = parseInt(boxes[i].getAttribute('data-preview-idx'));
      var cluster = getClusterForIndex(idx);
      if (cluster && cluster.cluster_id) {
        // Determine default action based on quadrant
        var action = 'create_new';
        if (cluster.quadrant === 4) action = 'skip';
        else if (cluster.quadrant === 2 && cluster.confidence >= 0.8) action = 'merge';
        toResolve.push({ idx: idx, cluster_id: cluster.cluster_id, action: action, quadrant: cluster.quadrant });
      }
    }
  }
  if (toResolve.length === 0) {
    toast('No entities to resolve');
    return;
  }

  var btn = document.querySelector('.btn-start-upload');
  btn.disabled = true;
  btn.textContent = 'Resolving ' + toResolve.length + ' clusters...';

  var created = 0, merged = 0, skipped = 0, failed = 0;
  var pending = toResolve.length;

  function onAllDone() {
    var sumEl = document.getElementById('uploadSummary');
    sumEl.innerHTML = '<div class="upload-summary">' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + created + '</div><div class="upload-summary-label">Created</div></div>' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + merged + '</div><div class="upload-summary-label">Merged</div></div>' +
      (skipped > 0 ? '<div class="upload-summary-stat"><div class="upload-summary-num">' + skipped + '</div><div class="upload-summary-label">Sources Added</div></div>' : '') +
      '</div>';
    var msg = [];
    if (created > 0) msg.push(created + ' created');
    if (merged > 0) msg.push(merged + ' merged');
    if (skipped > 0) msg.push(skipped + ' sources added');
    toast('Resolved: ' + msg.join(', '));
    btn.textContent = 'Done — View Entities';
    btn.disabled = false;
    btn.onclick = function() {
      hideUploadView();
      api('GET', '/api/search?q=*').then(function(data) {
        allEntities = data.results || [];
        entities = allEntities.slice();
        renderSidebar();
      });
    };
    // Refresh sidebar
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
    refreshReviewQueueBadge();
  }

  for (var r = 0; r < toResolve.length; r++) {
    (function(item) {
      api('POST', '/api/clusters/resolve', { cluster_id: item.cluster_id, action: item.action }).then(function(result) {
        if (result.action === 'create_new') created++;
        else if (result.action === 'merge') merged++;
        else if (result.action === 'skip') skipped++;
        // Disable the checkbox
        var boxes = document.querySelectorAll('[data-preview-idx="' + item.idx + '"]');
        for (var b = 0; b < boxes.length; b++) { boxes[b].checked = false; boxes[b].disabled = true; }
        pending--;
        if (pending <= 0) onAllDone();
      }).catch(function(err) {
        failed++;
        pending--;
        if (pending <= 0) onAllDone();
      });
    })(toResolve[r]);
  }
}

/* --- Signal cluster resolution from preview --- */
function resolvePreviewCluster(idx, clusterId, action) {
  var actionBtn = event && event.target;
  if (actionBtn) { actionBtn.disabled = true; actionBtn.textContent = 'Resolving...'; }

  api('POST', '/api/clusters/resolve', { cluster_id: clusterId, action: action }).then(function(result) {
    if (result.error) {
      toast('Error: ' + result.error);
      if (actionBtn) { actionBtn.disabled = false; }
      return;
    }

    // IDENTITY conflict blocked — show confirm/cancel in preview row
    if (result.action === 'conflict_blocked') {
      if (actionBtn) { actionBtn.disabled = false; }
      var row = document.querySelectorAll('.preview-entity-row')[idx];
      if (row) {
        var acts = row.querySelector('.preview-cluster-actions');
        if (acts) {
          var evHtml = '<div style="font-size:0.72rem;color:#a855f7;font-weight:600;margin-bottom:4px;">\\u26A0 Possible identity conflict</div>';
          var ev = result.evidence || [];
          for (var ei = 0; ei < ev.length; ei++) {
            evHtml += '<div style="font-size:0.68rem;margin-bottom:2px;"><strong>' + esc(ev[ei].attribute) + ':</strong> ' + esc(ev[ei].existing_value) + ' vs ' + esc(ev[ei].incoming_value) + '</div>';
          }
          evHtml += '<button class="primary" style="margin-top:4px;" onclick="resolvePreviewCluster(' + idx + ',' + "'" + esc(clusterId) + "'" + ',' + "'" + 'confirm_merge' + "'" + ')">Same person \\u2014 merge</button> ';
          evHtml += '<button onclick="resolvePreviewCluster(' + idx + ',' + "'" + esc(clusterId) + "'" + ',' + "'" + 'create_new' + "'" + ')">Different person</button>';
          acts.innerHTML = evHtml;
        }
      }
      toast('Identity conflict — review evidence');
      return;
    }

    // Update the preview row to show resolved state
    var row = document.querySelectorAll('.preview-entity-row')[idx];
    if (!row) { toast(action + ': ' + (result.entity_name || result.entity_id || 'done')); return; }

    // Remove action buttons and badge
    var badges = row.querySelectorAll('.preview-cluster-badge, .preview-cluster-actions');
    for (var b = 0; b < badges.length; b++) badges[b].remove();

    var innerDiv = row.querySelector('div');
    if (action === 'merge' || action === 'confirm_merge') {
      innerDiv.innerHTML += '<div class="preview-cluster-badge merge" style="margin-top:4px;">MERGED into ' + esc(result.entity_name || result.entity_id) + '</div>';
      // Uncheck this entity since it was resolved via staging
      var checkbox = row.querySelector('input[type=checkbox]');
      if (checkbox) { checkbox.checked = false; checkbox.disabled = true; }
      toast('Merged into ' + (result.entity_name || result.entity_id));
    } else if (action === 'create_new') {
      innerDiv.innerHTML += '<div class="preview-cluster-badge new-entity" style="margin-top:4px;">CREATED: ' + esc(result.entity_id) + '</div>';
      var checkbox = row.querySelector('input[type=checkbox]');
      if (checkbox) { checkbox.checked = false; checkbox.disabled = true; }
      toast('Created entity ' + result.entity_id);
    } else if (action === 'skip') {
      innerDiv.innerHTML += '<div class="preview-cluster-badge duplicate" style="margin-top:4px;">SOURCE ADDED to ' + esc(result.entity_id) + '</div>';
      var checkbox = row.querySelector('input[type=checkbox]');
      if (checkbox) { checkbox.checked = false; checkbox.disabled = true; }
      toast('Source added to ' + result.entity_id);
    } else if (action === 'hold') {
      innerDiv.innerHTML += '<div class="preview-cluster-badge review" style="margin-top:4px;">HELD for Review Queue</div>';
      toast('Held for later review');
    }

    updatePreviewCount();
    refreshReviewQueueBadge();

    // Refresh sidebar
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  }).catch(function(err) {
    toast('Resolution failed: ' + (err.message || 'Unknown error'));
    if (actionBtn) { actionBtn.disabled = false; }
  });
}

/* --- Review Queue View --- */
function refreshReviewQueueBadge() {
  api('GET', '/api/review-queue').then(function(data) {
    var badge = document.getElementById('reviewQueueBadge');
    if (!badge) return;
    var count = data.count || 0;
    if (count > 0) {
      badge.style.display = 'inline-block';
      badge.textContent = count;
      badge.classList.add('pulse');
    } else {
      badge.style.display = 'none';
      badge.classList.remove('pulse');
    }
  }).catch(function() {});
}

function showReviewQueue() {
  selectedId = null;
  selectedView = null;
  document.getElementById('main').innerHTML = '<div style="padding:40px;color:var(--text-muted);text-align:center;">Loading review queue...</div>';

  api('GET', '/api/review-queue').then(function(data) {
    renderReviewQueue(data);
  }).catch(function(err) {
    document.getElementById('main').innerHTML = '<div style="padding:40px;color:#ef4444;">Error loading review queue: ' + esc(err.message) + '</div>';
  });
}

function renderReviewQueue(data) {
  var clusters = data.clusters || [];
  var bundles = data.bundles || [];
  var standalone = data.standalone || [];
  var h = '<div class="review-queue">';

  // Count by state
  var unresolved = 0, provisional = 0;
  for (var i = 0; i < clusters.length; i++) {
    var state = (clusters[i].state || '').toLowerCase();
    if (state === 'unresolved') unresolved++;
    else if (state === 'provisional') provisional++;
  }

  // Header with stats
  h += '<div class="rq-header">';
  h += '<h2><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="1"/><path d="M9 14l2 2 4-4"/></svg> Review Queue</h2>';
  h += '<div class="rq-stats">';
  h += '<div class="rq-stat"><span class="rq-stat-num unresolved">' + bundles.length + '</span><span class="rq-stat-label">Bundles</span></div>';
  h += '<div class="rq-stat"><span class="rq-stat-num provisional">' + standalone.length + '</span><span class="rq-stat-label">Individual</span></div>';
  h += '<div class="rq-stat"><span class="rq-stat-num ready">' + (data.count || 0) + '</span><span class="rq-stat-label">Total Clusters</span></div>';
  h += '</div></div>';

  if ((data.count || 0) === 0) {
    h += '<div class="review-queue-empty"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" opacity="0.2" style="margin-bottom:12px"><circle cx="12" cy="12" r="10"/><path d="M9 12l2 2 4-4"/></svg><br/>No signal clusters pending review.<br/>Extract from a URL or upload files to see clusters here.</div>';
    h += '</div>';
    document.getElementById('main').innerHTML = h;
    return;
  }

  // --- Render extraction event bundles ---
  for (var bi = 0; bi < bundles.length; bi++) {
    var b = bundles[bi];
    var bundleId = 'bundle-' + bi;
    var sourceIcon = b.source_label === 'LinkedIn' ? '\\uD83D\\uDD17' : b.source_label === 'X' ? '\\uD835\\uDD4F' : '\\uD83D\\uDCE5';
    var displayName = b.context_person_name || b.primary.name;

    h += '<div class="rq-bundle expanded" id="' + bundleId + '">';

    // Bundle header — clickable to expand/collapse
    h += '<div class="rq-bundle-header" onclick="toggleBundle(' + "'" + bundleId + "'" + ')">';
    h += '<div class="rq-bundle-icon">' + sourceIcon + '</div>';
    h += '<div class="rq-bundle-info">';
    h += '<div class="rq-bundle-title">' + esc(b.source_label) + ': ' + esc(displayName) + '</div>';
    h += '<div class="rq-bundle-summary">' + b.person_count + ' person' + (b.person_count !== 1 ? 's' : '') + ', ' + b.org_count + ' organization' + (b.org_count !== 1 ? 's' : '') + ' &mdash; ' + b.total_clusters + ' clusters</div>';
    h += '</div>';
    h += '<div class="rq-bundle-meta">';
    h += '<span class="rq-bundle-count">' + b.total_clusters + ' clusters</span>';
    h += '<span class="rq-bundle-chevron">\\u25B6</span>';
    h += '</div>';
    h += '</div>';

    // Bundle body
    h += '<div class="rq-bundle-body">';

    // Primary entity section
    if (b.person_count > 0) {
      h += '<div class="rq-bundle-primary">';
      h += '<div class="rq-bundle-primary-label">Primary Entity</div>';
      var p = b.primary;
      var pIcon = p.entity_type === 'person' ? '\\uD83D\\uDC64' : '\\uD83C\\uDFE2';
      h += '<div style="display:flex;align-items:center;gap:10px;">';
      h += '<div class="rq-entity-icon ' + esc(p.entity_type) + '">' + pIcon + '</div>';
      h += '<div style="flex:1;">';
      h += '<div style="font-size:0.95rem;font-weight:700;color:var(--text-primary);">' + esc(p.name) + ' <span class="type-badge ' + esc(p.entity_type) + '" style="font-size:0.6rem;padding:1px 6px;">' + esc(p.entity_type) + '</span></div>';
      // Show signal summary
      var pSignals = p.signals || {};
      var pHandles = pSignals.handles || {};
      var signalBits = [];
      if (pHandles.linkedin) signalBits.push('LinkedIn');
      if (pHandles.x) signalBits.push('X: @' + pHandles.x);
      var pOrgs = pSignals.organizations || [];
      if (pOrgs.length > 0) signalBits.push(pOrgs.slice(0, 3).join(', '));
      if (signalBits.length > 0) h += '<div style="font-size:0.72rem;color:var(--text-muted);margin-top:2px;">' + esc(signalBits.join(' \\u2022 ')) + '</div>';
      if (p.candidate_entity_name) {
        h += '<div style="font-size:0.72rem;color:#6366f1;margin-top:2px;">\\u2192 Match: ' + esc(p.candidate_entity_name) + ' (' + Math.round((p.confidence || 0) * 100) + '% confidence)</div>';
      }
      h += '</div>';
      h += '<span class="rq-quadrant q' + p.quadrant + '">' + esc(p.quadrant_label) + '</span>';
      h += '</div>';
      h += '</div>';
    }

    // Related entities section
    if (b.related.length > 0) {
      h += '<div class="rq-bundle-related">';
      h += '<div class="rq-bundle-related-label">Related Affiliations (' + b.related.length + ')</div>';
      for (var ri = 0; ri < b.related.length; ri++) {
        var r = b.related[ri];
        var relId = bundleId + '-rel-' + ri;
        h += '<div class="rq-related-item" id="' + relId + '">';
        h += '<input type="checkbox" class="rq-related-check" data-cluster-ids="' + esc(r.all_cluster_ids.join(',')) + '" checked />';
        h += '<div class="rq-related-icon">\\uD83C\\uDFE2</div>';
        h += '<div class="rq-related-info">';
        h += '<div class="rq-related-name">' + esc(r.name);
        if (r.exists_in_graph) h += ' <span class="rq-exists-badge">EXISTS</span>';
        h += '</div>';
        if (r.relationship) {
          h += '<div class="rq-related-role">' + esc(displayName) + ' \\u2192 ' + esc(r.relationship) + '</div>';
        }
        h += '</div>';
        h += '<span class="rq-quadrant q' + r.quadrant + '" style="font-size:0.55rem;">' + esc(r.quadrant_label) + '</span>';
        h += '</div>';
      }
      h += '</div>';
    }

    // Bundle action buttons
    h += '<div class="rq-bundle-actions" id="' + bundleId + '-actions">';
    // Collect all cluster IDs for bundle resolution
    var allBundleIds = b.primary.all_cluster_ids.slice();
    for (var ri = 0; ri < b.related.length; ri++) {
      for (var ci = 0; ci < b.related[ri].all_cluster_ids.length; ci++) {
        allBundleIds.push(b.related[ri].all_cluster_ids[ci]);
      }
    }
    h += '<button class="rq-btn-add-graph" onclick="resolveBundleAction(' + "'" + bundleId + "'" + ',' + "'" + 'add_to_graph' + "'" + ',' + "'" + allBundleIds.join(',') + "'" + ')">\\u2705 Add to Graph</button>';
    h += '<button class="rq-btn-dismiss" onclick="resolveBundleAction(' + "'" + bundleId + "'" + ',' + "'" + 'dismiss' + "'" + ',' + "'" + allBundleIds.join(',') + "'" + ')">Dismiss</button>';
    h += '</div>';

    h += '</div>'; // bundle body
    h += '</div>'; // bundle
  }

  // --- Render standalone clusters (single clusters that arrived alone) ---
  if (standalone.length > 0) {
    if (bundles.length > 0) {
      h += '<div class="rq-group-header" style="margin-top:16px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity:0.5"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg> Individual Clusters <span style="color:var(--text-muted);">(' + standalone.length + ')</span></div>';
    }
    for (var si = 0; si < standalone.length; si++) {
      var c = standalone[si].cluster;
      if (!c) continue;
      var q = c.quadrant || 1;
      var names = (c.signals && c.signals.names) || [];
      var displayNameC = names[0] || c.cluster_id;
      var sourceType = (c.source && c.source.type) || 'unknown';
      var sourceUrl = (c.source && c.source.url) || '';
      var conf = c.confidence || 0;
      var candidateName = c.candidate_entity_name || '';
      var cid = c.cluster_id;
      var entityType = c.entity_type || 'person';
      var entityIcon = entityType === 'person' ? '&#128100;' : '&#127970;';

      var ch = '<div class="rq-card" id="cluster-' + esc(cid) + '">';
      ch += '<div class="rq-card-header">';
      ch += '<div class="rq-entity-icon ' + esc(entityType) + '">' + entityIcon + '</div>';
      ch += '<div class="rq-card-title">';
      ch += '<div class="rq-card-name">' + esc(displayNameC) + ' <span class="type-badge ' + esc(entityType) + '" style="font-size:0.6rem;padding:1px 6px;">' + esc(entityType) + '</span></div>';
      ch += '<div class="rq-card-source">' + esc(getSourceLabel(sourceType));
      if (sourceUrl) ch += ' &mdash; ' + esc(sourceUrl.length > 50 ? sourceUrl.substring(0, 50) + '...' : sourceUrl);
      ch += '</div></div>';
      ch += '<span class="rq-quadrant q' + q + '">Q' + q + ' ' + esc(quadrantLabel(q)) + '</span>';
      ch += '</div>';

      if (conf > 0) {
        var confPct = Math.round(conf * 100);
        var confCls = conf > 0.7 ? 'high' : conf >= 0.4 ? 'mid' : 'low';
        ch += '<div class="rq-conf-bar"><div class="rq-conf-track"><div class="rq-conf-fill ' + confCls + '" style="width:' + confPct + '%"></div></div>';
        ch += '<span class="rq-conf-label">' + confPct + '%</span></div>';
      }

      ch += '<div class="rq-actions cluster-actions">';
      if (q === 1) {
        ch += '<button class="rq-btn-create" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Create New Entity</button>';
        ch += '<button class="rq-btn-hold" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'hold' + "'" + ')">Hold</button>';
      } else if (q === 2) {
        ch += '<button class="rq-btn-merge" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'merge' + "'" + ')">Merge into ' + esc(candidateName) + '</button>';
        ch += '<button class="rq-btn-create" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Create Separate</button>';
      } else if (q === 4) {
        ch += '<button class="rq-btn-source" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'skip' + "'" + ')">Add Source &mdash; Already Captured</button>';
      } else {
        ch += '<button class="rq-btn-create" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'create_new' + "'" + ')">Create Entity</button>';
        ch += '<button class="rq-btn-hold" onclick="resolveQueueCluster(' + "'" + cid + "'" + ',' + "'" + 'hold' + "'" + ')">Hold</button>';
      }
      ch += '</div>';
      ch += '</div>';
      h += ch;
    }
  }

  h += '<div style="margin-top:20px;text-align:center;">';
  h += '<button class="rq-btn-hold" style="padding:10px 24px;" onclick="hideUploadView()">Back to Wiki</button>';
  h += '</div>';
  h += '</div>';
  document.getElementById('main').innerHTML = h;
}

function toggleBundle(bundleId) {
  var el = document.getElementById(bundleId);
  if (el) el.classList.toggle('expanded');
}

function resolveBundleAction(bundleId, action, allIdsStr) {
  var bundleEl = document.getElementById(bundleId);
  var actionsEl = document.getElementById(bundleId + '-actions');

  // Disable buttons
  if (actionsEl) {
    var btns = actionsEl.querySelectorAll('button');
    for (var b = 0; b < btns.length; b++) btns[b].disabled = true;
  }

  // Collect all cluster IDs
  var allIds = allIdsStr.split(',').filter(function(id) { return id.length > 0; });

  // Find excluded IDs (unchecked related entities)
  var excludedIds = [];
  if (bundleEl && action === 'add_to_graph') {
    var checkboxes = bundleEl.querySelectorAll('.rq-related-check');
    for (var ci = 0; ci < checkboxes.length; ci++) {
      if (!checkboxes[ci].checked) {
        var ids = (checkboxes[ci].getAttribute('data-cluster-ids') || '').split(',');
        for (var ei = 0; ei < ids.length; ei++) {
          if (ids[ei]) excludedIds.push(ids[ei]);
        }
      }
    }
  }

  api('POST', '/api/resolve-bundle', {
    cluster_ids: allIds,
    action: action,
    excluded_cluster_ids: excludedIds
  }).then(function(result) {
    if (result.errors && result.errors.length > 0) {
      toast('Bundle resolved with ' + result.errors.length + ' error(s)');
    } else {
      toast(action === 'add_to_graph' ? 'Added to graph (' + result.resolved.length + ' entities)' : 'Bundle dismissed');
    }

    // Fade out the bundle
    if (bundleEl) {
      bundleEl.style.opacity = '0.3';
      bundleEl.style.pointerEvents = 'none';
      if (actionsEl) {
        if (action === 'add_to_graph') {
          var names = result.resolved.map(function(r) { return r.entity_name || r.entity_id; }).join(', ');
          actionsEl.innerHTML = '<span style="color:#15803d;font-weight:600;">\\u2705 Added to graph: ' + esc(names) + '</span>';
        } else {
          actionsEl.innerHTML = '<span style="color:var(--text-muted);font-weight:600;">Dismissed</span>';
        }
      }
    }

    refreshReviewQueueBadge();
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  }).catch(function(err) {
    toast('Bundle resolution failed: ' + (err.message || 'Unknown error'));
    if (actionsEl) {
      var btns = actionsEl.querySelectorAll('button');
      for (var b = 0; b < btns.length; b++) btns[b].disabled = false;
    }
  });
}

function resolveQueueCluster(clusterId, action) {
  var card = document.getElementById('cluster-' + clusterId);
  if (card) {
    var btns = card.querySelectorAll('button');
    for (var b = 0; b < btns.length; b++) btns[b].disabled = true;
  }

  api('POST', '/api/clusters/resolve', { cluster_id: clusterId, action: action }).then(function(result) {
    if (result.error) {
      toast('Error: ' + result.error);
      if (card) { var btns = card.querySelectorAll('button'); for (var b = 0; b < btns.length; b++) btns[b].disabled = false; }
      return;
    }

    // IDENTITY conflict blocked — show evidence panel with confirm/cancel
    if (result.action === 'conflict_blocked') {
      if (card) {
        var actionsDiv = card.querySelector('.cluster-actions');
        if (actionsDiv) {
          var evHtml = '<div style="background:rgba(168,85,247,0.06);border:1px solid rgba(168,85,247,0.2);border-radius:8px;padding:10px;margin-bottom:8px;">';
          evHtml += '<div style="font-size:0.78rem;font-weight:700;color:#a855f7;margin-bottom:6px;">\\u26A0 These might be different people</div>';
          var ev = result.evidence || [];
          for (var ei = 0; ei < ev.length; ei++) {
            evHtml += '<div style="font-size:0.72rem;margin-bottom:3px;"><strong>' + esc(ev[ei].attribute) + ':</strong> ' + esc(ev[ei].existing_value) + ' vs ' + esc(ev[ei].incoming_value) + '</div>';
          }
          evHtml += '</div>';
          evHtml += '<button class="rq-btn-merge" onclick="resolveQueueCluster(' + "'" + esc(clusterId) + "'" + ',' + "'" + 'confirm_merge' + "'" + ')" style="margin-right:6px;">Yes, same person \\u2014 merge anyway</button>';
          evHtml += '<button class="rq-btn-create" onclick="resolveQueueCluster(' + "'" + esc(clusterId) + "'" + ',' + "'" + 'create_new' + "'" + ')">Different person \\u2014 create new</button>';
          actionsDiv.innerHTML = evHtml;
        }
        var btns = card.querySelectorAll('button'); for (var b = 0; b < btns.length; b++) btns[b].disabled = false;
      }
      toast('Identity conflict detected — review evidence');
      return;
    }

    // Remove the resolved card with a fade
    if (card) {
      card.style.opacity = '0.4';
      card.style.pointerEvents = 'none';
      var actionsDiv = card.querySelector('.cluster-actions');
      if (actionsDiv) {
        if (action === 'merge' || action === 'confirm_merge') actionsDiv.innerHTML = '<span style="color:#15803d;font-weight:600;">Merged into ' + esc(result.entity_name || result.entity_id) + '</span>';
        else if (action === 'create_new') actionsDiv.innerHTML = '<span style="color:#1d4ed8;font-weight:600;">Created ' + esc(result.entity_id) + '</span>';
        else if (action === 'skip') actionsDiv.innerHTML = '<span style="color:#6b21a8;font-weight:600;">Source added to ' + esc(result.entity_id) + '</span>';
        else if (action === 'hold') actionsDiv.innerHTML = '<span style="color:#92400e;font-weight:600;">Held for later</span>';
      }
    }

    toast(action === 'merge' || action === 'confirm_merge' ? 'Merged into ' + (result.entity_name || result.entity_id)
      : action === 'create_new' ? 'Created ' + result.entity_id
      : action === 'skip' ? 'Source added'
      : 'Held for later');

    refreshReviewQueueBadge();

    // Refresh sidebar
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  }).catch(function(err) {
    toast('Resolution failed: ' + (err.message || 'Unknown error'));
    if (card) { var btns = card.querySelectorAll('button'); for (var b = 0; b < btns.length; b++) btns[b].disabled = false; }
  });
}

function resolveEntityConflict(entityId, conflictId, resolution) {
  api('POST', '/api/conflicts/resolve', { entity_id: entityId, conflict_id: conflictId, resolution: resolution }).then(function(result) {
    if (result.error) { toast('Error: ' + result.error); return; }
    toast('Conflict resolved: ' + resolution.replace('_', ' '));
    // Reload entity detail to reflect changes
    selectEntity(entityId);
  }).catch(function(err) {
    toast('Failed: ' + (err.message || 'Unknown error'));
  });
}

/* --- LinkedIn Card Profile: support functions --- */

function switchLiTab(tabId, entityId) {
  window._liActiveTab = tabId;
  if (selectedData) {
    renderDetail(selectedData);
  } else if (entityId) {
    api('GET', '/api/entity/' + entityId).then(function(data) {
      selectedData = data;
      renderDetail(data);
    });
  }
}

function toggleCardEdit(cardId, entityId) {
  var card = document.getElementById('li-card-' + cardId);
  var display = document.getElementById('li-display-' + cardId);
  var edit = document.getElementById('li-edit-' + cardId);
  if (!card) return;
  if (edit && edit.style.display === 'none') {
    // Enter edit mode
    if (display) display.style.display = 'none';
    edit.style.display = '';
    card.classList.add('editing');
  } else {
    // Exit edit mode
    if (display) display.style.display = '';
    if (edit) edit.style.display = 'none';
    card.classList.remove('editing');
  }
}

function toggleCardCollapse(cardId) {
  var card = document.getElementById(cardId);
  if (!card) return;
  card.classList.toggle('li-collapsed');
  var body = document.getElementById(cardId + '-body');
  if (body) body.style.display = card.classList.contains('li-collapsed') ? 'none' : '';
}

function saveCardEdit(cardId, entityId) {
  var payload = {};

  if (cardId === 'hero') {
    var newName = (document.getElementById('li-edit-name') || {}).value || '';
    var newHeadline = (document.getElementById('li-edit-headline') || {}).value || '';
    var newLocation = (document.getElementById('li-edit-location') || {}).value || '';
    var newLinkedin = (document.getElementById('li-edit-linkedin') || {}).value || '';
    var newXHandle = (document.getElementById('li-edit-xhandle') || {}).value || '';
    payload.entity = { name: { full: newName } };
    payload.career_lite = { headline: newHeadline, location: newLocation, linkedin_url: newLinkedin };
    // Update attributes
    payload.attributes_update = [];
    if (newHeadline) payload.attributes_update.push({ key: 'headline', value: newHeadline });
    if (newLocation) payload.attributes_update.push({ key: 'location', value: newLocation });
    if (newLinkedin) payload.attributes_update.push({ key: 'linkedin_url', value: newLinkedin });
    if (newXHandle) payload.attributes_update.push({ key: 'x_handle', value: newXHandle });
  }

  if (cardId === 'about') {
    var newSummary = (document.getElementById('li-edit-summary') || {}).value || '';
    payload.entity = { summary: { value: newSummary } };
    // Collect remaining skill pills
    var pillEls = document.querySelectorAll('#li-edit-skills .li-skill-pill');
    var newSkills = [];
    for (var i = 0; i < pillEls.length; i++) {
      var text = pillEls[i].textContent.replace(/\\u00d7/g, '').trim();
      if (text) newSkills.push(text);
    }
    payload.career_lite = { skills: newSkills };
  }

  if (cardId === 'experience') {
    var expRows = document.querySelectorAll('#li-edit-experience [data-exp-idx]');
    var newExperience = [];
    for (var i = 0; i < expRows.length; i++) {
      var row = expRows[i];
      var entry = {};
      var fields = row.querySelectorAll('[data-field]');
      for (var j = 0; j < fields.length; j++) {
        entry[fields[j].getAttribute('data-field')] = fields[j].value || '';
      }
      newExperience.push(entry);
    }
    payload.career_lite = { experience: newExperience };
  }

  if (cardId === 'education') {
    var eduRows = document.querySelectorAll('#li-edit-education [data-edu-idx]');
    var newEducation = [];
    for (var i = 0; i < eduRows.length; i++) {
      var row = eduRows[i];
      var entry = {};
      var fields = row.querySelectorAll('[data-field]');
      for (var j = 0; j < fields.length; j++) {
        entry[fields[j].getAttribute('data-field')] = fields[j].value || '';
      }
      newEducation.push(entry);
    }
    payload.career_lite = { education: newEducation };
  }

  api('PUT', '/api/entity/' + entityId, payload).then(function(result) {
    if (result.error) { toast('Error: ' + result.error); return; }
    toast('Updated successfully');
    // Reload entity
    api('GET', '/api/entity/' + entityId).then(function(data) {
      selectedData = data;
      if (entityId === primaryEntityId) primaryEntityData = data;
      renderDetail(data);
    });
  }).catch(function(err) {
    toast('Save failed: ' + (err.message || 'Unknown error'));
  });
}

function saveNewObservation(entityId) {
  var text = (document.getElementById('li-obs-new-text') || {}).value || '';
  var source = (document.getElementById('li-obs-source') || {}).value || 'user_input';
  if (!text.trim()) { toast('Enter observation text'); return; }
  api('POST', '/api/observe', {
    entity_id: entityId,
    observation: text,
    source: source,
    confidence_label: 'STRONG',
    facts_layer: 'L2_GROUP'
  }).then(function(result) {
    if (result.error) { toast('Error: ' + result.error); return; }
    toast('Observation added');
    selectEntity(entityId);
  }).catch(function(err) {
    toast('Failed: ' + (err.message || 'Unknown error'));
  });
}

function addSkillPill() {
  var skill = prompt('Enter skill name:');
  if (!skill || !skill.trim()) return;
  var container = document.getElementById('li-edit-skills');
  if (!container) return;
  var addBtn = container.querySelector('.li-pill-add');
  var pill = document.createElement('span');
  pill.className = 'li-skill-pill';
  pill.innerHTML = esc(skill.trim()) + '<button class="li-pill-remove" onclick="this.parentElement.remove()">&times;</button>';
  container.insertBefore(pill, addBtn);
}

function addExperienceEntry() {
  var container = document.getElementById('li-edit-experience');
  if (!container) return;
  var addBtn = container.querySelector('.li-add-entry');
  var idx = container.querySelectorAll('[data-exp-idx]').length;
  var div = document.createElement('div');
  div.className = 'li-exp-item';
  div.style.cssText = 'flex-direction:column;gap:8px;';
  div.setAttribute('data-exp-idx', idx);
  div.innerHTML = '<div class="li-edit-row"><label>Title</label><input class="li-edit-field" data-field="title" value="" /></div>' +
    '<div class="li-edit-row"><label>Company</label><input class="li-edit-field" data-field="company" value="" /></div>' +
    '<div class="li-edit-row"><label>Start</label><input class="li-edit-field" data-field="start_date" value="" /><label style="min-width:40px;">End</label><input class="li-edit-field" data-field="end_date" value="" /></div>' +
    '<div class="li-edit-row"><label>Location</label><input class="li-edit-field" data-field="location" value="" /></div>' +
    '<div class="li-edit-row"><label>Desc</label><textarea class="li-edit-textarea" data-field="description" style="min-height:50px;"></textarea></div>';
  container.insertBefore(div, addBtn);
}

function addEducationEntry() {
  var container = document.getElementById('li-edit-education');
  if (!container) return;
  var addBtn = container.querySelector('.li-add-entry');
  var idx = container.querySelectorAll('[data-edu-idx]').length;
  var div = document.createElement('div');
  div.className = 'li-edu-item';
  div.style.cssText = 'flex-direction:column;gap:8px;';
  div.setAttribute('data-edu-idx', idx);
  div.innerHTML = '<div class="li-edit-row"><label>School</label><input class="li-edit-field" data-field="institution" value="" /></div>' +
    '<div class="li-edit-row"><label>Degree</label><input class="li-edit-field" data-field="degree" value="" /></div>' +
    '<div class="li-edit-row"><label>Field</label><input class="li-edit-field" data-field="field" value="" /></div>' +
    '<div class="li-edit-row"><label>Start</label><input class="li-edit-field" data-field="start_year" value="" /><label style="min-width:40px;">End</label><input class="li-edit-field" data-field="end_year" value="" /></div>';
  container.insertBefore(div, addBtn);
}

function showAllSkills() {
  if (!selectedData || !selectedData.career_lite) return;
  var skills = selectedData.career_lite.skills || [];
  var container = document.querySelector('.li-skill-pills');
  if (!container) return;
  container.innerHTML = '<span class="li-skill-label">Skills:</span>';
  for (var i = 0; i < skills.length; i++) {
    container.innerHTML += '<span class="li-skill-pill">' + esc(skills[i]) + '</span>';
  }
}

function showAllObservations() {
  if (!selectedData) return;
  var obs = (selectedData.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var container = document.getElementById('li-display-activity');
  if (!container) return;
  var h = '';
  for (var i = 0; i < obs.length; i++) {
    var o = obs[i];
    h += '<div class="li-obs-item">';
    h += '<div class="li-obs-source"><div class="li-obs-source-icon">' + esc(getSourceLabel(o.source || '').slice(0, 2).toUpperCase()) + '</div> ' + esc(getSourceLabel(o.source || '')) + '</div>';
    h += '<div class="li-obs-text" style="-webkit-line-clamp:unset;overflow:visible;">' + esc(o.observation || '') + '</div>';
    h += '<div class="li-obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</div>';
    h += '</div>';
  }
  container.innerHTML = h;
}

function filterConnections(query) {
  var q = (query || '').toLowerCase().trim();
  var cards = document.querySelectorAll('.conn-grid-card');
  for (var i = 0; i < cards.length; i++) {
    var name = cards[i].getAttribute('data-conn-name') || '';
    if (!q || name.indexOf(q) !== -1) {
      // Show unless it's an overflow card that hasn't been expanded
      var overflow = cards[i].getAttribute('data-conn-overflow');
      if (!overflow || cards[i].getAttribute('data-expanded') === 'true' || q) {
        cards[i].style.display = '';
      }
    } else {
      cards[i].style.display = 'none';
    }
  }
  // Hide/show tier sections based on whether they have visible cards
  var sections = document.querySelectorAll('.conn-tier-section');
  for (var s = 0; s < sections.length; s++) {
    var visibleCards = sections[s].querySelectorAll('.conn-grid-card:not([style*="display: none"])');
    sections[s].style.display = visibleCards.length > 0 || !q ? '' : 'none';
  }
}

function showAllTierConnections(tierId, sectionId) {
  var section = document.getElementById(sectionId);
  if (!section) return;
  var hidden = section.querySelectorAll('.conn-grid-card[data-conn-overflow="' + sectionId + '"]');
  for (var i = 0; i < hidden.length; i++) {
    hidden[i].style.display = '';
    hidden[i].setAttribute('data-expanded', 'true');
  }
  // Hide the "Show all" link
  var showMore = document.getElementById('show-more-' + tierId);
  if (showMore) showMore.style.display = 'none';
}

function showConnectionsPage(entityId) {
  if (!selectedData) return;
  var data = selectedData;
  var rels = data.relationships || [];
  var name = '';
  if (data.entity && data.entity.name) {
    name = data.entity.name.full || data.entity.name.common || data.entity.name.legal || '';
  }

  var tierDefs = {
    5: { label: 'Family', color: '#ef4444' },
    4: { label: 'Close Friends', color: '#22c55e' },
    3: { label: 'Friends', color: '#3b82f6' },
    2: { label: 'Colleagues', color: '#6b7280' },
    1: { label: 'Following', color: '#9ca3af' }
  };
  var tierBuckets = { 5: [], 4: [], 3: [], 2: [], 1: [] };
  for (var i = 0; i < rels.length; i++) {
    var tier = classifyRelTier(rels[i]);
    tierBuckets[tier].push(rels[i]);
  }

  // Update breadcrumbs
  breadcrumbs = [
    { label: name || entityId, action: 'selectEntity(\\'' + esc(entityId) + '\\')' },
    { label: 'All Connections' }
  ];

  var h = '<div class="detail-container" style="max-width:900px;">';
  h += '<div class="conn-grid-header" style="margin-bottom:12px;">';
  h += '<h2 style="margin:0;">All Connections (' + rels.length + ')</h2>';
  h += '<div class="conn-grid-search"><input type="text" placeholder="Search connections..." oninput="filterConnections(this.value)" /></div>';
  h += '</div>';

  // Summary line
  h += '<div class="conn-grid-summary" style="margin-bottom:16px;">';
  var tierOrder = [5, 4, 3, 2, 1];
  for (var t = 0; t < tierOrder.length; t++) {
    var tid = tierOrder[t];
    var td = tierDefs[tid];
    if (tierBuckets[tid].length === 0) continue;
    if (t > 0 && tierBuckets[tierOrder[t-1]].length > 0) h += '<span style="color:var(--text-muted);"> &middot; </span>';
    h += '<span class="conn-grid-summary-item"><span class="conn-grid-summary-dot" style="background:' + td.color + ';"></span> ' + tierBuckets[tid].length + ' ' + td.label + '</span>';
  }
  h += '</div>';

  // Tier filter buttons
  h += '<div style="display:flex;gap:6px;margin-bottom:16px;flex-wrap:wrap;">';
  h += '<button class="btn-sm" style="background:var(--accent);color:#fff;" onclick="filterConnectionsByTier(0)">All</button>';
  for (var t = 0; t < tierOrder.length; t++) {
    var tid = tierOrder[t];
    if (tierBuckets[tid].length === 0) continue;
    var td = tierDefs[tid];
    h += '<button class="btn-sm" style="border:1px solid ' + td.color + ';color:' + td.color + ';" onclick="filterConnectionsByTier(' + tid + ')">' + td.label + ' (' + tierBuckets[tid].length + ')</button>';
  }
  h += '</div>';

  // All tiers — NO truncation on the full connections page
  for (var t = 0; t < tierOrder.length; t++) {
    var tid = tierOrder[t];
    var bucket = tierBuckets[tid];
    if (bucket.length === 0) continue;
    var td = tierDefs[tid];
    var sectionId = 'conn-full-tier-' + tid;

    h += '<div class="conn-tier-section" data-tier="' + tid + '" id="' + sectionId + '">';
    h += '<div class="conn-tier-label" style="color:' + td.color + ';border-bottom-color:' + td.color + ';">' + td.label + ' (' + bucket.length + ')</div>';

    h += '<div class="conn-grid">';
    for (var j = 0; j < bucket.length; j++) {
      var r = bucket[j];
      var rName = r.name || '';
      var rInit = rName.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
      var hasEntity = !!r.target_entity_id;
      var existsInGraph = hasEntity;
      if (!hasEntity) {
        for (var k = 0; k < allEntities.length; k++) {
          if (allEntities[k].name && allEntities[k].name.toLowerCase() === rName.toLowerCase()) {
            existsInGraph = true;
            r._matched_entity_id = allEntities[k].entity_id;
            break;
          }
        }
      }
      var clickable = hasEntity || r._matched_entity_id;
      var clickId = r.target_entity_id || r._matched_entity_id || '';
      var desc = (r.context || r.relationship_type || '').substring(0, 60);

      h += '<div class="conn-grid-card conn-item' + (clickable ? ' clickable' : '') + '"' + (clickable ? ' onclick="selectEntity(\\'' + esc(clickId) + '\\')"' : '') + ' data-conn-name="' + esc(rName.toLowerCase()) + '" data-conn-tier="' + tid + '">';
      h += '<div class="conn-grid-avatar' + (existsInGraph ? ' in-graph' : '') + '">' + esc(rInit) + '</div>';
      h += '<div class="conn-grid-info">';
      h += '<div class="conn-grid-name">' + esc(rName) + '</div>';
      if (desc) h += '<div class="conn-grid-desc">' + esc(desc) + '</div>';
      h += '</div>';
      h += '<span class="conn-grid-tier" style="background:' + td.color + ';">T' + tid + '</span>';
      h += '</div>';
    }
    h += '</div>';
    h += '</div>';
  }
  h += '</div>';

  document.getElementById('detail').innerHTML = h;
  renderBreadcrumbs();
}

function filterConnectionsByTier(tierId) {
  var sections = document.querySelectorAll('.conn-tier-section[data-tier]');
  for (var i = 0; i < sections.length; i++) {
    if (tierId === 0) {
      sections[i].style.display = '';
    } else {
      sections[i].style.display = sections[i].getAttribute('data-tier') == tierId ? '' : 'none';
    }
  }
}

function uploadComplete() {
  uploadInProgress = false;
  if (previewEntities.length > 0) {
    // Preview mode — show checklist
    renderPreviewChecklist();
    return;
  }
  var btn = document.getElementById('btnStartUpload');
  btn.textContent = 'Done — View Entities';
  btn.disabled = false;
  btn.onclick = function() {
    hideUploadView();
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  };
  // Also refresh sidebar entity list
  api('GET', '/api/search?q=*').then(function(data) {
    allEntities = data.results || [];
    entities = allEntities.slice();
    renderSidebar();
  });
}

/* --- Google Drive Picker --- */
var driveBreadcrumb = [{ id: null, name: 'My Drive' }];
var driveFiles = [];
var driveSelected = {};
var driveIngesting = false;
var driveSearchMode = false;
var driveSearchQuery = '';
var driveFilterTimeout = null;

function showDriveView() {
  selectedId = null;
  selectedView = null;
  driveBreadcrumb = [{ id: null, name: 'My Drive' }];
  driveFiles = [];
  driveSelected = {};
  driveIngesting = false;
  driveSearchMode = false;
  driveSearchQuery = '';
  renderDrivePanel();
  loadDriveFolder(null);
  var items = document.querySelectorAll('.entity-item');
  for (var i = 0; i < items.length; i++) items[i].classList.remove('active');
}

function renderDrivePanel() {
  var h = '<h2 style="font-size:1.2rem;font-weight:700;color:var(--text-primary);margin-bottom:16px;">Import from Google Drive</h2>';

  // Search bar
  h += '<div class="drive-search-bar">';
  h += '<input type="text" id="driveSearchInput" placeholder="Type to filter, press Enter to search all of Drive" value="' + esc(driveSearchQuery) + '" oninput="onDriveFilter()" onkeydown="if(event.key===' + "'" + 'Enter' + "'" + ')driveFullSearch()" />';
  if (driveSearchMode) {
    h += '<button class="drive-search-clear" onclick="clearDriveSearch()">Clear</button>';
  } else {
    h += '<button class="drive-search-btn" onclick="driveFullSearch()">Search</button>';
  }
  h += '</div>';

  if (driveSearchMode) {
    // Search results mode — show tag instead of breadcrumb
    h += '<div class="drive-search-tag">Search results for &ldquo;' + esc(driveSearchQuery) + '&rdquo;</div>';
  } else {
    // Breadcrumb
    h += '<div class="drive-breadcrumb">';
    for (var i = 0; i < driveBreadcrumb.length; i++) {
      if (i > 0) h += '<span class="sep">&rsaquo;</span>';
      if (i < driveBreadcrumb.length - 1) {
        h += '<a onclick="navigateDrive(' + i + ')">' + esc(driveBreadcrumb[i].name) + '</a>';
      } else {
        h += '<span class="current">' + esc(driveBreadcrumb[i].name) + '</span>';
      }
    }
    h += '</div>';
  }

  // Loading or file list
  h += '<div id="driveFileArea"><div class="drive-loading">Loading...</div></div>';

  // Progress log (hidden until ingest starts)
  h += '<div id="driveProgressLog" class="upload-progress-log" style="display:none;"></div>';
  h += '<div id="driveSummary" style="display:none;"></div>';

  // Action bar
  h += '<div id="driveActionBar">';
  var selCount = Object.keys(driveSelected).length;
  h += '<button class="btn-start-upload" id="btnDriveImport" onclick="startDriveIngest()" style="display:' + (selCount > 0 ? 'block' : 'none') + ';">Import ' + selCount + ' file' + (selCount !== 1 ? 's' : '') + '</button>';
  h += '<button class="btn-back-upload" onclick="hideUploadView()">Back to Entities</button>';
  h += '</div>';

  document.getElementById('main').innerHTML = h;
}

function onDriveFilter() {
  clearTimeout(driveFilterTimeout);
  driveFilterTimeout = setTimeout(function() {
    var input = document.getElementById('driveSearchInput');
    var q = input ? input.value.trim().toLowerCase() : '';
    if (driveSearchMode || !q) {
      renderDriveFiles();
      return;
    }
    // Local filter: re-render with filter applied
    renderDriveFiles(q);
  }, 150);
}

function driveFullSearch() {
  var input = document.getElementById('driveSearchInput');
  var q = input ? input.value.trim() : '';
  if (!q) return;
  driveSearchQuery = q;
  driveSearchMode = true;
  driveSelected = {};
  renderDrivePanel();
  // API search
  var area = document.getElementById('driveFileArea');
  if (area) area.innerHTML = '<div class="drive-loading">Searching Drive...</div>';
  api('GET', '/api/drive/files?q=' + encodeURIComponent(q)).then(function(data) {
    driveFiles = data.files || [];
    renderDriveFiles();
  }).catch(function(err) {
    if (area) area.innerHTML = '<div class="drive-empty" style="color:#ef4444;">Search error: ' + esc(err.message) + '</div>';
  });
}

function clearDriveSearch() {
  driveSearchMode = false;
  driveSearchQuery = '';
  driveSelected = {};
  var folderId = driveBreadcrumb[driveBreadcrumb.length - 1].id;
  renderDrivePanel();
  loadDriveFolder(folderId);
}

function loadDriveFolder(folderId) {
  var area = document.getElementById('driveFileArea');
  if (area) area.innerHTML = '<div class="drive-loading">Loading...</div>';

  var url = '/api/drive/files';
  if (folderId) url += '?folderId=' + encodeURIComponent(folderId);

  api('GET', url).then(function(data) {
    driveFiles = data.files || [];
    renderDriveFiles();
  }).catch(function(err) {
    if (area) area.innerHTML = '<div class="drive-empty" style="color:#ef4444;">Error: ' + esc(err.message) + '</div>';
  });
}

function renderDriveFiles(localFilter) {
  var area = document.getElementById('driveFileArea');
  if (!area) return;

  var filtered = driveFiles;
  if (localFilter) {
    filtered = driveFiles.filter(function(f) {
      return f.name.toLowerCase().indexOf(localFilter) !== -1;
    });
  }

  if (filtered.length === 0) {
    area.innerHTML = '<div class="drive-empty">' + (localFilter ? 'No files match &ldquo;' + esc(localFilter) + '&rdquo;' : 'No supported files in this folder') + '</div>';
    updateDriveActionBar();
    return;
  }

  var h = '<div class="drive-file-list">';
  for (var i = 0; i < filtered.length; i++) {
    var f = filtered[i];
    if (f.isFolder) {
      var fChecked = driveSelected[f.id] ? ' checked' : '';
      var fSelCls = driveSelected[f.id] ? ' selected' : '';
      h += '<div class="drive-file-row' + fSelCls + '">';
      h += '<input type="checkbox" class="drive-file-check"' + fChecked + ' onclick="event.stopPropagation(); toggleDriveFile(' + "'" + esc(f.id) + "'" + ', ' + "'" + esc(f.name).replace(/'/g, "\\\\'") + "'" + ')" />';
      h += '<div class="drive-file-icon" onclick="openDriveFolder(' + "'" + esc(f.id) + "'" + ', ' + "'" + esc(f.name).replace(/'/g, "\\\\'") + "'" + ')" style="cursor:pointer;">\\ud83d\\udcc1</div>';
      h += '<div class="drive-file-name folder" onclick="openDriveFolder(' + "'" + esc(f.id) + "'" + ', ' + "'" + esc(f.name).replace(/'/g, "\\\\'") + "'" + ')" style="cursor:pointer;">' + esc(f.name) + '</div>';
      h += '<div class="drive-file-meta">' + formatDriveDate(f.modifiedTime) + '</div>';
      h += '</div>';
    } else {
      var checked = driveSelected[f.id] ? ' checked' : '';
      var selCls = driveSelected[f.id] ? ' selected' : '';
      h += '<div class="drive-file-row' + selCls + '" onclick="toggleDriveFile(' + "'" + esc(f.id) + "'" + ', ' + "'" + esc(f.name).replace(/'/g, "\\\\'") + "'" + ')">';
      h += '<input type="checkbox" class="drive-file-check"' + checked + ' onclick="event.stopPropagation(); toggleDriveFile(' + "'" + esc(f.id) + "'" + ', ' + "'" + esc(f.name).replace(/'/g, "\\\\'") + "'" + ')" />';
      h += '<div class="drive-file-icon">' + driveFileIcon(f.mimeType, f.isGoogleNative) + '</div>';
      h += '<div class="drive-file-name">' + esc(f.name) + (f.isGoogleNative ? ' <span style="font-size:0.65rem;color:#4b5563;">(Google)</span>' : '') + '</div>';
      h += '<div class="drive-file-meta">' + (f.size ? formatFileSize(f.size) : '') + '</div>';
      h += '<div class="drive-file-meta">' + formatDriveDate(f.modifiedTime) + '</div>';
      h += '</div>';
    }
  }
  h += '</div>';
  area.innerHTML = h;
  updateDriveActionBar();
}

function driveFileIcon(mimeType, isGoogleNative) {
  if (mimeType === 'application/pdf') return '\\ud83d\\udcc4';
  if (mimeType.includes('spreadsheet') || mimeType.includes('excel') || mimeType === 'text/csv') return '\\ud83d\\udcca';
  if (mimeType.includes('document') || mimeType.includes('wordprocessing')) return '\\ud83d\\udcdd';
  if (mimeType === 'text/plain' || mimeType === 'text/markdown') return '\\ud83d\\udcc3';
  if (mimeType === 'application/json') return '{ }';
  return '\\ud83d\\udcc4';
}

function formatDriveDate(iso) {
  if (!iso) return '';
  return iso.slice(0, 10);
}

function openDriveFolder(id, name) {
  driveBreadcrumb.push({ id: id, name: name });
  driveSelected = {};
  renderDrivePanel();
  loadDriveFolder(id);
}

function navigateDrive(index) {
  driveBreadcrumb = driveBreadcrumb.slice(0, index + 1);
  driveSelected = {};
  var folderId = driveBreadcrumb[driveBreadcrumb.length - 1].id;
  renderDrivePanel();
  loadDriveFolder(folderId);
}

function toggleDriveFile(fileId, fileName) {
  if (driveSelected[fileId]) {
    delete driveSelected[fileId];
  } else {
    driveSelected[fileId] = fileName;
  }
  renderDriveFiles();
}

function updateDriveActionBar() {
  var btn = document.getElementById('btnDriveImport');
  if (!btn) return;
  var selCount = Object.keys(driveSelected).length;
  btn.style.display = selCount > 0 ? 'block' : 'none';
  btn.textContent = 'Import ' + selCount + ' file' + (selCount !== 1 ? 's' : '');
}

function startDriveIngest() {
  var ids = Object.keys(driveSelected);
  if (ids.length === 0 || driveIngesting) return;
  driveIngesting = true;

  var btn = document.getElementById('btnDriveImport');
  btn.disabled = true;
  btn.textContent = 'Importing...';

  var log = document.getElementById('driveProgressLog');
  log.style.display = 'block';
  log.innerHTML = '<div class="log-info">Starting import of ' + ids.length + ' file' + (ids.length > 1 ? 's' : '') + ' from Drive...</div>';

  var headers = getAuthHeaders();
  headers['Content-Type'] = 'application/json';
  headers['X-Agent-Id'] = 'wiki-drive';

  fetch('/api/drive/ingest', {
    method: 'POST',
    headers: headers,
    body: JSON.stringify({ fileIds: ids }),
  }).then(function(response) {
    if (!response.ok) {
      return response.json().then(function(e) {
        throw new Error(e.error || 'Import failed (' + response.status + ')');
      });
    }
    var reader = response.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';

    function read() {
      return reader.read().then(function(result) {
        if (result.done) {
          driveIngestComplete();
          return;
        }
        buffer += decoder.decode(result.value, { stream: true });
        var lines = buffer.split('\\n');
        buffer = lines.pop();
        for (var i = 0; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          try {
            var evt = JSON.parse(lines[i]);
            handleDriveEvent(evt);
          } catch (e) {}
        }
        return read();
      });
    }
    return read();
  }).catch(function(err) {
    log.innerHTML += '<div class="log-error">Error: ' + esc(err.message) + '</div>';
    log.scrollTop = log.scrollHeight;
    driveIngesting = false;
    btn.disabled = false;
    btn.textContent = 'Retry Import';
  });
}

function handleDriveEvent(evt) {
  var log = document.getElementById('driveProgressLog');
  if (evt.type === 'started') {
    log.innerHTML += '<div class="log-info">Processing ' + evt.total_files + ' file' + (evt.total_files > 1 ? 's' : '') + '...</div>';
  } else if (evt.type === 'file_downloading') {
    log.innerHTML += '<div class="log-info">Downloading file ' + evt.file_index + '...</div>';
  } else if (evt.type === 'file_progress') {
    if (evt.warning) {
      log.innerHTML += '<div class="log-error">' + esc(evt.file) + ' — ' + esc(evt.warning) + '</div>';
    } else {
      log.innerHTML += '<div class="log-success">' + esc(evt.file) + ' — ' + evt.entities_created + ' created, ' + evt.entities_updated + ' updated</div>';
    }
  } else if (evt.type === 'file_error') {
    log.innerHTML += '<div class="log-error">' + esc(evt.file) + ' — ' + esc(evt.error) + '</div>';
  } else if (evt.type === 'complete') {
    var s = evt.summary || {};
    var sumEl = document.getElementById('driveSummary');
    sumEl.style.display = 'block';
    sumEl.innerHTML = '<div class="upload-summary">' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.files_processed || 0) + '</div><div class="upload-summary-label">Files</div></div>' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.entities_created || 0) + '</div><div class="upload-summary-label">Created</div></div>' +
      '<div class="upload-summary-stat"><div class="upload-summary-num">' + (s.entities_updated || 0) + '</div><div class="upload-summary-label">Merged</div></div>' +
      '</div>';
  }
  log.scrollTop = log.scrollHeight;
}

function driveIngestComplete() {
  driveIngesting = false;
  var btn = document.getElementById('btnDriveImport');
  btn.textContent = 'Done — View Entities';
  btn.disabled = false;
  btn.onclick = function() {
    hideUploadView();
    api('GET', '/api/search?q=*').then(function(data) {
      allEntities = data.results || [];
      entities = allEntities.slice();
      renderSidebar();
    });
  };
  api('GET', '/api/search?q=*').then(function(data) {
    allEntities = data.results || [];
    entities = allEntities.slice();
    renderSidebar();
  });
}

function renderCareerLite(data) {
  var e = data.entity || {};
  var cl = data.career_lite || {};
  var name = e.name?.full || '';
  var initials = name.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
  var entityId = e.entity_id || '';
  var health = computeEntityHealth(data);
  var h = '';

  // Hero Card
  h += '<div class="hero-card">';
  h += '<div class="hero-top">';
  h += '<div class="hero-avatar">' + esc(initials) + '</div>';
  h += '<div class="hero-info">';
  h += '<div class="hero-name-row">';
  h += '<span class="hero-name">' + esc(name) + '</span>';
  h += '<span class="entity-id-badge">' + esc(entityId) + '</span>';
  h += '</div>';
  if (cl.headline) h += '<div class="hero-headline">' + esc(cl.headline) + '</div>';
  var currentTitle = cl.current_title || cl.current_role || '';
  var currentCompany = cl.current_company || '';
  if (currentTitle && currentCompany) {
    h += '<div class="hero-current">' + esc(currentTitle) + ' at ' + esc(currentCompany) + '</div>';
  } else if (currentTitle || currentCompany) {
    h += '<div class="hero-current">' + esc(currentTitle || currentCompany) + '</div>';
  }
  if (cl.location) h += '<div class="hero-location"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg> ' + esc(cl.location) + '</div>';

  // Contact row
  h += '<div class="hero-contact-row">';
  var attrs = data.attributes || [];
  for (var i = 0; i < attrs.length; i++) {
    if (attrs[i].key === 'email' && attrs[i].value) {
      h += '<span class="hero-contact-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M22 7l-10 7L2 7"/></svg> ' + esc(attrs[i].value) + '</span>';
    }
    if (attrs[i].key === 'phone' && attrs[i].value) {
      h += '<span class="hero-contact-item"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 01-2.18 2 19.79 19.79 0 01-8.63-3.07 19.5 19.5 0 01-6-6 19.79 19.79 0 01-3.07-8.67A2 2 0 014.11 2h3a2 2 0 012 1.72c.127.96.361 1.903.7 2.81a2 2 0 01-.45 2.11L8.09 9.91a16 16 0 006 6l1.27-1.27a2 2 0 012.11-.45c.907.339 1.85.573 2.81.7A2 2 0 0122 16.92z"/></svg> ' + esc(attrs[i].value) + '</span>';
    }
  }
  if (cl.linkedin_url) {
    h += '<span class="hero-contact-item"><a href="' + esc(cl.linkedin_url) + '" target="_blank"><svg width="12" height="12" viewBox="0 0 24 24" fill="#0A66C2"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg> LinkedIn</a></span>';
  }
  h += '</div>';

  // Badges row
  h += '<div class="hero-badges">';
  h += renderTierBadge(entityId);
  h += renderHealthIndicator(health);
  h += renderDensityBadge(data);
  h += '<span class="cl-interface-badge">Career</span>';
  h += '</div>';

  // Actions
  h += '<div class="hero-actions">';
  h += '<button class="btn-share" onclick="openShareModal()">Share</button>';
  if (entityId !== primaryEntityId) h += '<button class="btn-delete-entity" onclick="confirmDeleteEntity(' + "'" + esc(entityId) + "'" + ', ' + "'" + esc(name).replace(/'/g, '') + "'" + ')" title="Delete entity">Delete</button>';
  h += '</div>';

  h += '</div></div></div>';

  // Summary
  var summary = e.summary?.value || '';
  if (summary) {
    h += '<div class="section">';
    h += '<div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(99,102,241,0.08);">&#128196;</span> Summary</span></div>';
    h += '<div class="summary-text">' + esc(summary) + '</div>';
    h += '</div>';
  }

  // Experience — Timeline style
  var exp = cl.experience || cl.work_history || [];
  if (exp.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(99,102,241,0.08);">&#128188;</span> Experience (' + exp.length + ')</span></div>';
    h += '<div class="timeline-section">';
    for (var i = 0; i < exp.length; i++) {
      var x = exp[i];
      var isCurrent = !x.end_date || (typeof x.end_date === 'string' && x.end_date.toLowerCase() === 'present');
      h += '<div class="timeline-item' + (isCurrent ? ' current' : '') + '">';
      if (x.company) h += '<div class="timeline-company">' + esc(x.company) + '</div>';
      if (x.title) h += '<div class="timeline-title">' + esc(x.title) + '</div>';
      var dates = [x.start_date, x.end_date || (isCurrent ? 'Present' : '')].filter(Boolean).join(' — ');
      if (dates) h += '<div class="timeline-dates">' + esc(dates) + '</div>';
      if (x.description) h += '<div class="timeline-desc">' + esc(x.description) + '</div>';
      h += '</div>';
    }
    h += '</div></div>';
  }

  // Education — Card style with icon
  var edu = cl.education || [];
  if (edu.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(168,85,247,0.08);">&#127891;</span> Education (' + edu.length + ')</span></div>';
    for (var i = 0; i < edu.length; i++) {
      var ed = edu[i];
      h += '<div class="edu-card">';
      h += '<div class="edu-icon">&#127891;</div>';
      h += '<div class="edu-info">';
      if (ed.institution) h += '<div class="edu-institution">' + esc(ed.institution) + '</div>';
      var degree = [ed.degree, ed.field].filter(Boolean).join(' in ');
      if (degree) h += '<div class="edu-degree">' + esc(degree) + '</div>';
      var years = [ed.start_year, ed.end_year].filter(Boolean).join(' — ');
      if (years) h += '<div class="edu-years">' + esc(years) + '</div>';
      h += '</div></div>';
    }
    h += '</div>';
  }

  // Skills — Chip grid
  var skills = cl.skills || [];
  if (skills.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(20,184,166,0.08);">&#128161;</span> Skills (' + skills.length + ')</span></div>';
    h += '<div class="skill-grid">';
    for (var i = 0; i < skills.length; i++) {
      h += '<span class="skill-chip">' + esc(skills[i]) + '</span>';
    }
    h += '</div></div>';
  }

  // Connections — Relationship cards with type badges
  var rels = data.relationships || [];
  if (rels.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(59,130,246,0.08);">&#129309;</span> Connections (' + rels.length + ')</span></div>';
    for (var i = 0; i < rels.length; i++) {
      var r = rels[i];
      var rName = r.name || '';
      var rInit = rName.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
      var rType = (r.relationship_type || '').toLowerCase();
      var typeCls = 'default';
      if (rType.indexOf('friend') !== -1) typeCls = 'friend';
      else if (rType.indexOf('colleague') !== -1 || rType.indexOf('professional') !== -1 || rType.indexOf('coworker') !== -1) typeCls = 'colleague';
      else if (rType.indexOf('family') !== -1 || rType.indexOf('parent') !== -1 || rType.indexOf('sibling') !== -1 || rType.indexOf('spouse') !== -1 || rType.indexOf('child') !== -1) typeCls = 'family';
      else if (rType.indexOf('mentor') !== -1) typeCls = 'mentor';
      h += '<div class="rel-card"' + (r.target_entity_id ? ' onclick="selectEntity(' + "'" + esc(r.target_entity_id) + "'" + ')" style="cursor:pointer"' : '') + '>';
      h += '<div class="rel-card-avatar">' + esc(rInit) + '</div>';
      h += '<div class="rel-card-info">';
      h += '<div class="rel-card-name">' + esc(rName) + '</div>';
      if (r.context) h += '<div class="rel-card-context">' + esc(r.context) + '</div>';
      h += '</div>';
      h += '<span class="rel-type-badge ' + typeCls + '">' + esc(r.relationship_type || 'Connection') + '</span>';
      h += sentimentBadge(r.sentiment);
      h += '</div>';
    }
    h += '</div>';
  }

  // Observations with color-coded confidence
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  if (obs.length > 0) {
    h += '<div class="section"><div class="section-header"><span class="section-title"><span class="section-header-icon" style="background:rgba(107,114,128,0.08);">&#128065;</span> Observations (' + obs.length + ')</span></div>';
    for (var i = 0; i < obs.length; i++) {
      var o = obs[i];
      var decay = calcDecay(o.observed_at);
      var opacity = Math.max(0.4, decay);
      h += '<div class="obs-card" style="opacity:' + opacity.toFixed(2) + '">';
      h += '<div class="obs-text">' + esc(o.observation) + '</div>';
      h += '<div class="obs-meta">';
      h += confidenceBadge(o.confidence, o.confidence_label);
      h += layerBadge(o.layer_number);
      if (o.source) h += '<span class="obs-source">' + esc(getSourceLabel(o.source)) + '</span>';
      h += '<span class="obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</span>';
      h += '<button class="btn-delete" data-id="' + esc(o.observation_id || '') + '" onclick="deleteObs(this.dataset.id)">delete</button>';
      h += '</div></div>';
    }
    h += '</div>';
  }

  // Source Attribution Footer
  h += renderSourceFooter(data);

  document.getElementById('main').innerHTML = h;
}

// --- Profile Mode Rendering Helpers ---

function formatProfileKey(key) {
  return (key || '').replace(/_/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
}

function renderProfileSection(id, label, contentHtml, startCollapsed) {
  var collapsed = startCollapsed ? ' collapsed' : '';
  var hidden = startCollapsed ? ' hidden' : '';
  return '<div class="profile-section">'
    + '<div class="profile-section-header' + collapsed + '" onclick="toggleProfileSection(' + "'" + id + "'" + ')" onkeydown="if(event.key===' + "'" + 'Enter' + "'" + ')toggleProfileSection(' + "'" + id + "'" + ')" tabindex="0">'
    + '<span>' + esc(label) + '</span><span class="chevron">&#9660;</span></div>'
    + '<div id="profile-sec-' + id + '" class="profile-section-body' + hidden + '">'
    + contentHtml + '</div></div>';
}

function renderOceanBars(ocean) {
  if (!ocean || typeof ocean !== 'object') return '';
  var traits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
  var h = '';
  for (var i = 0; i < traits.length; i++) {
    var trait = traits[i];
    var data = ocean[trait];
    if (!data) continue;
    var score = 0;
    var noteKey = trait + '_note';
    var disputeNote = ocean[noteKey] || (data && data._note) || '';
    if (typeof data === 'object') {
      score = data.score || data.percentile || 0;
    } else if (typeof data === 'number') {
      score = data;
    }
    var pct = Math.min(100, Math.max(0, typeof score === 'number' ? (score > 1 ? score : score * 100) : 0));
    h += '<div class="profile-bar-wrap">';
    h += '<span class="profile-bar-label">' + formatProfileKey(trait) + '</span>';
    h += '<span class="profile-bar-track"><span class="profile-bar-fill" style="width:' + pct + '%"></span></span>';
    h += '<span class="profile-bar-value">' + (typeof score === 'number' ? (score > 1 ? score.toFixed(0) : (score * 100).toFixed(0)) + '%' : esc(String(score))) + '</span>';
    if (disputeNote) h += '<span class="profile-dispute" title="' + esc(String(disputeNote)) + '">&#9888; disputed</span>';
    h += '</div>';
  }
  return h;
}

function renderProfileValue(val, contextKey) {
  if (val === null || val === undefined) return '';
  if (Array.isArray(val)) {
    if (val.length === 0) return '';
    // Check if items are objects with 'name' key (e.g., children)
    if (typeof val[0] === 'object' && val[0] !== null) {
      var h = '';
      for (var i = 0; i < val.length; i++) {
        h += '<div class="profile-insight-card"><div class="insight-text">';
        var keys = Object.keys(val[i]);
        for (var k = 0; k < keys.length; k++) {
          h += '<div class="profile-kv-row"><span class="profile-kv-key">' + formatProfileKey(keys[k]) + '</span><span class="profile-kv-val">' + esc(String(val[i][keys[k]])) + '</span></div>';
        }
        h += '</div></div>';
      }
      return h;
    }
    // Check if contextKey suggests tags
    if (contextKey === 'energized_by' || contextKey === 'drained_by' || contextKey === 'blind_spots'
        || contextKey === 'expectations' || contextKey === 'cautions' || contextKey === 'gaps'
        || contextKey === 'data_sources' || contextKey === 'skills' || contextKey === 'languages') {
      var h = '<div>';
      for (var i = 0; i < val.length; i++) {
        h += '<span class="profile-tag">' + esc(String(val[i])) + '</span>';
      }
      h += '</div>';
      return h;
    }
    // Default: bullet list
    var h = '<ul style="margin:4px 0;padding-left:20px">';
    for (var i = 0; i < val.length; i++) {
      h += '<li style="font-size:0.82rem;color:var(--text-primary)">' + esc(String(val[i])) + '</li>';
    }
    h += '</ul>';
    return h;
  }
  if (typeof val === 'object') {
    var h = '';
    var keys = Object.keys(val);
    for (var k = 0; k < keys.length; k++) {
      if (keys[k] === 'interface') continue;
      var subVal = val[keys[k]];
      if (subVal === null || subVal === undefined) continue;
      if (typeof subVal === 'object' && !Array.isArray(subVal)) {
        h += '<div style="margin-top:6px"><strong style="font-size:0.82rem;color:var(--text-secondary)">' + formatProfileKey(keys[k]) + '</strong>';
        h += '<div style="padding-left:12px">' + renderProfileValue(subVal, keys[k]) + '</div></div>';
      } else {
        h += '<div class="profile-kv-row"><span class="profile-kv-key">' + formatProfileKey(keys[k]) + '</span><span class="profile-kv-val">' + renderProfileValue(subVal, keys[k]) + '</span></div>';
      }
    }
    return h;
  }
  return esc(String(val));
}

function renderProfileWhatWorks(items) {
  if (!Array.isArray(items) || items.length === 0) return '';
  var h = '';
  for (var i = 0; i < items.length; i++) {
    h += '<div class="profile-green">' + esc(String(items[i])) + '</div>';
  }
  return h;
}

function renderProfileWhatDoesntWork(items) {
  if (!Array.isArray(items) || items.length === 0) return '';
  var h = '';
  for (var i = 0; i < items.length; i++) {
    h += '<div class="profile-red">' + esc(String(items[i])) + '</div>';
  }
  return h;
}

function renderProfileInsightCard(obs) {
  var h = '<div class="profile-insight-card">';
  h += '<div class="insight-text">' + esc(obs.observation || obs.text || '') + '</div>';
  if (obs.source) h += '<div class="insight-source">' + esc(obs.source) + '</div>';
  h += '</div>';
  return h;
}

function renderProfileDetail(data) {
  var e = data.entity || {};
  var sa = data.structured_attributes || {};
  var name = e.name?.full || '';
  var preferred = (sa.identity && sa.identity.preferred_name) || e.name?.preferred || '';
  var entityId = e.entity_id || '';
  var summary = e.summary?.value || '';
  var meta = data.extraction_metadata || {};
  var h = '';

  // 1. Header
  h += '<div class="detail-header">';
  h += '<h2>' + esc(name);
  if (preferred && preferred !== name) h += ' <span style="color:var(--text-tertiary);font-weight:400">(' + esc(preferred) + ')</span>';
  h += '</h2>';
  h += '<span class="profile-badge">Profile Mode</span>';
  h += '<span class="entity-id-badge">' + esc(entityId) + '</span>';
  h += confidenceBadge(meta.extraction_confidence);

  // Source date
  var sourceDate = meta.source_date || '';
  if (sourceDate) {
    var isStale = false;
    try {
      var sd = new Date(sourceDate);
      var sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      if (sd < sixMonthsAgo) isStale = true;
    } catch(ex) {}
    h += '<span class="profile-source-date' + (isStale ? ' stale' : '') + '">Source: ' + esc(sourceDate) + (isStale ? ' (stale)' : '') + '</span>';
  }

  h += '<div style="margin-top:8px">';
  h += '<button class="btn-share" onclick="openShareModal()">Share</button>';
  if (entityId !== primaryEntityId) h += '<button class="btn-delete-entity" style="margin-left:8px" onclick="confirmDeleteEntity(' + "'" + esc(entityId) + "'" + ', ' + "'" + esc(name).replace(/'/g, '') + "'" + ')" title="Delete entity">Delete</button>';
  h += '</div></div>';

  // 2. Summary
  if (summary) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">Summary</div>';
    h += '<div class="summary-text">' + esc(summary) + '</div></div>';
  }

  // 3. Identity
  if (sa.identity) {
    var iBody = renderProfileValue(sa.identity, 'identity');
    if (iBody) h += renderProfileSection('identity', 'Identity', iBody, false);
  }

  // 4. Personality Profile
  if (sa.personality_assessments) {
    var pBody = '';
    var pa = sa.personality_assessments;
    if (pa.mbti) {
      pBody += '<div class="profile-insight-card"><div class="insight-text"><strong>MBTI: ' + esc(pa.mbti.type || '') + '</strong>';
      if (pa.mbti.description) pBody += '<div style="margin-top:4px;font-size:0.8rem;color:var(--text-secondary)">' + esc(pa.mbti.description) + '</div>';
      if (pa.mbti.confidence) pBody += '<div style="font-size:0.72rem;color:var(--text-tertiary)">Confidence: ' + esc(String(pa.mbti.confidence)) + '</div>';
      pBody += '</div></div>';
    }
    if (pa.enneagram) {
      pBody += '<div class="profile-insight-card"><div class="insight-text"><strong>Enneagram: Type ' + esc(String(pa.enneagram.core_type || '')) + (pa.enneagram.wing ? 'w' + esc(String(pa.enneagram.wing)) : '') + '</strong>';
      if (pa.enneagram.tritype) pBody += ' <span style="color:var(--text-tertiary)">(Tritype: ' + esc(String(pa.enneagram.tritype)) + ')</span>';
      if (pa.enneagram.instinctual_variant) pBody += ' <span style="color:var(--text-tertiary)">' + esc(pa.enneagram.instinctual_variant) + '</span>';
      if (pa.enneagram.description) pBody += '<div style="margin-top:4px;font-size:0.8rem;color:var(--text-secondary)">' + esc(pa.enneagram.description) + '</div>';
      pBody += '</div></div>';
    }
    if (pa.ocean) {
      pBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem">OCEAN / Big Five</strong></div>';
      pBody += renderOceanBars(pa.ocean);
    }
    if (pBody) h += renderProfileSection('personality', 'Personality Profile', pBody, false);
  }

  // 5. Behavioral Patterns
  if (sa.behavioral_patterns) {
    var bBody = '';
    var bp = sa.behavioral_patterns;
    if (bp.communication_style) bBody += '<div class="profile-kv-row"><span class="profile-kv-key">Communication Style</span><span class="profile-kv-val">' + esc(String(bp.communication_style)) + '</span></div>';
    if (bp.decision_making) bBody += '<div class="profile-kv-row"><span class="profile-kv-key">Decision Making</span><span class="profile-kv-val">' + esc(String(bp.decision_making)) + '</span></div>';
    if (bp.conflict_style) bBody += '<div class="profile-kv-row"><span class="profile-kv-key">Conflict Style</span><span class="profile-kv-val">' + esc(String(bp.conflict_style)) + '</span></div>';
    if (bp.energized_by && bp.energized_by.length > 0) {
      bBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem;color:var(--text-secondary)">Energized By</strong></div>';
      bBody += renderProfileValue(bp.energized_by, 'energized_by');
    }
    if (bp.drained_by && bp.drained_by.length > 0) {
      bBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem;color:var(--text-secondary)">Drained By</strong></div>';
      bBody += renderProfileValue(bp.drained_by, 'drained_by');
    }
    if (bp.blind_spots && bp.blind_spots.length > 0) {
      bBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem;color:var(--text-secondary)">Blind Spots</strong></div>';
      for (var i = 0; i < bp.blind_spots.length; i++) {
        bBody += '<div class="profile-insight-card"><div class="insight-text">' + esc(String(bp.blind_spots[i])) + '</div></div>';
      }
    }
    if (bBody) h += renderProfileSection('behavioral', 'Behavioral Patterns', bBody, false);
  }

  // 6. Enneagram Dynamics
  if (sa.enneagram_dynamics) {
    var eBody = renderProfileValue(sa.enneagram_dynamics, 'enneagram_dynamics');
    if (eBody) h += renderProfileSection('enneagram', 'Enneagram Dynamics', eBody, false);
  }

  // 7. Family
  if (sa.family) {
    var fBody = renderProfileValue(sa.family, 'family');
    if (fBody) h += renderProfileSection('family', 'Family', fBody, false);
  }

  // 8. Spouse Dynamic
  if (sa.spouse_dynamic) {
    var sdBody = '';
    var sd = sa.spouse_dynamic;
    if (sd.core_dynamic) sdBody += '<div class="profile-kv-row"><span class="profile-kv-key">Core Dynamic</span><span class="profile-kv-val">' + esc(String(sd.core_dynamic)) + '</span></div>';
    if (sd.friction_points && sd.friction_points.length > 0) {
      sdBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem">Friction Points</strong></div>';
      for (var i = 0; i < sd.friction_points.length; i++) {
        sdBody += '<div class="profile-red">' + esc(String(sd.friction_points[i])) + '</div>';
      }
    }
    if (sd.strengths && sd.strengths.length > 0) {
      sdBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem">Strengths</strong></div>';
      for (var i = 0; i < sd.strengths.length; i++) {
        sdBody += '<div class="profile-green">' + esc(String(sd.strengths[i])) + '</div>';
      }
    }
    if (sd.confirmed && sd.confirmed.length > 0) {
      sdBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem;color:#10b981">Confirmed</strong></div>';
      for (var i = 0; i < sd.confirmed.length; i++) {
        sdBody += '<div class="profile-green">' + esc(String(sd.confirmed[i])) + '</div>';
      }
    }
    if (sd.disputed && sd.disputed.length > 0) {
      sdBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem;color:#f59e0b">Disputed</strong></div>';
      for (var i = 0; i < sd.disputed.length; i++) {
        sdBody += '<div class="profile-amber">' + esc(String(sd.disputed[i])) + '</div>';
      }
    }
    if (sd.modified && sd.modified.length > 0) {
      sdBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem;color:#f59e0b">Modified</strong></div>';
      for (var i = 0; i < sd.modified.length; i++) {
        sdBody += '<div class="profile-amber">' + esc(String(sd.modified[i])) + '</div>';
      }
    }
    if (sdBody) h += renderProfileSection('spouse-dynamic', 'Spouse Dynamic', sdBody, false);
  }

  // 9. Relationship with primary user — MOST PROMINENT
  if (sa.relationship_to_primary_user) {
    var rpBody = '';
    var rp = sa.relationship_to_primary_user;
    if (rp.what_works && rp.what_works.length > 0) {
      rpBody += '<div style="margin-bottom:8px"><strong style="font-size:0.82rem;color:#10b981">What Works</strong></div>';
      rpBody += renderProfileWhatWorks(rp.what_works);
    }
    if (rp.what_doesnt_work && rp.what_doesnt_work.length > 0) {
      rpBody += '<div style="margin-top:8px;margin-bottom:8px"><strong style="font-size:0.82rem;color:#ef4444">What Doesn' + "'" + 't Work</strong></div>';
      rpBody += renderProfileWhatDoesntWork(rp.what_doesnt_work);
    }
    if (rp.management_protocol) {
      rpBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem">Management Protocol</strong></div>';
      rpBody += '<div style="font-size:0.82rem;color:var(--text-primary);margin-top:4px;padding:8px 12px;background:var(--bg-secondary);border-radius:var(--radius-md)">' + esc(String(rp.management_protocol)) + '</div>';
    }
    if (rp.mj_analysis) {
      rpBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem">MJ Analysis</strong></div>';
      rpBody += '<div class="profile-insight-card"><div class="insight-text">' + esc(String(rp.mj_analysis)) + '</div><div class="insight-source">Source: MJ/AI Assessment</div></div>';
    }
    if (rp.communication_guidelines) {
      rpBody += '<div style="margin-top:8px"><strong style="font-size:0.82rem">Communication Guidelines</strong></div>';
      if (typeof rp.communication_guidelines === 'string') {
        rpBody += '<div style="font-size:0.82rem;color:var(--text-primary);margin-top:4px">' + esc(rp.communication_guidelines) + '</div>';
      } else {
        rpBody += renderProfileValue(rp.communication_guidelines, 'communication_guidelines');
      }
    }
    if (rpBody) {
      h += '<div class="section" style="border:2px solid var(--accent-primary);border-radius:var(--radius-md);padding:2px">';
      h += renderProfileSection('rel-primary', 'Relationship with Primary User', rpBody, false);
      h += '</div>';
    }
  }

  // 10. AI Interaction Guidelines
  if (sa.ai_interaction_guidelines) {
    var aiBody = '';
    var ai = sa.ai_interaction_guidelines;
    if (ai.expectations && ai.expectations.length > 0) {
      aiBody += '<div style="margin-bottom:6px"><strong style="font-size:0.82rem">Expectations</strong></div>';
      aiBody += renderProfileValue(ai.expectations, 'expectations');
    }
    if (ai.cautions && ai.cautions.length > 0) {
      aiBody += '<div style="margin-top:6px"><strong style="font-size:0.82rem">Cautions</strong></div>';
      aiBody += renderProfileValue(ai.cautions, 'cautions');
    }
    if (ai.preferred_approach) {
      aiBody += '<div class="profile-kv-row"><span class="profile-kv-key">Preferred Approach</span><span class="profile-kv-val">' + esc(String(ai.preferred_approach)) + '</span></div>';
    }
    if (aiBody) h += renderProfileSection('ai-guidelines', 'AI Interaction Guidelines', aiBody, false);
  }

  // 11. Flat Attributes
  var attrs = data.attributes || [];
  if (attrs.length > 0) {
    var aBody = '';
    for (var i = 0; i < attrs.length; i++) {
      aBody += '<div class="profile-kv-row"><span class="profile-kv-key">' + formatProfileKey(attrs[i].key) + '</span><span class="profile-kv-val">' + esc(attrs[i].value || '') + '</span></div>';
    }
    h += renderProfileSection('flat-attrs', 'Attributes (' + attrs.length + ')', aBody, true);
  }

  // 12. Relationships
  var rels = data.relationships || [];
  if (rels.length > 0) {
    var rBody = '';
    for (var i = 0; i < rels.length; i++) {
      var r = rels[i];
      rBody += '<div class="rel-row"><span class="rel-name">' + esc(r.name) + '</span>';
      rBody += '<span class="rel-type">' + esc(r.relationship_type || '') + '</span>';
      if (r.context) rBody += '<span class="rel-context">' + esc(r.context) + '</span>';
      rBody += '</div>';
    }
    h += renderProfileSection('relationships', 'Relationships (' + rels.length + ')', rBody, false);
  }

  // 13. Observations
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  if (obs.length > 0) {
    var oBody = '';
    for (var i = 0; i < obs.length; i++) {
      var o = obs[i];
      oBody += '<div class="obs-card">';
      oBody += '<div class="obs-text">' + esc(o.observation) + '</div>';
      oBody += '<div class="obs-meta">';
      oBody += confidenceBadge(o.confidence, o.confidence_label);
      if (o.source) oBody += '<span class="obs-source">' + esc(o.source) + '</span>';
      oBody += '<span class="obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</span>';
      oBody += '<button class="btn-delete" data-id="' + esc(o.observation_id || '') + '" onclick="deleteObs(this.dataset.id)">delete</button>';
      oBody += '</div></div>';
    }
    h += renderProfileSection('observations', 'Observations (' + obs.length + ')', oBody, false);
  }

  // 14. Profile Metadata
  if (sa.profile_metadata) {
    var mBody = renderProfileValue(sa.profile_metadata, 'profile_metadata');
    if (mBody) h += renderProfileSection('profile-meta', 'Profile Metadata', mBody, true);
  }

  document.getElementById('main').innerHTML = h;
}

// --- Dynamic Card Renderer for Structured Attributes in LinkedIn Layout ---

function renderLiOceanBars(ocean) {
  if (!ocean || typeof ocean !== 'object') return '';
  var traits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
  var h = '';
  for (var i = 0; i < traits.length; i++) {
    var trait = traits[i];
    var data = ocean[trait];
    if (!data) continue;
    var score = 0;
    var disputeNote = (data && data._note) || '';
    if (typeof data === 'object') {
      score = data.score || data.percentile || 0;
    } else if (typeof data === 'number') {
      score = data;
    }
    var pct = Math.min(100, Math.max(0, typeof score === 'number' ? (score > 1 ? score : score * 100) : 0));
    var valStr = typeof score === 'number' ? (score > 1 ? score.toFixed(0) : (score * 100).toFixed(0)) + '%' : esc(String(score));
    h += '<div class="li-bar-wrap">';
    h += '<span class="li-bar-label">' + formatProfileKey(trait) + '</span>';
    h += '<span class="li-bar-track"><span class="li-bar-fill" style="width:' + pct + '%"></span></span>';
    h += '<span class="li-bar-value">' + valStr + '</span>';
    if (disputeNote) h += '<span class="li-bar-dispute" title="' + esc(String(disputeNote)) + '">&#9888; disputed</span>';
    h += '</div>';
  }
  return h;
}

function renderLiPillTags(items, colorClass) {
  if (!Array.isArray(items) || items.length === 0) return '';
  var h = '';
  for (var i = 0; i < items.length; i++) {
    h += '<span class="li-pill-tag ' + colorClass + '">' + esc(String(items[i])) + '</span>';
  }
  return h;
}

function renderLiBorderItems(items, colorClass) {
  if (!Array.isArray(items) || items.length === 0) return '';
  var h = '';
  for (var i = 0; i < items.length; i++) {
    h += '<div class="li-border-item ' + colorClass + '">' + esc(String(items[i])) + '</div>';
  }
  return h;
}

function renderLiStatusItems(items, statusType) {
  if (!Array.isArray(items) || items.length === 0) return '';
  var tagClass = 'li-status-' + statusType;
  var h = '';
  for (var i = 0; i < items.length; i++) {
    h += '<div class="li-border-item ' + (statusType === 'confirmed' ? 'li-border-green' : statusType === 'disputed' ? 'li-border-red' : 'li-border-amber') + '">';
    h += esc(String(items[i]));
    h += '<span class="li-status-tag ' + tagClass + '">' + statusType + '</span>';
    h += '</div>';
  }
  return h;
}

function renderLiKvTable(obj) {
  if (!obj || typeof obj !== 'object') return '';
  var keys = Object.keys(obj);
  var h = '<div class="li-kv-table">';
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    if (k === 'interface' || k.startsWith('_')) continue;
    var v = obj[k];
    if (v === null || v === undefined) continue;
    if (typeof v === 'object' && !Array.isArray(v)) continue; // skip nested objects, handled separately
    var valStr = Array.isArray(v) ? v.join(', ') : String(v);
    h += '<div class="li-kv-row"><span class="li-kv-key">' + formatProfileKey(k) + '</span><span class="li-kv-val">' + esc(valStr) + '</span></div>';
  }
  h += '</div>';
  return h;
}

function renderLiGenericValue(val, contextKey) {
  if (val === null || val === undefined) return '';
  if (Array.isArray(val)) {
    if (val.length === 0) return '';
    if (typeof val[0] === 'object' && val[0] !== null) {
      var h = '';
      for (var i = 0; i < val.length; i++) {
        h += '<div class="li-sub-card">';
        h += renderLiKvTable(val[i]);
        h += '</div>';
      }
      return h;
    }
    return renderLiBorderItems(val, 'li-border-blue');
  }
  if (typeof val === 'object') {
    return renderLiKvTable(val);
  }
  return '<div style="font-size:14px;color:#191919;line-height:1.4">' + esc(String(val)) + '</div>';
}

function renderDynamicCardContent(sectionKey, sectionData) {
  var h = '';

  // --- IDENTITY ---
  if (sectionKey === 'identity') {
    return renderLiKvTable(sectionData);
  }

  // --- PROFESSIONAL ---
  if (sectionKey === 'professional') {
    return renderLiKvTable(sectionData);
  }

  // --- PERSONALITY ASSESSMENTS (with OCEAN bars) ---
  if (sectionKey === 'personality_assessments') {
    var pa = sectionData;
    if (pa.mbti) {
      h += '<div style="margin-bottom:16px">';
      h += '<div class="li-sub-title">MBTI</div>';
      h += '<span class="li-mbti-badge">' + esc(pa.mbti.type || '') + '</span>';
      if (pa.mbti.description) h += '<div style="margin-top:8px;font-size:14px;color:#191919;line-height:1.4">' + esc(pa.mbti.description) + '</div>';
      if (pa.mbti.confidence) h += '<div style="margin-top:4px;font-size:13px;color:#666">Confidence: ' + esc(String(pa.mbti.confidence)) + '</div>';
      h += '</div>';
    }
    if (pa.enneagram) {
      h += '<div style="margin-bottom:16px">';
      h += '<div class="li-sub-title">Enneagram</div>';
      var ennLabel = 'Type ' + (pa.enneagram.core_type || '') + (pa.enneagram.wing ? 'w' + pa.enneagram.wing : '');
      h += '<span class="li-enneagram-badge">' + esc(ennLabel) + '</span>';
      if (pa.enneagram.tritype) h += '<span style="margin-left:8px;font-size:13px;color:#666">Tritype: ' + esc(String(pa.enneagram.tritype)) + '</span>';
      if (pa.enneagram.instinctual_variant) h += '<span style="margin-left:8px;font-size:13px;color:#666">' + esc(pa.enneagram.instinctual_variant) + '</span>';
      if (pa.enneagram.description) h += '<div style="margin-top:8px;font-size:14px;color:#191919;line-height:1.4">' + esc(pa.enneagram.description) + '</div>';
      h += '</div>';
    }
    if (pa.ocean) {
      h += '<div style="margin-bottom:8px">';
      h += '<div class="li-sub-title">OCEAN / Big Five</div>';
      h += renderLiOceanBars(pa.ocean);
      h += '</div>';
    }
    return h;
  }

  // --- BEHAVIORAL PATTERNS ---
  if (sectionKey === 'behavioral_patterns') {
    var bp = sectionData;
    // Key-value fields
    var kvFields = ['communication_style', 'decision_making', 'conflict_style'];
    var hasKv = false;
    for (var i = 0; i < kvFields.length; i++) {
      if (bp[kvFields[i]]) {
        h += '<div class="li-kv-row"><span class="li-kv-key">' + formatProfileKey(kvFields[i]) + '</span><span class="li-kv-val">' + esc(String(bp[kvFields[i]])) + '</span></div>';
        hasKv = true;
      }
    }
    // Energized By pills
    if (bp.energized_by && bp.energized_by.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title">Energized By</div>';
      h += renderLiPillTags(bp.energized_by, 'li-pill-green');
      h += '</div>';
    }
    // Drained By pills
    if (bp.drained_by && bp.drained_by.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title">Drained By</div>';
      h += renderLiPillTags(bp.drained_by, 'li-pill-red');
      h += '</div>';
    }
    // Blind Spots
    if (bp.blind_spots && bp.blind_spots.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title">&#9888; Blind Spots</div>';
      h += renderLiBorderItems(bp.blind_spots, 'li-border-amber');
      h += '</div>';
    }
    // Any remaining fields
    var handled = ['communication_style', 'decision_making', 'conflict_style', 'energized_by', 'drained_by', 'blind_spots'];
    var bpKeys = Object.keys(bp);
    for (var i = 0; i < bpKeys.length; i++) {
      if (handled.indexOf(bpKeys[i]) === -1 && !bpKeys[i].startsWith('_')) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(bpKeys[i]) + '</div>';
        h += renderLiGenericValue(bp[bpKeys[i]], bpKeys[i]);
        h += '</div>';
      }
    }
    return h;
  }

  // --- ENNEAGRAM DYNAMICS ---
  if (sectionKey === 'enneagram_dynamics') {
    return renderLiKvTable(sectionData);
  }

  // --- FAMILY (with member sub-cards) ---
  if (sectionKey === 'family') {
    var fam = sectionData;
    // Spouse sub-card
    if (fam.spouse) {
      var sp = fam.spouse;
      var spInit = (sp.name || '').split(/\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
      h += '<div class="li-family-member">';
      h += '<div class="li-family-avatar">' + esc(spInit) + '</div>';
      h += '<div class="li-family-info">';
      h += '<div class="li-family-name">' + esc(sp.name || '') + '</div>';
      h += '<div class="li-family-role">' + esc(sp.relationship_type || 'Spouse') + '</div>';
      var spDetails = [];
      if (sp.origin) spDetails.push('Origin: ' + sp.origin);
      if (sp.profession) spDetails.push(sp.profession);
      if (sp.personality_type) spDetails.push('Personality: ' + sp.personality_type);
      if (spDetails.length > 0) h += '<div class="li-family-detail">' + esc(spDetails.join(' · ')) + '</div>';
      h += '</div></div>';
    }
    // Children
    if (fam.children && fam.children.length > 0) {
      for (var i = 0; i < fam.children.length; i++) {
        var child = fam.children[i];
        var cInit = (child.name || '').split(/\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
        h += '<div class="li-family-member">';
        h += '<div class="li-family-avatar" style="background:linear-gradient(135deg,#7c3aed,#5b21b6)">' + esc(cInit) + '</div>';
        h += '<div class="li-family-info">';
        h += '<div class="li-family-name">' + esc(child.name || '') + '</div>';
        var childMeta = [];
        if (child.age) childMeta.push('Age ' + child.age);
        if (child.birth_date) childMeta.push('Born: ' + child.birth_date);
        if (childMeta.length > 0) h += '<div class="li-family-role">' + esc(childMeta.join(' · ')) + '</div>';
        if (child.notes) h += '<div class="li-family-detail">' + esc(child.notes) + '</div>';
        h += '</div></div>';
      }
    }
    // Family notes
    if (fam.family_notes) {
      h += '<div style="margin-top:12px;font-size:14px;color:#666;line-height:1.4;font-style:italic">' + esc(fam.family_notes) + '</div>';
    }
    // Any other fields
    var famHandled = ['spouse', 'children', 'family_notes'];
    var famKeys = Object.keys(fam);
    for (var i = 0; i < famKeys.length; i++) {
      if (famHandled.indexOf(famKeys[i]) === -1 && !famKeys[i].startsWith('_')) {
        h += '<div class="li-kv-row"><span class="li-kv-key">' + formatProfileKey(famKeys[i]) + '</span><span class="li-kv-val">' + esc(String(fam[famKeys[i]])) + '</span></div>';
      }
    }
    return h;
  }

  // --- SPOUSE DYNAMIC (with status tags) ---
  if (sectionKey === 'spouse_dynamic') {
    var sd = sectionData;
    if (sd.core_dynamic) {
      h += '<div class="li-kv-row"><span class="li-kv-key">Core Dynamic</span><span class="li-kv-val">' + esc(String(sd.core_dynamic)) + '</span></div>';
    }
    if (sd.friction_points && sd.friction_points.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#ef4444">Friction Points</div>';
      h += renderLiBorderItems(sd.friction_points, 'li-border-red');
      h += '</div>';
    }
    if (sd.strengths && sd.strengths.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#10b981">Strengths</div>';
      h += renderLiBorderItems(sd.strengths, 'li-border-green');
      h += '</div>';
    }
    if (sd.confirmed && sd.confirmed.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#10b981">&#10003; Confirmed</div>';
      h += renderLiStatusItems(sd.confirmed, 'confirmed');
      h += '</div>';
    }
    if (sd.disputed && sd.disputed.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#dc2626">&#9888; Disputed</div>';
      h += renderLiStatusItems(sd.disputed, 'disputed');
      h += '</div>';
    }
    if (sd.modified && sd.modified.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#d97706">&#9998; Modified</div>';
      h += renderLiStatusItems(sd.modified, 'modified');
      h += '</div>';
    }
    // Any other fields
    var sdHandled = ['core_dynamic', 'friction_points', 'strengths', 'confirmed', 'disputed', 'modified'];
    var sdKeys = Object.keys(sd);
    for (var i = 0; i < sdKeys.length; i++) {
      if (sdHandled.indexOf(sdKeys[i]) === -1 && !sdKeys[i].startsWith('_')) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(sdKeys[i]) + '</div>';
        h += renderLiGenericValue(sd[sdKeys[i]], sdKeys[i]);
        h += '</div>';
      }
    }
    return h;
  }

  // --- RELATIONSHIP WITH PRIMARY USER ---
  if (sectionKey === 'relationship_to_primary_user') {
    var rp = sectionData;
    if (rp.what_works && rp.what_works.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#10b981">&#10003; What Works</div>';
      h += renderLiBorderItems(rp.what_works, 'li-border-green');
      h += '</div>';
    }
    if (rp.what_doesnt_work && rp.what_doesnt_work.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#ef4444">&#10007; What Doesn&#39;t Work</div>';
      h += renderLiBorderItems(rp.what_doesnt_work, 'li-border-red');
      h += '</div>';
    }
    if (rp.management_protocol) {
      h += '<div class="li-sub-section"><div class="li-sub-title">Management Protocol</div>';
      h += '<div style="font-size:14px;color:#191919;line-height:1.4;padding:10px 14px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0">' + esc(String(rp.management_protocol)) + '</div>';
      h += '</div>';
    }
    if (rp.mj_analysis) {
      h += '<div class="li-sub-section"><div class="li-sub-title">MJ Analysis</div>';
      h += '<div class="li-blockquote"><div class="li-blockquote-text">' + esc(String(rp.mj_analysis)) + '</div>';
      h += '<div class="li-blockquote-source">Source: MJ/AI Assessment</div></div>';
      h += '</div>';
    }
    if (rp.communication_guidelines) {
      h += '<div class="li-sub-section"><div class="li-sub-title">Communication Guidelines</div>';
      if (typeof rp.communication_guidelines === 'string') {
        h += '<div style="font-size:14px;color:#191919;line-height:1.4">' + esc(rp.communication_guidelines) + '</div>';
      } else {
        h += renderLiGenericValue(rp.communication_guidelines, 'communication_guidelines');
      }
      h += '</div>';
    }
    // Any other fields
    var rpHandled = ['what_works', 'what_doesnt_work', 'management_protocol', 'mj_analysis', 'communication_guidelines'];
    var rpKeys = Object.keys(rp);
    for (var i = 0; i < rpKeys.length; i++) {
      if (rpHandled.indexOf(rpKeys[i]) === -1 && !rpKeys[i].startsWith('_')) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(rpKeys[i]) + '</div>';
        h += renderLiGenericValue(rp[rpKeys[i]], rpKeys[i]);
        h += '</div>';
      }
    }
    return h;
  }

  // --- AI INTERACTION GUIDELINES / COMMUNICATION GUIDELINES ---
  if (sectionKey === 'ai_interaction_guidelines') {
    var ai = sectionData;
    if (ai.expectations && ai.expectations.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#10b981">Expectations</div>';
      h += renderLiBorderItems(ai.expectations, 'li-border-green');
      h += '</div>';
    }
    if (ai.cautions && ai.cautions.length > 0) {
      h += '<div class="li-sub-section"><div class="li-sub-title" style="color:#f59e0b">&#9888; Cautions</div>';
      h += renderLiBorderItems(ai.cautions, 'li-border-amber');
      h += '</div>';
    }
    if (ai.preferred_approach) {
      h += '<div class="li-kv-row"><span class="li-kv-key">Preferred Approach</span><span class="li-kv-val">' + esc(String(ai.preferred_approach)) + '</span></div>';
    }
    // Any other fields
    var aiHandled = ['expectations', 'cautions', 'preferred_approach'];
    var aiKeys = Object.keys(ai);
    for (var i = 0; i < aiKeys.length; i++) {
      if (aiHandled.indexOf(aiKeys[i]) === -1 && !aiKeys[i].startsWith('_')) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(aiKeys[i]) + '</div>';
        h += renderLiGenericValue(ai[aiKeys[i]], aiKeys[i]);
        h += '</div>';
      }
    }
    return h;
  }

  // --- PROFILE METADATA ---
  if (sectionKey === 'profile_metadata') {
    var pm = sectionData;
    var pmKeys = Object.keys(pm);
    for (var i = 0; i < pmKeys.length; i++) {
      var k = pmKeys[i];
      if (k.startsWith('_')) continue;
      var v = pm[k];
      if (v === null || v === undefined) continue;
      if (Array.isArray(v)) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(k) + '</div>';
        h += renderLiPillTags(v, 'li-pill-blue');
        h += '</div>';
      } else {
        h += '<div class="li-kv-row"><span class="li-kv-key">' + formatProfileKey(k) + '</span><span class="li-kv-val">' + esc(String(v)) + '</span></div>';
      }
    }
    return h;
  }

  // --- GENERIC FALLBACK ---
  if (typeof sectionData === 'string') {
    return '<div style="font-size:14px;color:#191919;line-height:1.4">' + esc(sectionData) + '</div>';
  }
  if (Array.isArray(sectionData)) {
    return renderLiGenericValue(sectionData, sectionKey);
  }
  if (typeof sectionData === 'object') {
    // Check for known patterns
    var sdKeys = Object.keys(sectionData);
    var hasWhatWorks = sdKeys.indexOf('what_works') !== -1 || sdKeys.indexOf('what_doesnt_work') !== -1;
    var hasOcean = sdKeys.indexOf('ocean') !== -1 || sdKeys.indexOf('mbti') !== -1;
    var hasSpouse = sdKeys.indexOf('spouse') !== -1 || sdKeys.indexOf('children') !== -1;
    if (hasWhatWorks) return renderDynamicCardContent('relationship_to_primary_user', sectionData);
    if (hasOcean) return renderDynamicCardContent('personality_assessments', sectionData);
    if (hasSpouse) return renderDynamicCardContent('family', sectionData);
    // Render as KV with nested sections
    h = '';
    for (var i = 0; i < sdKeys.length; i++) {
      var k = sdKeys[i];
      if (k.startsWith('_') || k === 'interface') continue;
      var v = sectionData[k];
      if (v === null || v === undefined) continue;
      if (typeof v === 'object' && !Array.isArray(v)) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(k) + '</div>';
        h += renderLiKvTable(v);
        h += '</div>';
      } else if (Array.isArray(v)) {
        h += '<div class="li-sub-section"><div class="li-sub-title">' + formatProfileKey(k) + '</div>';
        h += renderLiGenericValue(v, k);
        h += '</div>';
      } else {
        h += '<div class="li-kv-row"><span class="li-kv-key">' + formatProfileKey(k) + '</span><span class="li-kv-val">' + esc(String(v)) + '</span></div>';
      }
    }
    return h;
  }
  return esc(String(sectionData));
}

function renderStructuredAttributeCards(sa, editSvg, entityId) {
  if (!sa || typeof sa !== 'object') return '';
  var saKeys = Object.keys(sa);
  var skipKeys = ['interface'];

  // Section display config
  var sectionConfig = {
    'identity': { label: 'Identity', order: 1 },
    'professional': { label: 'Professional', order: 2 },
    'personality_assessments': { label: 'Personality Profile', order: 3 },
    'behavioral_patterns': { label: 'Behavioral Patterns', order: 4 },
    'enneagram_dynamics': { label: 'Enneagram Dynamics', order: 5 },
    'family': { label: 'Family', order: 6 },
    'spouse_dynamic': { label: 'Spouse Dynamic', order: 7 },
    'relationship_to_primary_user': { label: 'Relationship with Primary User', order: 8 },
    'ai_interaction_guidelines': { label: 'Communication Guidelines', order: 9 },
    'profile_metadata': { label: 'Profile Metadata', order: 100 }
  };

  // Collect sections
  var sections = [];
  for (var i = 0; i < saKeys.length; i++) {
    var sKey = saKeys[i];
    if (skipKeys.indexOf(sKey) !== -1) continue;
    var sData = sa[sKey];
    if (!sData) continue;
    if (typeof sData === 'object' && !Array.isArray(sData) && Object.keys(sData).length === 0) continue;
    var config = sectionConfig[sKey] || { label: formatProfileKey(sKey), order: 50 };
    sections.push({ key: sKey, label: config.label, order: config.order, data: sData });
  }

  // Sort by order
  sections.sort(function(a, b) { return a.order - b.order; });

  var h = '';
  for (var i = 0; i < sections.length; i++) {
    var sec = sections[i];
    var cardId = 'li-card-sa-' + sec.key;
    var collapsed = sec.key === 'profile_metadata';

    h += '<div class="li-card' + (collapsed ? ' li-collapsed' : '') + '" id="' + cardId + '">';
    h += '<div class="li-card-header">';
    h += '<h2 class="li-card-title">' + esc(sec.label) + '</h2>';
    h += '<div style="display:flex;align-items:center;gap:8px;">';
    h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'sa-' + sec.key + '\\',\\'' + esc(entityId) + '\\')" title="Edit">' + editSvg + '</button>';
    h += '<button class="li-collapse-btn" onclick="toggleCardCollapse(\\'' + cardId + '\\')" title="Toggle">';
    h += '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
    h += '</button>';
    h += '</div></div>';

    h += '<div class="li-card-body" id="' + cardId + '-body"' + (collapsed ? ' style="display:none"' : '') + '>';
    h += renderDynamicCardContent(sec.key, sec.data);
    h += '</div></div>';
  }
  return h;
}

function renderDetail(data) {
  // Profile mode entities now render in LinkedIn card layout with dynamic structured attribute cards
  var e = data.entity || {};
  var type = e.entity_type || '';

  // Route connected object types to their own renderer
  if (['role', 'credential', 'skill'].indexOf(type) !== -1) {
    return renderConnectedDetail(data);
  }

  // --- LinkedIn-inspired card layout for Person + Org entities ---
  var isOrg = ['organization', 'business', 'institution'].indexOf(type) !== -1;
  var isPerson = type === 'person';
  var name = isPerson ? (e.name?.full || '') : (e.name?.common || e.name?.legal || e.name?.full || '');
  var summary = e.summary?.value || '';
  var meta = data.extraction_metadata || {};
  var entityId = e.entity_id || '';
  var health = computeEntityHealth(data);
  var density = getEntityDensity(data);
  var cl = data.career_lite || {};
  var attrs = data.attributes || [];
  var obs = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var rels = data.relationships || [];
  var connected = data.connected_objects || [];
  var initials = name.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);

  // Extract key attributes
  var headline = cl.headline || '';
  var location = cl.location || '';
  var linkedinUrl = cl.linkedin_url || '';
  var xHandle = '', xUrl = '', igHandle = '', igUrl = '';
  for (var i = 0; i < attrs.length; i++) {
    if (attrs[i].key === 'headline' && attrs[i].value && !headline) headline = attrs[i].value;
    if (attrs[i].key === 'location' && attrs[i].value && !location) location = attrs[i].value;
    if (attrs[i].key === 'linkedin_url' && attrs[i].value && !linkedinUrl) linkedinUrl = attrs[i].value;
    if (attrs[i].key === 'x_handle' && attrs[i].value) xHandle = attrs[i].value;
    if (attrs[i].key === 'x_url' && attrs[i].value) xUrl = attrs[i].value;
    if (attrs[i].key === 'instagram_handle' && attrs[i].value) igHandle = attrs[i].value;
    if (attrs[i].key === 'instagram_url' && attrs[i].value) igUrl = attrs[i].value;
  }
  var currentTitle = cl.current_title || cl.current_role || '';
  var currentCompany = cl.current_company || '';
  var experience = cl.experience || cl.work_history || [];
  var education = cl.education || [];
  var skills = cl.skills || [];
  var isSelf = entityId === primaryEntityId;

  // Augment with structured_attributes data for profile-mode entities
  var sa = data.structured_attributes || {};
  var preferredName = (sa.identity && sa.identity.preferred_name) || '';
  if (!headline && sa.professional) {
    var saRole = sa.professional.current_role || '';
    var saCompany = sa.professional.company || '';
    if (saRole && saCompany) headline = saRole + ' at ' + saCompany;
    else if (saRole) headline = saRole;
    else if (saCompany) headline = saCompany;
  }
  if (!location && sa.identity && sa.identity.location) location = sa.identity.location;
  if (!currentTitle && sa.professional) currentTitle = sa.professional.current_role || '';
  if (!currentCompany && sa.professional) currentCompany = sa.professional.company || '';

  // Source count
  var srcSet = {};
  for (var i = 0; i < obs.length; i++) { if (obs[i].source) srcSet[obs[i].source] = true; }
  var prov = data.provenance_chain || {};
  var docs = prov.source_documents || [];
  for (var i = 0; i < docs.length; i++) { var s = (docs[i].source || '').split(':')[0]; if (s) srcSet[s] = true; }
  var sourceCount = Object.keys(srcSet).length;

  // --- Determine available lens tabs ---
  var tabs = [{ id: 'overview', label: 'Overview' }];
  if (isPerson && experience.length > 0) tabs.push({ id: 'career', label: 'Career' });
  if (rels.length + connected.length >= 3) tabs.push({ id: 'network', label: 'Network Map' });
  if (isPerson && obs.length >= 5) tabs.push({ id: 'intel-brief', label: 'Intelligence Brief' });
  if (isOrg) tabs.push({ id: 'org-brief', label: 'Org Brief' });
  tabs.push({ id: 'sources', label: 'Source Provenance' });

  // Store current tab context for switching
  var activeTab = window._liActiveTab || 'overview';

  var mainEl = document.getElementById('main');
  mainEl.className = 'li-profile-bg';

  // Hide external breadcrumbs — we render our own inside the profile
  var extBc = document.getElementById('breadcrumbs');
  if (extBc) extBc.innerHTML = '';

  var h = '<div class="li-profile" data-entity-id="' + esc(entityId) + '">';

  // --- Integrated Breadcrumbs ---
  h += '<div class="li-breadcrumbs">';
  if (breadcrumbs && breadcrumbs.length > 0) {
    for (var bi = 0; bi < breadcrumbs.length; bi++) {
      if (bi > 0) h += '<span class="li-bc-sep">&#8250;</span>';
      if (bi < breadcrumbs.length - 1 && breadcrumbs[bi].action) {
        h += '<a onclick="' + breadcrumbs[bi].action + '">' + esc(breadcrumbs[bi].label) + '</a>';
      } else {
        h += '<span class="li-bc-current">' + esc(breadcrumbs[bi].label) + '</span>';
      }
    }
  } else {
    h += '<a onclick="selectView(\\'overview\\')">Home</a>';
    h += '<span class="li-bc-sep">&#8250;</span>';
    h += '<span class="li-bc-current">' + esc(name) + '</span>';
  }
  h += '</div>';

  // --- Tab Bar ---
  h += '<div class="li-tab-bar">';
  for (var t = 0; t < tabs.length; t++) {
    h += '<button class="li-tab' + (tabs[t].id === activeTab ? ' active' : '') + '" onclick="switchLiTab(\\'' + tabs[t].id + '\\',\\'' + esc(entityId) + '\\')">' + esc(tabs[t].label) + '</button>';
  }
  h += '</div>';

  // For non-overview tabs, dispatch to existing renderers then wrap with persistent header
  // Save the header HTML (breadcrumbs + tab bar) built so far
  var headerHtml = h;

  var nonOverviewRenderer = null;
  if (activeTab === 'career') { nonOverviewRenderer = function() { renderCareerLite(data); }; window._liActiveTab = 'career'; }
  else if (activeTab === 'network') { nonOverviewRenderer = function() { renderNetworkMapPlaceholder(data); }; window._liActiveTab = 'network'; }
  else if (activeTab === 'intel-brief') { nonOverviewRenderer = function() { renderIntelligenceBriefPlaceholder(data); }; window._liActiveTab = 'intel-brief'; }
  else if (activeTab === 'org-brief' && isOrg) { nonOverviewRenderer = function() { renderOrgDossier(data); }; window._liActiveTab = 'org-brief'; }
  else if (activeTab === 'sources') { nonOverviewRenderer = function() { renderSourceProvenance(data); }; window._liActiveTab = 'sources'; }

  if (nonOverviewRenderer) {
    // Let the renderer set mainEl.innerHTML with its content
    nonOverviewRenderer();
    // Now wrap: persistent header (breadcrumbs + tab bar) above, renderer content below
    var renderedContent = mainEl.innerHTML;
    mainEl.className = 'li-profile-bg';
    mainEl.innerHTML = headerHtml + '<div class="li-tab-content">' + renderedContent + '</div></div>';
    renderRightPanel(data);
    return;
  }

  // --- CARD 1: HERO ---
  var editSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>';

  h += '<div class="li-card li-hero" id="li-card-hero">';
  h += '<div class="li-hero-top">';
  h += '<div class="li-hero-avatar ' + (isOrg ? 'org' : 'person') + '">' + esc(initials) + '</div>';
  h += '<div class="li-hero-info">';
  h += '<h1 class="li-hero-name" id="li-hero-name">' + esc(name);
  if (preferredName && preferredName !== name) h += ' <span style="color:#666;font-weight:400;font-size:18px">(' + esc(preferredName) + ')</span>';
  h += '</h1>';
  if (headline) {
    h += '<div class="li-hero-headline">' + esc(headline) + '</div>';
  } else if (currentTitle && currentCompany) {
    h += '<div class="li-hero-headline">' + esc(currentTitle) + ' at ' + esc(currentCompany) + '</div>';
  } else if (currentTitle || currentCompany) {
    h += '<div class="li-hero-headline">' + esc(currentTitle || currentCompany) + '</div>';
  }
  h += '<div class="li-hero-meta">';
  if (location) {
    h += '<span><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg> ' + esc(location) + '</span>';
  }
  h += '<span class="li-hero-type">' + esc(type) + '</span>';
  h += '</div>';
  // Stats row
  h += '<div class="li-hero-stats">';
  if (rels.length > 0) {
    var connClickAction = (entityId === primaryEntityId) ? 'showPeopleHub(\\'all\\')' : 'showConnectionsPage(\\'' + esc(entityId) + '\\')';
    h += '<span class="li-hero-stat" onclick="' + connClickAction + '">' + rels.length + ' connection' + (rels.length !== 1 ? 's' : '') + '</span>';
  }
  h += '<span class="li-hero-stat muted">' + sourceCount + ' source' + (sourceCount !== 1 ? 's' : '') + '</span>';
  h += '</div>';
  // Socials
  var hasSocials = linkedinUrl || xHandle || xUrl || igHandle || igUrl;
  if (hasSocials) {
    h += '<div class="li-hero-socials">';
    if (linkedinUrl) h += '<a class="li-hero-social-link" href="' + esc(linkedinUrl) + '" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="#0A66C2"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg> LinkedIn</a>';
    if (xUrl || xHandle) h += '<a class="li-hero-social-link" href="' + esc(xUrl || ('https://x.com/' + xHandle)) + '" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="#191919"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg> ' + esc(xHandle || 'X') + '</a>';
    if (igUrl || igHandle) h += '<a class="li-hero-social-link" href="' + esc(igUrl || ('https://instagram.com/' + igHandle)) + '" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#E4405F" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="5"/><circle cx="12" cy="12" r="5"/><circle cx="17.5" cy="6.5" r="1.5"/></svg> ' + esc(igHandle || 'Instagram') + '</a>';
    h += '</div>';
  }
  h += '</div>'; // li-hero-info

  // Right side: tier badge + health circle
  h += '<div class="li-hero-right">';
  h += renderTierBadge(entityId);
  var healthPct = health.level === 'strong' ? '95' : health.level === 'developing' ? '60' : '25';
  h += '<div class="li-health-circle ' + health.level + '" title="Health: ' + health.label + '">' + healthPct + '</div>';
  // Delete button for non-self
  if (entityId !== primaryEntityId) {
    h += '<button style="margin-top:4px;font-size:12px;color:#cc1016;background:none;border:1px solid #fecaca;border-radius:6px;padding:4px 10px;cursor:pointer;" onclick="confirmDeleteEntity(\\'' + esc(entityId) + '\\',\\'' + esc(name).replace(/'/g, '') + '\\')">Delete</button>';
  }
  h += '</div>';

  // Edit button
  h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'hero\\',\\'' + esc(entityId) + '\\')" title="Edit" style="position:absolute;top:12px;right:12px;">' + editSvg + '</button>';

  h += '</div>'; // li-hero-top

  // Hero edit form (hidden by default)
  h += '<div id="li-edit-hero" style="display:none;margin-top:16px;">';
  h += '<div class="li-edit-row"><label>Name</label><input class="li-edit-field" id="li-edit-name" value="' + esc(name) + '" /></div>';
  h += '<div class="li-edit-row"><label>Headline</label><input class="li-edit-field" id="li-edit-headline" value="' + esc(headline) + '" /></div>';
  h += '<div class="li-edit-row"><label>Location</label><input class="li-edit-field" id="li-edit-location" value="' + esc(location) + '" /></div>';
  h += '<div class="li-edit-row"><label>LinkedIn</label><input class="li-edit-field" id="li-edit-linkedin" value="' + esc(linkedinUrl) + '" /></div>';
  h += '<div class="li-edit-row"><label>X Handle</label><input class="li-edit-field" id="li-edit-xhandle" value="' + esc(xHandle) + '" /></div>';
  h += '<div class="li-edit-actions">';
  h += '<button class="li-btn-cancel" onclick="toggleCardEdit(\\'hero\\')">Cancel</button>';
  h += '<button class="li-btn-save" onclick="saveCardEdit(\\'hero\\',\\'' + esc(entityId) + '\\')">Save</button>';
  h += '</div></div>';

  h += '</div>'; // li-card hero

  // --- CARD 2: ABOUT ---
  if (summary || skills.length > 0) {
    h += '<div class="li-card" id="li-card-about">';
    h += '<div class="li-card-header"><h2 class="li-card-title">About</h2>';
    h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'about\\',\\'' + esc(entityId) + '\\')" title="Edit">' + editSvg + '</button></div>';

    // Display mode
    h += '<div id="li-display-about">';
    if (summary) {
      h += '<div class="li-about-text" id="li-about-text">' + esc(summary) + '</div>';
      h += '<span class="li-see-more" onclick="var t=document.getElementById(\\'li-about-text\\');t.classList.toggle(\\'expanded\\');this.textContent=t.classList.contains(\\'expanded\\')?\\'. . .see less\\':\\'. . .see more\\'">. . .see more</span>';
    }
    if (skills.length > 0) {
      h += '<div class="li-skill-pills">';
      h += '<span class="li-skill-label">Top Skills:</span>';
      var showSkills = Math.min(skills.length, 5);
      for (var i = 0; i < showSkills; i++) {
        h += '<span class="li-skill-pill">' + esc(skills[i]) + '</span>';
      }
      if (skills.length > 5) {
        h += '<span class="li-show-all" onclick="showAllSkills()">Show all ' + skills.length + ' skills &#8594;</span>';
      }
      h += '</div>';
    }
    h += '</div>';

    // Edit mode (hidden)
    h += '<div id="li-edit-about" style="display:none;">';
    h += '<div class="li-edit-row"><label>Summary</label></div>';
    h += '<textarea class="li-edit-textarea" id="li-edit-summary">' + esc(summary) + '</textarea>';
    if (skills.length > 0) {
      h += '<div style="margin-top:12px;"><label style="font-size:13px;color:#666;font-weight:500;">Skills</label></div>';
      h += '<div class="li-skill-pills" id="li-edit-skills">';
      for (var i = 0; i < skills.length; i++) {
        h += '<span class="li-skill-pill">' + esc(skills[i]) + '<button class="li-pill-remove" onclick="this.parentElement.remove()">&times;</button></span>';
      }
      h += '<span class="li-pill-add" onclick="addSkillPill()">+ Add</span>';
      h += '</div>';
    }
    h += '<div class="li-edit-actions">';
    h += '<button class="li-btn-cancel" onclick="toggleCardEdit(\\'about\\')">Cancel</button>';
    h += '<button class="li-btn-save" onclick="saveCardEdit(\\'about\\',\\'' + esc(entityId) + '\\')">Save</button>';
    h += '</div></div>';

    h += '</div>'; // li-card about
  }

  // --- DYNAMIC STRUCTURED ATTRIBUTE CARDS ---
  if (sa && typeof sa === 'object' && Object.keys(sa).length > 1) {
    h += renderStructuredAttributeCards(sa, editSvg, entityId);
  }

  // --- CARD 3: INTELLIGENCE (self entity only) ---
  if (isSelf) {
    var avgConf = density.avgConf || 0;
    var coveragePct = Math.min(100, Math.round((density.attrCount / 15) * 100));
    var lastEnriched = meta.extracted_at ? meta.extracted_at.slice(0, 10) : 'Unknown';
    var conflictCount = (data.conflicts || []).length;

    h += '<div class="li-card" id="li-card-intel">';
    h += '<div class="li-card-header"><h2 class="li-card-title">Intelligence</h2>';
    h += '<span class="li-intel-private"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg> Private to you</span></div>';
    h += '<div class="li-intel-stats">';
    h += '<div class="li-intel-stat"><div class="li-intel-stat-value">' + coveragePct + '%</div><div class="li-intel-stat-label">Data Coverage</div></div>';
    h += '<div class="li-intel-stat"><div class="li-intel-stat-value">' + avgConf.toFixed(2) + '</div><div class="li-intel-stat-label">Avg Confidence</div></div>';
    h += '<div class="li-intel-stat"><div class="li-intel-stat-value">' + sourceCount + '</div><div class="li-intel-stat-label">Sources</div></div>';
    h += '</div>';
    h += '<div class="li-intel-footer">Last enriched: ' + esc(lastEnriched) + '</div>';
    if (conflictCount > 0) {
      h += '<div class="li-intel-warning"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>' + conflictCount + ' active conflict' + (conflictCount > 1 ? 's' : '') + ' need review</div>';
    }
    h += '</div>';
  }

  // --- CARD 4: EXPERIENCE (person only, if work_history exists) ---
  if (isPerson && experience.length > 0) {
    h += '<div class="li-card" id="li-card-experience">';
    h += '<div class="li-card-header"><h2 class="li-card-title">Experience</h2>';
    h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'experience\\',\\'' + esc(entityId) + '\\')" title="Edit">' + editSvg + '</button></div>';

    h += '<div id="li-display-experience">';
    // Sort experience: current first
    var sortedExp = experience.slice().sort(function(a, b) {
      var aEnd = (a.end_date || 'Present').toLowerCase();
      var bEnd = (b.end_date || 'Present').toLowerCase();
      if (aEnd === 'present' && bEnd !== 'present') return -1;
      if (bEnd === 'present' && aEnd !== 'present') return 1;
      return (bEnd > aEnd) ? 1 : -1;
    });
    for (var i = 0; i < sortedExp.length; i++) {
      var exp = sortedExp[i];
      var compInit = (exp.company || '').slice(0, 2).toUpperCase();
      var isCurrent = (exp.end_date || '').toLowerCase() === 'present' || !exp.end_date;
      // Calculate duration
      var dur = '';
      if (exp.start_date) {
        var startStr = exp.start_date;
        var endStr = isCurrent ? new Date().toISOString().slice(0, 7) : (exp.end_date || '');
        var sDate = new Date(startStr);
        var eDate = endStr ? new Date(endStr) : new Date();
        if (!isNaN(sDate) && !isNaN(eDate)) {
          var months = (eDate.getFullYear() - sDate.getFullYear()) * 12 + (eDate.getMonth() - sDate.getMonth());
          var yrs = Math.floor(months / 12);
          var mos = months % 12;
          dur = (yrs > 0 ? yrs + ' yr' + (yrs > 1 ? 's' : '') : '') + (mos > 0 ? (yrs > 0 ? ' ' : '') + mos + ' mo' + (mos > 1 ? 's' : '') : '');
        }
      }

      // Check if org entity exists in graph for clickable link
      var orgEntityId = '';
      for (var k = 0; k < allEntities.length; k++) {
        if (allEntities[k].name && allEntities[k].name.toLowerCase() === (exp.company || '').toLowerCase()) {
          orgEntityId = allEntities[k].entity_id;
          break;
        }
      }

      h += '<div class="li-exp-item">';
      h += '<div class="li-exp-logo">' + esc(compInit) + '</div>';
      h += '<div class="li-exp-info">';
      h += '<div class="li-exp-title">' + esc(exp.title || '') + '</div>';
      if (orgEntityId) {
        h += '<div class="li-exp-company"><a href="#" onclick="selectEntity(\\'' + esc(orgEntityId) + '\\');return false;">' + esc(exp.company || '') + '</a></div>';
      } else {
        h += '<div class="li-exp-company">' + esc(exp.company || '') + '</div>';
      }
      var dateStr = (exp.start_date || '') + (exp.start_date ? ' - ' : '') + (isCurrent ? 'Present' : (exp.end_date || ''));
      if (dur) dateStr += ' \\u00B7 ' + dur;
      h += '<div class="li-exp-dates">' + esc(dateStr) + '</div>';
      if (exp.location) h += '<div class="li-exp-loc">' + esc(exp.location) + '</div>';
      if (exp.description) {
        h += '<div class="li-exp-desc" id="li-exp-desc-' + i + '">' + esc(exp.description) + '</div>';
        h += '<span class="li-see-more" onclick="var t=document.getElementById(\\'li-exp-desc-' + i + '\\');t.classList.toggle(\\'expanded\\');this.textContent=t.classList.contains(\\'expanded\\')?\\'. . .see less\\':\\'. . .see more\\'">. . .see more</span>';
      }
      h += '</div></div>';
    }
    h += '</div>';

    // Edit mode (hidden)
    h += '<div id="li-edit-experience" style="display:none;">';
    for (var i = 0; i < sortedExp.length; i++) {
      var exp = sortedExp[i];
      h += '<div class="li-exp-item" style="flex-direction:column;gap:8px;" data-exp-idx="' + i + '">';
      h += '<div class="li-edit-row"><label>Title</label><input class="li-edit-field" data-field="title" value="' + esc(exp.title || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Company</label><input class="li-edit-field" data-field="company" value="' + esc(exp.company || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Start</label><input class="li-edit-field" data-field="start_date" value="' + esc(exp.start_date || '') + '" /><label style="min-width:40px;">End</label><input class="li-edit-field" data-field="end_date" value="' + esc(exp.end_date || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Location</label><input class="li-edit-field" data-field="location" value="' + esc(exp.location || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Desc</label><textarea class="li-edit-textarea" data-field="description" style="min-height:50px;">' + esc(exp.description || '') + '</textarea></div>';
      h += '</div>';
    }
    h += '<div class="li-add-entry" onclick="addExperienceEntry()">+ Add experience</div>';
    h += '<div class="li-edit-actions">';
    h += '<button class="li-btn-cancel" onclick="toggleCardEdit(\\'experience\\')">Cancel</button>';
    h += '<button class="li-btn-save" onclick="saveCardEdit(\\'experience\\',\\'' + esc(entityId) + '\\')">Save</button>';
    h += '</div></div>';

    h += '</div>';
  }

  // --- CARD 5: EDUCATION (person only, if education exists) ---
  if (isPerson && education.length > 0) {
    h += '<div class="li-card" id="li-card-education">';
    h += '<div class="li-card-header"><h2 class="li-card-title">Education</h2>';
    h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'education\\',\\'' + esc(entityId) + '\\')" title="Edit">' + editSvg + '</button></div>';

    h += '<div id="li-display-education">';
    for (var i = 0; i < education.length; i++) {
      var edu = education[i];
      var instInit = (edu.institution || '').slice(0, 2).toUpperCase();
      h += '<div class="li-edu-item">';
      h += '<div class="li-edu-logo">' + esc(instInit) + '</div>';
      h += '<div class="li-edu-info">';
      h += '<div class="li-edu-name">' + esc(edu.institution || '') + '</div>';
      var degreeStr = (edu.degree || '');
      if (edu.field) degreeStr += (degreeStr ? ', ' : '') + edu.field;
      if (degreeStr) h += '<div class="li-edu-degree">' + esc(degreeStr) + '</div>';
      var yearStr = '';
      if (edu.start_year) yearStr = edu.start_year + (edu.end_year ? ' - ' + edu.end_year : '');
      else if (edu.years) yearStr = edu.years;
      if (yearStr) h += '<div class="li-edu-years">' + esc(yearStr) + '</div>';
      h += '</div></div>';
    }
    h += '</div>';

    // Edit mode (hidden)
    h += '<div id="li-edit-education" style="display:none;">';
    for (var i = 0; i < education.length; i++) {
      var edu = education[i];
      h += '<div class="li-edu-item" style="flex-direction:column;gap:8px;" data-edu-idx="' + i + '">';
      h += '<div class="li-edit-row"><label>School</label><input class="li-edit-field" data-field="institution" value="' + esc(edu.institution || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Degree</label><input class="li-edit-field" data-field="degree" value="' + esc(edu.degree || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Field</label><input class="li-edit-field" data-field="field" value="' + esc(edu.field || '') + '" /></div>';
      h += '<div class="li-edit-row"><label>Start</label><input class="li-edit-field" data-field="start_year" value="' + esc(edu.start_year || '') + '" /><label style="min-width:40px;">End</label><input class="li-edit-field" data-field="end_year" value="' + esc(edu.end_year || '') + '" /></div>';
      h += '</div>';
    }
    h += '<div class="li-add-entry" onclick="addEducationEntry()">+ Add education</div>';
    h += '<div class="li-edit-actions">';
    h += '<button class="li-btn-cancel" onclick="toggleCardEdit(\\'education\\')">Cancel</button>';
    h += '<button class="li-btn-save" onclick="saveCardEdit(\\'education\\',\\'' + esc(entityId) + '\\')">Save</button>';
    h += '</div></div>';

    h += '</div>';
  }

  // --- ORG: PEOPLE card (instead of Experience/Education) ---
  if (isOrg) {
    var orgPeople = [];
    for (var i = 0; i < rels.length; i++) {
      orgPeople.push(rels[i]);
    }
    for (var i = 0; i < connected.length; i++) {
      if (connected[i].entity_type === 'person') orgPeople.push(connected[i]);
    }
    if (orgPeople.length > 0) {
      h += '<div class="li-card" id="li-card-people">';
      h += '<div class="li-card-header"><h2 class="li-card-title">People</h2></div>';
      for (var i = 0; i < orgPeople.length; i++) {
        var p = orgPeople[i];
        var pName = p.name || p.label || '';
        var pInit = pName.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
        var pRole = p.relationship_type || p.context || '';
        var pClickId = p.target_entity_id || p.entity_id || '';
        h += '<div class="li-people-item"' + (pClickId ? ' onclick="selectEntity(\\'' + esc(pClickId) + '\\')"' : '') + '>';
        h += '<div class="li-people-avatar">' + esc(pInit) + '</div>';
        h += '<div><div class="li-people-name">' + esc(pName) + '</div>';
        if (pRole) h += '<div class="li-people-role">' + esc(pRole) + '</div>';
        h += '</div></div>';
      }
      h += '</div>';
    }
  }

  // --- CARD 6: ACTIVITY / OBSERVATIONS ---
  h += '<div class="li-card" id="li-card-activity">';
  h += '<div class="li-card-header"><h2 class="li-card-title">Activity</h2>';
  h += '<button class="li-edit-btn" onclick="toggleCardEdit(\\'activity\\',\\'' + esc(entityId) + '\\')" title="Add observation">' + editSvg + '</button></div>';

  h += '<div id="li-display-activity">';
  if (obs.length === 0) {
    h += '<div style="font-size:14px;color:#666;">No observations yet</div>';
  }
  var showObs = Math.min(obs.length, 3);
  for (var i = 0; i < showObs; i++) {
    var o = obs[i];
    h += '<div class="li-obs-item">';
    h += '<div class="li-obs-source"><div class="li-obs-source-icon">' + esc(getSourceLabel(o.source || '').slice(0, 2).toUpperCase()) + '</div> ' + esc(getSourceLabel(o.source || '')) + '</div>';
    h += '<div class="li-obs-text">' + esc(o.observation || '') + '</div>';
    h += '<div class="li-obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</div>';
    h += '</div>';
  }
  if (obs.length > 3) {
    h += '<div class="li-show-all" onclick="showAllObservations()">Show all ' + obs.length + ' observations &#8594;</div>';
  }
  h += '</div>';

  // Edit mode: add observation form
  h += '<div id="li-edit-activity" style="display:none;">';
  h += '<textarea class="li-edit-textarea" id="li-obs-new-text" placeholder="What did you learn about this entity?"></textarea>';
  h += '<div class="li-edit-row" style="margin-top:8px;"><label>Source</label><select id="li-obs-source" class="li-edit-field" style="padding:6px 10px;"><option value="user_input">User Input</option><option value="linkedin_api">LinkedIn</option><option value="web">Web</option><option value="file">File</option></select></div>';
  h += '<div class="li-edit-actions">';
  h += '<button class="li-btn-cancel" onclick="toggleCardEdit(\\'activity\\')">Cancel</button>';
  h += '<button class="li-btn-save" onclick="saveNewObservation(\\'' + esc(entityId) + '\\')">Add Observation</button>';
  h += '</div></div>';

  h += '</div>';

  // --- CARD 7: CONNECTIONS ---
  if (rels.length > 0) {
    var tierDefs = {
      5: { label: 'Family', color: '#ef4444' },
      4: { label: 'Close Friends', color: '#22c55e' },
      3: { label: 'Friends', color: '#3b82f6' },
      2: { label: 'Colleagues', color: '#6b7280' },
      1: { label: 'Following', color: '#9ca3af' }
    };
    var tierBuckets = { 5: [], 4: [], 3: [], 2: [], 1: [] };
    for (var i = 0; i < rels.length; i++) {
      var tier = classifyRelTier(rels[i]);
      tierBuckets[tier].push(rels[i]);
    }

    h += '<div class="li-card" id="li-card-connections">';

    // Header with link to full page
    h += '<div class="li-card-header">';
    h += '<h2 class="li-card-title" style="cursor:pointer;" onclick="showConnectionsPage(\\'' + esc(entityId) + '\\')">Connections (' + rels.length + ')</h2>';
    h += '</div>';

    // Summary line
    h += '<div class="conn-grid-summary" style="margin-bottom:12px;">';
    var tierOrder = [5, 4, 3, 2, 1];
    for (var t = 0; t < tierOrder.length; t++) {
      var tid = tierOrder[t];
      var td = tierDefs[tid];
      if (tierBuckets[tid].length === 0) continue;
      if (t > 0 && tierBuckets[tierOrder[t-1]].length > 0) h += '<span style="color:#999;"> &middot; </span>';
      h += '<span class="conn-grid-summary-item"><span class="conn-grid-summary-dot" style="background:' + td.color + ';"></span> ' + tierBuckets[tid].length + ' ' + td.label + '</span>';
    }
    h += '</div>';

    // Tier sections with grid cards
    var CARDS_PER_TIER = 6;
    for (var t = 0; t < tierOrder.length; t++) {
      var tid = tierOrder[t];
      var bucket = tierBuckets[tid];
      if (bucket.length === 0) continue;
      var td = tierDefs[tid];
      var sectionId = 'conn-tier-' + tid;

      h += '<div class="conn-tier-section" id="' + sectionId + '">';
      if (tid === 1) {
        h += '<div class="conn-tier-label conn-tier-toggle" style="cursor:pointer;color:' + td.color + ';" onclick="var el=document.getElementById(\\'conn-grid-' + tid + '\\');var vis=el.style.display!==\\'none\\';el.style.display=vis?\\'none\\':\\'grid\\';this.querySelector(\\'.chevron\\').textContent=vis?\\'\\u25B6\\':\\'\\u25BC\\'">';
        h += '<span class="chevron">\\u25B6</span> ' + td.label + ' (' + bucket.length + ')';
        h += '</div>';
      } else {
        h += '<div class="conn-tier-label" style="color:' + td.color + ';border-bottom-color:' + td.color + ';">' + td.label + ' (' + bucket.length + ')</div>';
      }

      var gridDisplay = tid === 1 ? 'none' : 'grid';
      h += '<div class="conn-grid" id="conn-grid-' + tid + '" style="display:' + gridDisplay + ';">';
      for (var j = 0; j < bucket.length; j++) {
        var r = bucket[j];
        var rName = r.name || '';
        var rInit = rName.split(/\\s+/).map(function(w) { return w ? w[0] : ''; }).join('').toUpperCase().slice(0, 2);
        var hasEntity = !!r.target_entity_id;
        var existsInGraph = hasEntity;
        if (!hasEntity) {
          for (var k = 0; k < allEntities.length; k++) {
            if (allEntities[k].name && allEntities[k].name.toLowerCase() === rName.toLowerCase()) {
              existsInGraph = true; r._matched_entity_id = allEntities[k].entity_id; break;
            }
          }
        }
        var clickable = hasEntity || r._matched_entity_id;
        var clickId = r.target_entity_id || r._matched_entity_id || '';
        var desc = (r.context || r.relationship_type || '').substring(0, 60);
        var hiddenStyle = j >= CARDS_PER_TIER ? ' style="display:none;" data-conn-overflow="' + sectionId + '"' : '';

        h += '<div class="conn-grid-card conn-item' + (clickable ? ' clickable' : '') + '"' + (clickable ? ' onclick="selectEntity(\\'' + esc(clickId) + '\\')"' : '') + hiddenStyle + ' data-conn-name="' + esc(rName.toLowerCase()) + '">';
        h += '<div class="conn-grid-avatar' + (existsInGraph ? ' in-graph' : '') + '">' + esc(rInit) + '</div>';
        h += '<div class="conn-grid-info"><div class="conn-grid-name">' + esc(rName) + '</div>';
        if (desc) h += '<div class="conn-grid-desc">' + esc(desc) + '</div>';
        h += '</div>';
        h += '<span class="conn-grid-tier" style="background:' + td.color + ';">T' + tid + '</span>';
        h += '</div>';
      }
      h += '</div>';
      if (bucket.length > CARDS_PER_TIER) {
        h += '<div class="conn-show-more" id="show-more-' + tid + '" onclick="showAllTierConnections(' + tid + ',\\'' + sectionId + '\\')">Show all ' + bucket.length + ' ' + td.label + '</div>';
      }
      h += '</div>';
    }
    h += '<div class="conn-view-all-link" onclick="showConnectionsPage(\\'' + esc(entityId) + '\\')">View all ' + rels.length + ' connections &#8594;</div>';
    h += '</div>';
  }

  // --- Conflicts section (if any) ---
  var activeConflicts = data.conflicts || [];
  if (activeConflicts.length > 0) {
    h += '<div class="li-card" style="border-left:3px solid #f97316;">';
    h += '<div class="li-card-header"><h2 class="li-card-title" style="color:#f97316;">&#9888; Conflicts (' + activeConflicts.length + ')</h2></div>';
    for (var ci = 0; ci < activeConflicts.length; ci++) {
      var cf = activeConflicts[ci];
      var cfType = (cf.conflict_type || 'FACTUAL').toLowerCase();
      h += '<div class="conflict-card">';
      h += '<div class="conflict-card-header"><span class="conflict-attr">' + esc(cf.attribute || '') + '</span><span class="conflict-type-tag ' + cfType + '">' + esc(cf.conflict_type || '') + '</span></div>';
      h += '<div class="conflict-values">';
      h += '<div class="conflict-val val-a"><div class="conflict-val-label">Value A (existing)</div><div class="conflict-val-text">' + esc(String(cf.value_a || '')) + '</div></div>';
      h += '<div class="conflict-val val-b"><div class="conflict-val-label">Value B (incoming)</div><div class="conflict-val-text">' + esc(String(cf.value_b || '')) + '</div></div>';
      h += '</div>';
      h += '<div class="conflict-actions">';
      h += '<button onclick="resolveEntityConflict(\\'' + esc(entityId) + '\\',\\'' + esc(cf.conflict_id) + '\\',\\'keep_a\\')">Keep A</button>';
      h += '<button onclick="resolveEntityConflict(\\'' + esc(entityId) + '\\',\\'' + esc(cf.conflict_id) + '\\',\\'keep_b\\')">Keep B</button>';
      h += '<button class="btn-keep-both" onclick="resolveEntityConflict(\\'' + esc(entityId) + '\\',\\'' + esc(cf.conflict_id) + '\\',\\'keep_both\\')">Keep Both</button>';
      h += '</div></div>';
    }
    h += '</div>';
  }

  h += '</div>'; // li-profile
  mainEl.innerHTML = h;
  window._liActiveTab = 'overview';
  renderRightPanel(data);
}

function renderOrgDossier(data) {
  var e = data.entity || {};
  var type = e.entity_type || '';
  var name = e.name?.common || e.name?.legal || e.name?.full || '';
  var roles = data.roles || [];
  var credentials = data.credentials || [];
  var skills = data.skills || [];
  var observations = (data.observations || []).slice().sort(function(a, b) {
    return new Date(b.observed_at || 0) - new Date(a.observed_at || 0);
  });
  var attributes = data.attributes || [];
  var relationships = data.relationships || [];
  var summary = e.summary?.value || '';
  var industry = data.industry || '';
  var h = '';

  // Compute date range from roles and credentials
  var dateRange = '';
  var earliest = '';
  var latest = '';
  var hasPresent = false;
  for (var i = 0; i < roles.length; i++) {
    var rd = roles[i].role_data || {};
    if (rd.start_date && (!earliest || rd.start_date < earliest)) earliest = rd.start_date;
    if (rd.end_date === 'Present' || rd.end_date === 'present') hasPresent = true;
    else if (rd.end_date && (!latest || rd.end_date > latest)) latest = rd.end_date;
  }
  // Also check credential dates for earliest/latest
  for (var i = 0; i < credentials.length; i++) {
    var cd = credentials[i].credential_data || {};
    var cStart = cd.start_year ? String(cd.start_year) : '';
    var cEnd = cd.end_year ? String(cd.end_year) : '';
    if (cStart && (!earliest || cStart < earliest)) earliest = cStart;
    if (cEnd && (!latest || cEnd > latest)) latest = cEnd;
  }
  if (earliest || latest || hasPresent) {
    dateRange = (earliest || '?') + ' — ' + (hasPresent ? 'Present' : (latest || '?'));
  }

  // Header
  h += '<div class="detail-header">';
  h += '<h2>' + esc(name) + '</h2>';
  h += '<span class="type-badge ' + type + '">' + esc(type) + '</span>';
  if (industry) h += '<span class="type-badge" style="background:rgba(16,185,129,0.1);color:#10b981;">' + esc(industry) + '</span>';
  if (dateRange) h += '<span style="font-size:0.78rem;color:var(--text-muted);margin-left:8px;">' + esc(dateRange) + '</span>';
  h += '<span class="entity-id-badge">' + esc(e.entity_id || '') + '</span>';
  h += renderDensityBadge(data);
  if ((e.entity_id || '') !== primaryEntityId) h += '<button class="btn-delete-entity" onclick="confirmDeleteEntity(' + "'" + esc(e.entity_id || '') + "'" + ', ' + "'" + esc(name).replace(/'/g, '') + "'" + ')" title="Delete entity">Delete</button>';
  h += '<button class="btn-enrich-org" id="btnEnrichOrg" onclick="enrichOrgFromWeb(' + "'" + esc(e.entity_id || '') + "'" + ', ' + "'" + esc(name).replace(/'/g, '') + "'" + ')" style="margin-left:8px;padding:4px 12px;border:1px solid #6366f1;border-radius:6px;background:transparent;color:#6366f1;font-size:0.72rem;font-weight:600;cursor:pointer;">Enrich from Web</button>';
  h += '</div>';

  // Enrichment prompts for skeleton/partial orgs
  var orgDensity = getEntityDensity(data);
  if (orgDensity.level === 'skeleton' || orgDensity.level === 'partial') {
    h += '<div class="section" style="margin-top:0;">';
    if (roles.length === 0) {
      h += renderEnrichPrompt('\\uD83D\\uDCBC', 'No roles recorded for this organization. Add observations about your involvement.', '', '');
    }
    if (attributes.length < 3) {
      h += renderEnrichPrompt('\\uD83C\\uDFE2', 'Limited information about this organization. Use "Enrich from Web" to pull industry, description, and more.', 'Enrich', 'document.getElementById(' + "'" + 'btnEnrichOrg' + "'" + ').click()');
    }
    if (observations.length < 2) {
      h += renderEnrichPrompt('\\uD83D\\uDCDD', 'Few observations recorded. Add notes about your experience with this organization.', '', '');
    }
    h += '</div>';
  }

  // Section: Your Roles Here
  if (roles.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">Your Roles Here (' + roles.length + ')</div>';
    for (var i = 0; i < roles.length; i++) {
      var rd = roles[i].role_data || {};
      h += '<div class="cl-exp-card">';
      if (rd.title) h += '<div class="cl-exp-title">' + esc(rd.title) + '</div>';
      var dates = [rd.start_date, rd.end_date].filter(Boolean).join(' — ');
      if (dates) h += '<div class="cl-exp-dates">' + esc(dates) + '</div>';
      if (rd.employment_type) h += '<div class="cl-exp-dates" style="font-style:italic;">' + esc(rd.employment_type) + '</div>';
      if (rd.description) h += '<div class="cl-exp-desc">' + esc(rd.description) + '</div>';
      h += '</div>';
    }
    h += '</div>';
  }

  // Section: Credentials
  if (credentials.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">Credentials (' + credentials.length + ')</div>';
    for (var i = 0; i < credentials.length; i++) {
      var cd = credentials[i].credential_data || {};
      h += '<div class="cl-edu-card">';
      if (cd.institution) h += '<div class="cl-edu-institution">' + esc(cd.institution) + '</div>';
      var degree = [cd.degree, cd.field].filter(Boolean).join(' in ');
      if (degree) h += '<div class="cl-edu-degree">' + esc(degree) + '</div>';
      var years = [cd.start_year, cd.end_year].filter(Boolean).join(' — ');
      if (years) h += '<div class="cl-edu-years">' + esc(years) + '</div>';
      h += '</div>';
    }
    h += '</div>';
  }

  // Section: Skills
  if (skills.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">Skills (' + skills.length + ')</div>';
    h += '<div class="cl-skills-wrap">';
    for (var i = 0; i < skills.length; i++) {
      var sn = (skills[i].skill_data || {}).name || (skills[i].entity || {}).name?.common || '';
      if (sn) h += '<span class="cl-skill-tag">' + esc(sn) + '</span>';
    }
    h += '</div></div>';
  }

  // Section: Key Observations
  if (observations.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">Key Observations (' + observations.length + ')</div>';
    for (var i = 0; i < observations.length; i++) {
      var o = observations[i];
      var decay = calcDecay(o.observed_at);
      var opacity = Math.max(0.5, decay);
      h += '<div class="obs-card" style="opacity:' + opacity.toFixed(2) + '">';
      h += '<div class="obs-text">' + esc(o.observation) + '</div>';
      h += '<div class="obs-meta">';
      h += confidenceBadge(o.confidence, o.confidence_label);
      if (o.source) h += '<span class="obs-source">' + esc(o.source) + '</span>';
      h += '<span class="obs-date">' + esc((o.observed_at || '').slice(0, 10)) + '</span>';
      if (decay < 1) h += '<span style="font-size:0.7rem;color:var(--text-muted);">decay ' + decay.toFixed(2) + '</span>';
      h += '</div></div>';
    }
    h += '</div>';
  }

  // Section: About (Summary + Attributes)
  if (summary || attributes.length > 0) {
    h += '<div class="section">';
    h += '<div class="section-title section-title-only">About</div>';
    if (summary) h += '<div class="summary-text">' + esc(summary) + '</div>';
    for (var i = 0; i < attributes.length; i++) {
      var a = attributes[i];
      h += '<div class="attr-row"><span class="attr-key">' + esc(a.key || '') + '</span><span class="attr-value">' + esc(a.value || '') + '</span></div>';
    }
    h += '</div>';
  }

  // Section: Relationships
  if (relationships.length > 0) {
    h += '<div class="section"><div class="section-title section-title-only">Relationships (' + relationships.length + ')</div>';
    for (var i = 0; i < relationships.length; i++) {
      var r = relationships[i];
      h += '<div class="rel-row"><span class="rel-name">' + esc(r.name || '') + '</span>';
      h += '<span class="rel-type">' + esc(r.relationship_type || '') + '</span>';
      if (r.context) h += '<span class="rel-context">' + esc(r.context) + '</span>';
      h += '</div>';
    }
    h += '</div>';
  }

  document.getElementById('main').innerHTML = h;
}

function renderConnectedDetail(data) {
  var e = data.entity || {};
  var type = e.entity_type || '';
  var name = e.name?.full || e.name?.common || '';
  var parentId = e.parent_entity_id || '';
  var h = '';

  // Header
  h += '<div class="detail-header">';
  h += '<h2>' + esc(name) + '</h2>';
  h += '<span class="type-badge ' + type + '">' + type + '</span>';
  h += '<span class="entity-id-badge">' + esc(e.entity_id || '') + '</span>';
  h += '</div>';

  // Parent link
  if (parentId) {
    h += '<div class="section" style="padding:8px 0;">';
    h += '<span style="font-size:0.82rem;color:var(--text-muted);">Parent: </span>';
    h += '<a href="#" style="font-size:0.82rem;color:#6366f1;text-decoration:none;" onclick="event.preventDefault();selectEntity(' + "'" + esc(parentId) + "'" + ')">' + esc(parentId) + '</a>';
    h += '</div>';
  }

  // Type-specific data
  if (type === 'role' && data.role_data) {
    var rd = data.role_data;
    h += '<div class="section"><div class="section-title section-title-only">Role Details</div>';
    if (rd.title) h += '<div class="attr-row"><span class="attr-key">Title</span><span class="attr-value">' + esc(rd.title) + '</span></div>';
    if (rd.company) h += '<div class="attr-row"><span class="attr-key">Company</span><span class="attr-value">' + esc(rd.company) + '</span></div>';
    if (rd.start_date || rd.end_date) h += '<div class="attr-row"><span class="attr-key">Period</span><span class="attr-value">' + esc(rd.start_date || '?') + ' — ' + esc(rd.end_date || 'Present') + '</span></div>';
    if (rd.description) h += '<div style="margin-top:8px;font-size:0.82rem;color:var(--text-primary);line-height:1.5;">' + esc(rd.description) + '</div>';
    h += '</div>';
  }

  if (type === 'organization' && data.organization_data) {
    h += '<div class="section"><div class="section-title section-title-only">Organization Details</div>';
    h += '<div class="attr-row"><span class="attr-key">Name</span><span class="attr-value">' + esc(data.organization_data.name || name) + '</span></div>';
    h += '</div>';
  }

  if (type === 'credential' && data.credential_data) {
    var cd = data.credential_data;
    h += '<div class="section"><div class="section-title section-title-only">Credential Details</div>';
    if (cd.institution) h += '<div class="attr-row"><span class="attr-key">Institution</span><span class="attr-value">' + esc(cd.institution) + '</span></div>';
    if (cd.degree) h += '<div class="attr-row"><span class="attr-key">Degree</span><span class="attr-value">' + esc(cd.degree) + '</span></div>';
    if (cd.field) h += '<div class="attr-row"><span class="attr-key">Field</span><span class="attr-value">' + esc(cd.field) + '</span></div>';
    if (cd.start_year || cd.end_year) h += '<div class="attr-row"><span class="attr-key">Years</span><span class="attr-value">' + esc(cd.start_year || '?') + ' — ' + esc(cd.end_year || '?') + '</span></div>';
    h += '</div>';
  }

  if (type === 'skill' && data.skill_data) {
    h += '<div class="section"><div class="section-title section-title-only">Skill Details</div>';
    h += '<div class="attr-row"><span class="attr-key">Skill</span><span class="attr-value">' + esc(data.skill_data.name || name) + '</span></div>';
    h += '</div>';
  }

  // Summary if present
  var summary = e.summary?.value || '';
  if (summary) {
    h += '<div class="section"><div class="section-title section-title-only">Summary</div>';
    h += '<div class="summary-text">' + esc(summary) + '</div></div>';
  }

  document.getElementById('main').innerHTML = h;
}

/* --- Actions --- */
function toggleSummaryEdit() {
  var d = document.getElementById('summaryDisplay');
  var e = document.getElementById('summaryEditSection');
  if (e.style.display === 'none') {
    e.style.display = 'block'; d.style.display = 'none';
  } else {
    e.style.display = 'none'; d.style.display = 'block';
  }
}

function saveSummary() {
  var val = document.getElementById('summaryEdit').value;
  api('PATCH', '/api/entity/' + selectedId, { summary: val }).then(function() {
    toast('Summary updated');
    selectEntity(selectedId);
  }).catch(function(err) { toast('Error: ' + err.message); });
}

function addObs() {
  var text = document.getElementById('obsText').value.trim();
  if (!text) return;
  document.getElementById('btnAddObs').disabled = true;
  api('POST', '/api/observe', {
    entity_id: selectedId,
    observation: text,
    confidence_label: document.getElementById('obsConfidence').value,
    facts_layer: document.getElementById('obsLayer').value,
  }).then(function() {
    toast('Observation added');
    selectEntity(selectedId);
  }).catch(function(err) {
    toast('Error: ' + err.message);
    document.getElementById('btnAddObs').disabled = false;
  });
}

function deleteObs(obsId) {
  if (!obsId || !confirm('Delete this observation?')) return;
  api('DELETE', '/api/observe/' + obsId).then(function() {
    toast('Observation deleted');
    selectEntity(selectedId);
  }).catch(function(err) { toast('Error: ' + err.message); });
}

// --- Share functions ---

function openShareModal() {
  if (!selectedId) return;
  api('GET', '/api/shares/' + selectedId).then(function(shares) {
    showShareModal(shares);
  }).catch(function() {
    showShareModal([]);
  });
}

function showShareModal(existingShares) {
  var overlay = document.createElement('div');
  overlay.className = 'share-overlay';
  overlay.id = 'shareOverlay';
  overlay.onclick = function(e) { if (e.target === overlay) closeShareModal(); };

  var sections = [
    { id: 'summary', label: 'Summary', defaultOn: true },
    { id: 'experience', label: 'Experience', defaultOn: true },
    { id: 'education', label: 'Education', defaultOn: true },
    { id: 'skills', label: 'Skills', defaultOn: true },
    { id: 'connections', label: 'Connections', defaultOn: false },
  ];

  var togglesHtml = '<div class="share-section-toggles">';
  for (var i = 0; i < sections.length; i++) {
    var s = sections[i];
    togglesHtml += '<div class="share-toggle-row">' +
      '<label for="share-sec-' + s.id + '">' + esc(s.label) + '</label>' +
      '<input type="checkbox" id="share-sec-' + s.id + '" ' + (s.defaultOn ? 'checked' : '') + '>' +
      '</div>';
  }
  togglesHtml += '</div>';

  var expiryHtml = '<div class="share-expiry-row">' +
    '<label>Expires in</label>' +
    '<select id="shareExpiry">' +
    '<option value="7">7 days</option>' +
    '<option value="30" selected>30 days</option>' +
    '<option value="90">90 days</option>' +
    '<option value="365">1 year</option>' +
    '</select></div>';

  var activeHtml = '';
  if (existingShares.length > 0) {
    activeHtml = '<div class="share-active-list"><h4>Active Links</h4>';
    for (var i = 0; i < existingShares.length; i++) {
      var sh = existingShares[i];
      var expDate = new Date(sh.expiresAt).toLocaleDateString();
      activeHtml += '<div class="share-active-item">' +
        '<div><div class="share-active-info">Expires ' + esc(expDate) + '</div>' +
        '<div class="share-active-sections">' + esc(sh.sections.join(', ')) + '</div></div>' +
        '<button class="btn-revoke" onclick="revokeShare(' + "'" + sh.shareId + "'" + ')">Revoke</button>' +
        '</div>';
    }
    activeHtml += '</div>';
  }

  var html = '<div class="share-modal">' +
    '<h3>Share Profile</h3>' +
    togglesHtml +
    expiryHtml +
    '<div class="share-actions">' +
    '<button class="btn-cancel" onclick="closeShareModal()">Cancel</button>' +
    '<button class="btn-generate" onclick="generateShareLink()">Generate Link</button>' +
    '</div>' +
    '<div id="shareResult"></div>' +
    activeHtml +
    '</div>';

  overlay.innerHTML = html;
  document.body.appendChild(overlay);
}

function closeShareModal() {
  var overlay = document.getElementById('shareOverlay');
  if (overlay) overlay.remove();
}

function generateShareLink() {
  var sections = [];
  var ids = ['summary', 'experience', 'education', 'skills', 'connections'];
  for (var i = 0; i < ids.length; i++) {
    var cb = document.getElementById('share-sec-' + ids[i]);
    if (cb && cb.checked) sections.push(ids[i]);
  }
  var expiry = document.getElementById('shareExpiry');
  var days = expiry ? parseInt(expiry.value) : 30;

  api('POST', '/api/share', {
    entityId: selectedId,
    sections: sections,
    expiresInDays: days
  }).then(function(data) {
    var resultDiv = document.getElementById('shareResult');
    if (resultDiv) {
      resultDiv.innerHTML = '<div class="share-result">' +
        '<div class="share-result-url">' + esc(data.shareUrl) + '</div>' +
        '<button class="btn-copy-link" onclick="copyShareLink(' + "'" + data.shareUrl.replace(/'/g, "\\\\'") + "'" + ')">Copy Link</button>' +
        '</div>';
    }
  }).catch(function(err) {
    toast('Error creating share: ' + err.message);
  });
}

function copyShareLink(url) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(url).then(function() {
      toast('Link copied to clipboard');
    }).catch(function() {
      fallbackCopy(url);
    });
  } else {
    fallbackCopy(url);
  }
}

function fallbackCopy(text) {
  var ta = document.createElement('textarea');
  ta.value = text;
  ta.style.position = 'fixed';
  ta.style.left = '-9999px';
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand('copy'); toast('Link copied to clipboard'); }
  catch(e) { toast('Copy failed — select the URL manually'); }
  document.body.removeChild(ta);
}

function revokeShare(shareId) {
  if (!confirm('Revoke this share link? Anyone with this link will no longer be able to view the profile.')) return;
  api('DELETE', '/api/share/' + shareId).then(function() {
    toast('Share link revoked');
    closeShareModal();
    openShareModal();
  }).catch(function(err) {
    toast('Error revoking share: ' + err.message);
  });
}
</script>
</body>
</html>`;

// ==========================================================================
// MECE-014: Remote MCP Endpoint (Streamable HTTP Transport)
// Enables claude.ai Custom Connectors: Settings → Connectors → Add
// Same 3 tools as the DXT package, running server-side over HTTP.
// ==========================================================================

const MCP_PROTOCOL_VERSION = '2024-11-05';
const MCP_SERVER_INFO = { name: 'context-engine', version: '1.0.0' };

// --- MCP Tool Definitions (same as dxt/server/index.js) ---

const MCP_TOOLS = [
  {
    name: 'build_graph',
    description: 'Build or rebuild the knowledge graph from files. Use this tool when the user uploads documents, shares files, or asks you to process, ingest, analyze, or extract information from any content into their knowledge graph. Extracts entities (people, organizations, concepts, businesses) and their relationships from all provided content. This is how new information enters the user\'s personal knowledge system. Accepts any file format — JSON, PDF, text, LinkedIn exports, chat logs, resumes, contracts, tax documents, corporate filings. After building, the user can query their graph using the query tool.',
    inputSchema: {
      type: 'object',
      properties: {
        files: {
          type: 'array',
          description: 'Array of {filename, content} objects to process',
          items: {
            type: 'object',
            properties: {
              filename: { type: 'string', description: 'Name of the file including extension' },
              content: { type: 'string', description: 'Full text content of the file' }
            },
            required: ['filename', 'content']
          }
        },
        set_self_entity: {
          type: 'string',
          description: 'Optional. Name of the primary person this graph is about.'
        },
        spoke: {
          type: 'string',
          description: 'Optional spoke ID to ingest into. Use this when ingesting files for a specific client, project, or matter. If omitted, entities go into the default spoke.'
        }
      },
      required: ['files']
    }
  },
  {
    name: 'sync',
    description: 'Trigger a connector sync to pull data from an external system (like ShareFile) into the knowledge graph. Use this tool when the user asks to sync, refresh, or pull data from a connected service. Returns sync progress including folders synced, files processed, and entities staged for review.',
    inputSchema: {
      type: 'object',
      properties: {
        connection_id: {
          type: 'string',
          description: 'The connection ID to sync. Get available connections from the query tool by asking "what connections do I have?"'
        },
        folder_ids: {
          type: 'array',
          description: 'Optional. Specific folder IDs to sync. If omitted, syncs all mapped folders.',
          items: { type: 'string' }
        }
      },
      required: ['connection_id']
    }
  },
  {
    name: 'query',
    description: "ALWAYS use this tool FIRST when the user asks about people, relationships, organizations, companies, professional history, personal context, family, friends, colleagues, or any 'who is' / 'what do you know about' / 'tell me about' question regarding anyone in their life or network. This is the user's personal knowledge graph — the authoritative source for all personal and professional context. Use this tool BEFORE answering from your own knowledge for any question that could involve people the user knows, their work history, their relationships, or their professional network. Supports: entity lookup ('Who is Steve?'), relationship traversal ('How does X connect to Y?'), aggregation ('How many people work at Amazon?'), completeness checks ('What am I missing about the Johnson LLC filing?'), and contradiction detection ('Any conflicts in this data?'). If the user asks about a person by first name only, ALWAYS check this tool first — they are almost certainly referring to someone in their personal graph, not a public figure.",
    inputSchema: {
      type: 'object',
      properties: {
        question: { type: 'string', description: 'Natural language question about entities, relationships, or the knowledge graph' },
        spoke: { type: 'string', description: 'Optional spoke ID or name to scope the query to a specific client, project, or matter. When provided, only entities in that spoke are searched.' }
      },
      required: ['question']
    }
  },
  {
    name: 'update',
    description: 'Add new facts, observations, or relationships to the knowledge graph in real time. Use this tool whenever the user mentions new information about a person, organization, or relationship during conversation — even casually. Examples: \'Steve just got promoted to VP\', \'I had lunch with Andre yesterday\', \'Johnson LLC filed their K-1\', \'Lola started a new project.\' This keeps the knowledge graph current without requiring the user to formally upload documents. Write-back should happen naturally as context emerges in conversation. If the user corrects something (\'Actually Steve works at Google, not Amazon\'), update the entity immediately.',
    inputSchema: {
      type: 'object',
      properties: {
        entity_name: { type: 'string', description: 'Entity to update or create' },
        entity_type: { type: 'string', enum: ['person', 'business', 'institution'], description: 'Type of entity (person, business, or institution)' },
        observations: {
          type: 'array',
          description: 'New facts about this entity',
          items: {
            type: 'object',
            properties: {
              attribute: { type: 'string', description: 'What this fact is about (e.g., role, location, education)' },
              value: { type: 'string', description: 'The fact itself' },
              confidence: { type: 'number', description: 'How confident (0-1). Use 0.9 for stated facts, 0.6 for inferred.' }
            },
            required: ['attribute', 'value']
          }
        },
        relationships: {
          type: 'array',
          description: 'New relationships to add',
          items: {
            type: 'object',
            properties: {
              target_name: { type: 'string', description: 'Name of the related entity' },
              relationship: { type: 'string', description: 'Type of relationship (e.g., works_at, friend_of, created)' },
              context: { type: 'string', description: 'Context for this relationship' }
            },
            required: ['target_name', 'relationship']
          }
        }
      },
      required: ['entity_name']
    }
  },
  {
    name: 'analyze_gaps',
    description: 'Analyze completeness of a client matter against a legal template. Shows missing documents, incomplete entity fields, and missing relationships. Use when user asks "what\'s missing?" or "how complete is this matter?"',
    inputSchema: {
      type: 'object',
      properties: {
        spoke: { type: 'string', description: 'Spoke ID or name to analyze' },
        template: { type: 'string', description: 'Optional matter type override (e.g. estate_planning, corporate_formation, tax_preparation, personal_injury, general)' },
        refresh: { type: 'boolean', description: 'Force fresh analysis instead of using cached results' }
      },
      required: ['spoke']
    }
  },
  {
    name: 'get_provenance',
    description: 'Get the source attribution for any fact about an entity. Shows which file, what text, and where in the document each piece of information was extracted from. Use when the user asks "where did that come from?" or "show me the source" or wants to verify any fact.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Entity name or ID' },
        field: { type: 'string', description: 'Optional specific field to check provenance for' }
      },
      required: ['entity']
    }
  },
  {
    name: 'export_spoke',
    description: 'Export all extracted data from a client spoke as a structured table with source attribution. Returns a natural language summary showing which required fields are verified, missing, or conflicting. Use when the user asks to "export", "show all data", "give me a spreadsheet", or wants a complete overview of what has been extracted for a client matter.',
    inputSchema: {
      type: 'object',
      properties: {
        spoke: { type: 'string', description: 'Spoke ID or name to export' }
      },
      required: ['spoke']
    }
  }
];

// --- MCP Tool Handlers (server-side, calls internal functions directly) ---

async function mcpBuildGraph(args, graphDir) {
  const { files, set_self_entity, spoke } = args || {};
  const spokeId = spoke || 'default';
  if (!files || !Array.isArray(files)) throw new Error('files array is required');

  const results = [];
  for (const file of files) {
    try {
      const content = file.content || '';
      const buf = Buffer.from(content, content.match(/^[A-Za-z0-9+/=\s]+$/) ? 'base64' : 'utf-8');
      const parsed = await universalParse(buf, file.filename);
      const entities = (parsed.entities || []).map(ent => {
        const eType = (ent.type || 'PERSON').toLowerCase();
        const mapped = eType === 'org' ? 'business' : eType === 'concept' ? 'business' : (eType === 'person' ? 'person' : 'business');
        const nameObj = mapped === 'person'
          ? { full: ent.name, preferred: (ent.name || '').split(/\s+/)[0], confidence: ent.confidence || 0.8, facts_layer: 1 }
          : { common: ent.name, confidence: ent.confidence || 0.8, facts_layer: 1 };
        const attrs = [];
        if (ent.attributes) {
          let seq = 1;
          for (const [key, value] of Object.entries(ent.attributes)) {
            attrs.push({ attribute_id: `ATTR-${String(seq++).padStart(3, '0')}`, key, value: String(value), confidence: ent.confidence || 0.7 });
          }
        }
        return {
          schema_version: '2.0', schema_type: 'context_architecture_entity',
          extraction_metadata: { extracted_at: new Date().toISOString(), source_description: `MCP build_graph: ${file.filename}`, extraction_model: 'universal-parser', extraction_confidence: ent.confidence || 0.7, schema_version: '2.0' },
          entity: { entity_type: mapped, name: nameObj, summary: { value: ent.evidence || '', confidence: ent.confidence || 0.5, facts_layer: 2 } },
          attributes: attrs, relationships: [], values: [], key_facts: [], constraints: [], observations: [],
          ownership: 'referenced', access_rules: { visibility: 'private', shared_with: [] }, projection_config: { lenses: ['default'] }, perspectives: [],
          spoke_id: spokeId, source: 'manual', source_ref: file.filename
        };
      });
      if (entities.length > 0) {
        const staged = stageAndScoreExtraction(entities, { type: 'file', url: '', description: `MCP build_graph: ${file.filename}` }, graphDir);
        results.push({ filename: file.filename, entities_staged: staged.length });
      } else {
        results.push({ filename: file.filename, entities_staged: 0 });
      }
    } catch (err) {
      results.push({ filename: file.filename, error: err.message });
    }
  }

  if (set_self_entity) {
    const { similarity } = require('./merge-engine');
    const allEnts = listEntities(graphDir);
    let bestMatch = null, bestScore = 0;
    for (const { data } of allEnts) {
      const e = data.entity || {};
      const eName = e.name?.full || e.name?.common || e.name?.preferred || '';
      const score = similarity(set_self_entity, eName);
      if (score > bestScore) { bestScore = score; bestMatch = { id: e.entity_id, name: eName }; }
    }
    if (bestMatch && bestScore > 0.6) {
      const selfPath = path.join(graphDir, 'self-entity.json');
      fs.writeFileSync(selfPath, JSON.stringify({ self_entity_id: bestMatch.id, self_entity_name: bestMatch.name, purpose: 'Primary user knowledge graph' }, null, 2));
      clearSelfEntityCache(graphDir);
      const selfData = readEntity(bestMatch.id, graphDir);
      if (selfData) { selfData.ownership = 'self'; writeEntity(bestMatch.id, selfData, graphDir); }
    }
  }

  const totalEntities = listEntities(graphDir).length;
  return {
    files_processed: files.length,
    file_results: results,
    total_entities: totalEntities,
    self_entity: set_self_entity || null,
    message: `Processed ${files.length} files. ${totalEntities} entities in graph.`
  };
}

async function mcpQuery(args, graphDir) {
  const { question, spoke } = args || {};
  if (!question) throw new Error('question is required');

  let queryOpts = null;
  if (spoke) {
    // Resolve spoke by ID or name
    const spokeObj = getSpoke(graphDir, spoke);
    if (spokeObj) {
      queryOpts = { spokeId: spokeObj.id, spokeName: spokeObj.name, centeredEntityName: spokeObj.centered_entity_name };
    } else {
      // Try by name
      const spokes = loadSpokes(graphDir);
      const byName = Object.values(spokes).find(s => s.name.toLowerCase() === spoke.toLowerCase());
      if (byName) {
        queryOpts = { spokeId: byName.id, spokeName: byName.name, centeredEntityName: byName.centered_entity_name };
      }
    }
  }

  const response = await queryEngine(question, graphDir, queryOpts);
  return {
    answer: response.answer,
    query_type: response.query?.type,
    spoke_id: response.query?.spoke_id || null,
    entities: response.entities || [],
    paths: response.paths || [],
    gaps: response.gaps || [],
    conflicts: response.conflicts || [],
    confidence: response.confidence,
    timing_ms: response.timing?.total_ms
  };
}

async function mcpUpdate(args, graphDir) {
  const { entity_name, entity_type, observations, relationships } = args || {};
  if (!entity_name) throw new Error('entity_name is required');

  const { similarity } = require('./merge-engine');
  const allEnts = listEntities(graphDir);

  // Find existing entity by name
  let entityId = null;
  let bestScore = 0;
  for (const { data } of allEnts) {
    const e = data.entity || {};
    const eName = e.name?.full || e.name?.common || e.name?.preferred || '';
    const score = similarity(entity_name, eName);
    if (score > bestScore) { bestScore = score; entityId = e.entity_id; }
  }
  if (bestScore < 0.7) entityId = null;

  // Create if not found
  if (!entityId) {
    const eType = entity_type || 'person';
    const nameParts = entity_name.trim().split(/\s+/);
    let initials;
    if (eType === 'person') initials = nameParts.map(w => w[0]).join('').toUpperCase();
    else if (eType === 'institution') initials = 'INST-' + nameParts.map(w => w[0]).join('').toUpperCase();
    else initials = 'BIZ-' + nameParts.map(w => w[0]).join('').toUpperCase();
    const seq = getNextCounter(graphDir, eType);
    entityId = `ENT-${initials}-${String(seq).padStart(3, '0')}`;
    const now = new Date().toISOString();
    const nameObj = eType === 'person' ? { full: entity_name, preferred: nameParts[0], confidence: 0.9, facts_layer: 1 } : { common: entity_name, confidence: 0.9, facts_layer: 1 };
    const entityData = {
      schema_version: '2.0', schema_type: 'context_architecture_entity',
      extraction_metadata: { extracted_at: now, updated_at: now, source_description: 'MCP update tool', extraction_model: 'conversation', extraction_confidence: 0.8, schema_version: '2.0' },
      entity: { entity_type: eType, entity_id: entityId, name: nameObj, summary: { value: '', confidence: 0, facts_layer: 2 } },
      attributes: [], relationships: [], values: [], key_facts: [], constraints: [], observations: [],
      ownership: 'owned', access_rules: { visibility: 'private', shared_with: [] }, projection_config: { lenses: ['default'] }, perspectives: [],
      provenance_chain: { created_at: now, created_by: 'mcp-update', source_documents: [{ source: 'conversation', ingested_at: now }], merge_history: [] }
    };
    writeEntity(entityId, entityData, graphDir);
  }

  let obsAdded = 0, relsAdded = 0;

  // Add observations
  if (observations && observations.length > 0) {
    const entity = readEntity(entityId, graphDir);
    if (entity) {
      if (!entity.observations) entity.observations = [];
      const now = new Date().toISOString();
      for (const obs of observations) {
        const seq = String(entity.observations.length + 1).padStart(3, '0');
        const tsCompact = now.replace(/[-:T]/g, '').slice(0, 14);
        entity.observations.push({
          observation_id: `OBS-${entityId}-${tsCompact}-${seq}`,
          observation: `${obs.attribute}: ${obs.value}`,
          confidence: obs.confidence || 0.8,
          confidence_label: (obs.confidence || 0.8) >= 0.8 ? 'STRONG' : 'MODERATE',
          facts_layer: 'L1_OBJECTIVE', layer_number: 1,
          truth_level: 'INFERRED',
          observed_at: now, observed_by: 'mcp-update', source: 'conversation'
        });
        obsAdded++;
      }
      writeEntity(entityId, entity, graphDir);
    }
  }

  // Add relationships
  if (relationships && relationships.length > 0) {
    const entity = readEntity(entityId, graphDir);
    if (entity) {
      if (!entity.relationships) entity.relationships = [];
      for (const rel of relationships) {
        // Find target
        let targetId = null, targetName = rel.target_name;
        let tBest = 0;
        for (const { data } of allEnts) {
          const e = data.entity || {};
          const eName = e.name?.full || e.name?.common || e.name?.preferred || '';
          const score = similarity(rel.target_name, eName);
          if (score > tBest) { tBest = score; targetId = e.entity_id; targetName = eName; }
        }
        if (tBest < 0.7) {
          // Create target
          const tParts = rel.target_name.trim().split(/\s+/);
          const tInit = tParts.map(w => w[0]).join('').toUpperCase();
          const tSeq = getNextCounter(graphDir, 'person');
          targetId = `ENT-${tInit}-${String(tSeq).padStart(3, '0')}`;
          const now2 = new Date().toISOString();
          writeEntity(targetId, {
            schema_version: '2.0', schema_type: 'context_architecture_entity',
            extraction_metadata: { extracted_at: now2, updated_at: now2, source_description: 'MCP update (relationship target)', extraction_model: 'conversation', extraction_confidence: 0.6, schema_version: '2.0' },
            entity: { entity_type: 'person', entity_id: targetId, name: { full: rel.target_name, preferred: tParts[0], confidence: 0.7, facts_layer: 1 }, summary: { value: '', confidence: 0, facts_layer: 2 } },
            attributes: [], relationships: [], values: [], key_facts: [], constraints: [], observations: [],
            ownership: 'referenced', access_rules: { visibility: 'private', shared_with: [] }, projection_config: { lenses: ['default'] }, perspectives: [],
            provenance_chain: { created_at: now2, created_by: 'mcp-update', source_documents: [], merge_history: [] }
          }, graphDir);
          targetName = rel.target_name;
        }
        const relSeq = String(entity.relationships.length + 1).padStart(3, '0');
        entity.relationships.push({
          relationship_id: `REL-${relSeq}`, name: targetName, entity_id: targetId,
          relationship_type: rel.relationship, context: rel.context || '',
          sentiment: 'neutral', confidence: 0.8, confidence_label: 'STRONG', source: 'conversation'
        });
        relsAdded++;
      }
      writeEntity(entityId, entity, graphDir);
    }
  }

  return {
    entity_id: entityId,
    entity_name,
    observations_added: obsAdded,
    relationships_added: relsAdded,
    message: `Updated ${entity_name}: +${obsAdded} observations, +${relsAdded} relationships.`
  };
}

async function mcpSync(args, graphDir) {
  const { connection_id, folder_ids } = args || {};
  if (!connection_id) throw new Error('connection_id is required');

  const conn = getConnection(graphDir, connection_id);
  if (!conn) throw new Error(`Connection not found: ${connection_id}`);

  const ConnectorClass = getConnectorClass(conn.provider);
  if (!ConnectorClass) throw new Error(`No connector for provider: ${conn.provider}`);

  const connector = new ConnectorClass(graphDir, conn.id);
  const events = [];
  const writeEvent = (event) => events.push(event);

  const results = await connector.sync({ folder_ids }, writeEvent);
  return {
    folders_synced: results.folders_synced,
    files_processed: results.files_processed,
    entities_staged: results.entities_staged,
    errors: results.errors || [],
    message: `Synced ${results.folders_synced} folders, processed ${results.files_processed} files, staged ${results.entities_staged} entities for review.`
  };
}

async function mcpAnalyzeGaps(args, graphDir) {
  const { spoke, template, refresh } = args || {};
  if (!spoke) throw new Error('spoke is required');

  // Resolve spoke by ID or name (same pattern as mcpQuery)
  let spokeObj = getSpoke(graphDir, spoke);
  if (!spokeObj) {
    const spokes = loadSpokes(graphDir);
    spokeObj = Object.values(spokes).find(s => s.name.toLowerCase() === spoke.toLowerCase());
  }
  if (!spokeObj) throw new Error(`Spoke not found: ${spoke}`);

  const templateType = template || spokeObj.template_type;
  if (!templateType) {
    const available = Object.keys(loadTemplates());
    throw new Error(`No template assigned to spoke "${spokeObj.name}". Assign one first or pass template parameter. Available: ${available.join(', ')}`);
  }

  // Check cache
  if (spokeObj.gap_analysis && !refresh) {
    const cached = spokeObj.gap_analysis;
    const spokeName = spokeObj.name || spoke;
    const pct = Math.round((cached.overall_score || 0) * 100);
    const missingDocs = (cached.missing_documents || []).slice(0, 3).map(d => d.item.replace(/_/g, ' ')).join(', ');
    const missingFields = (cached.missing_entity_fields || []).slice(0, 3).map(f => `${f.entity || f.role} needs ${f.missing.replace(/_/g, ' ')}`).join(', ');
    let msg = `${spokeName} is ${pct}% complete.`;
    if (missingDocs) msg += ` Missing: ${missingDocs}.`;
    if (missingFields) msg += ` ${missingFields}.`;
    return { ...cached, cached: true, message: msg };
  }

  const report = await analyzeGaps(spokeObj.id, graphDir, templateType);

  // Cache on spoke
  updateSpoke(graphDir, spokeObj.id, { gap_analysis: report, template_type: templateType });

  const pct = Math.round((report.overall_score || 0) * 100);
  const missingDocs = (report.missing_documents || []).slice(0, 3).map(d => d.item.replace(/_/g, ' ')).join(', ');
  const missingFields = (report.missing_entity_fields || []).slice(0, 3).map(f => `${f.entity || f.role} needs ${f.missing.replace(/_/g, ' ')}`).join(', ');
  let msg = `${spokeObj.name} is ${pct}% complete.`;
  if (missingDocs) msg += ` Missing: ${missingDocs}.`;
  if (missingFields) msg += ` ${missingFields}.`;

  return { ...report, message: msg };
}

async function mcpGetProvenance(args, graphDir) {
  const { entity: entityRef, field } = args || {};
  if (!entityRef) throw new Error('entity is required');

  // Resolve entity by name or ID
  const { similarity } = require('./merge-engine');
  const allEnts = listEntities(graphDir);
  let entityId = null;
  let entityData = null;
  let bestScore = 0;

  // Try direct ID match first
  for (const { id, data } of allEnts) {
    if (id === entityRef || (data.entity?.entity_id === entityRef)) {
      entityId = id;
      entityData = data;
      break;
    }
  }

  // If no direct ID match, fuzzy match on name
  if (!entityId) {
    for (const { id, data } of allEnts) {
      const e = data.entity || {};
      const eName = e.name?.full || e.name?.common || e.name?.preferred || '';
      const score = similarity(entityRef, eName);
      if (score > bestScore) { bestScore = score; entityId = id; entityData = data; }
    }
    if (bestScore < 0.5) throw new Error(`No entity found matching "${entityRef}"`);
  }

  const eName = entityData.entity?.name?.full || entityData.entity?.name?.common || entityId;
  const fields = buildProvenanceReport(entityData);

  // If specific field requested, filter
  if (field) {
    const fKey = field.toLowerCase();
    const fData = fields[fKey];
    if (!fData) return { entity_id: entityId, entity_name: eName, message: `No provenance found for "${field}".` };

    let msg = `The ${field} "${fData.value}" for ${eName}`;
    if (fData.sources.length > 0) {
      const s = fData.sources[0];
      msg += ` was extracted ${s.extraction_type === 'direct' ? 'directly' : s.extraction_type === 'ocr' ? 'via OCR' : 'by inference'} from ${s.filename}`;
      if (s.location) msg += `, ${s.location}`;
      if (s.snippet) msg += `: "${s.snippet}"`;
      if (fData.sources.length > 1) {
        msg += `. Also found in: ${fData.sources.slice(1).map(ss => ss.filename).join(', ')}`;
      }
    } else {
      msg += ' has no source provenance recorded.';
    }
    if (fData.conflict) msg += ' WARNING: Conflicting values detected from different sources.';
    return { entity_id: entityId, entity_name: eName, field, ...fData, message: msg };
  }

  // Full provenance report
  const summaryParts = [];
  for (const [key, fData] of Object.entries(fields)) {
    if (fData.sources.length > 0) {
      const s = fData.sources[0];
      let part = `${key}="${fData.value}" from ${s.filename}`;
      if (s.location) part += ` (${s.location})`;
      if (fData.conflict) part += ' [CONFLICT]';
      summaryParts.push(part);
    }
  }
  const message = summaryParts.length > 0
    ? `Provenance for ${eName}:\n${summaryParts.map(p => '- ' + p).join('\n')}`
    : `No provenance data recorded for ${eName}.`;

  return { entity_id: entityId, entity_name: eName, fields, message };
}

async function mcpExportSpoke(args, graphDir) {
  const { spoke } = args || {};
  if (!spoke) throw new Error('spoke is required');

  // Resolve spoke by ID or name
  let spokeObj = getSpoke(graphDir, spoke);
  if (!spokeObj) {
    const spokes = loadSpokes(graphDir);
    spokeObj = Object.values(spokes).find(s => s.name && s.name.toLowerCase() === spoke.toLowerCase());
  }
  if (!spokeObj) throw new Error(`Spoke not found: ${spoke}`);

  const templateType = spokeObj.template_type;
  if (!templateType) throw new Error(`No template assigned to spoke "${spokeObj.name}". Assign one first.`);

  const template = getTemplate(templateType);
  if (!template) throw new Error(`Template "${templateType}" not found`);

  const allEnts = listEntities(graphDir);
  const spokeEntities = allEnts
    .filter(e => e.data.spoke_id === spokeObj.id)
    .map(e => ({ ...e.data, _id: e.id }));

  // Build natural language summary
  const parts = [];
  let totalFields = 0, verifiedCount = 0;

  for (const role of (template.required_entities || [])) {
    const matched = _exportMatchEntityToRole(role, spokeEntities, spokeObj.name);
    const roleParts = [];

    if (matched.length === 0 && !role.optional) {
      for (const f of (role.required_fields || [])) {
        totalFields++;
        roleParts.push(f.replace(/_/g, ' ') + ' \u2717 (missing)');
      }
      parts.push(`${role.role.replace(/_/g, ' ')}: (no entity found) — ${roleParts.join(', ')}`);
    } else {
      for (const entity of matched) {
        const entityName = entity.entity?.name?.full || entity.entity?.name?.common || '(unknown)';
        const provReport = buildProvenanceReport(entity);
        const fieldParts = [];

        for (const fieldName of (role.required_fields || [])) {
          totalFields++;
          const fieldData = _exportFindField(provReport, entity, fieldName);
          if (fieldData && fieldData.value) {
            verifiedCount++;
            fieldParts.push(fieldName.replace(/_/g, ' ') + ' \u2713');
          } else {
            fieldParts.push(fieldName.replace(/_/g, ' ') + ' \u2717 (missing)');
          }
        }

        const roleLabel = role.role.replace(/_/g, ' ');
        parts.push(`${roleLabel}: ${entityName} — ${fieldParts.join(', ')}`);
      }
    }
  }

  const spokeName = spokeObj.name || spoke;
  const message = `${spokeName} export: ${verifiedCount} of ${totalFields} required fields verified.\n${parts.join('\n')}`;

  return {
    spoke_id: spokeObj.id,
    spoke_name: spokeName,
    template_type: templateType,
    total_fields: totalFields,
    verified: verifiedCount,
    missing: totalFields - verifiedCount,
    message
  };
}

const MCP_HANDLERS = {
  build_graph: mcpBuildGraph,
  query: mcpQuery,
  update: mcpUpdate,
  sync: mcpSync,
  analyze_gaps: mcpAnalyzeGaps,
  get_provenance: mcpGetProvenance,
  export_spoke: mcpExportSpoke
};

// --- JSON-RPC helpers ---

function jsonrpcSuccess(id, result) {
  return { jsonrpc: '2.0', id, result };
}

function jsonrpcError(id, code, message, data) {
  const err = { jsonrpc: '2.0', id, error: { code, message } };
  if (data !== undefined) err.error.data = data;
  return err;
}

// --- MCP Routes ---

// GET /.well-known/mcp.json — Auto-discovery manifest for claude.ai
app.get('/.well-known/mcp.json', (req, res) => {
  res.json({
    mcpb_version: '0.1',
    name: 'context-engine',
    version: '1.0.0',
    display_name: 'Context Engine',
    description: 'Knowledge graph superpowers for Claude. Extracts entities and relationships from your project files, then answers questions with multi-hop graph traversal.',
    author: { name: 'CJ Mitchell', url: 'https://github.com/flawlesstracks/context-engine' },
    endpoint: '/mcp',
    authentication: { type: 'none', note: 'Defaults to owner tenant. Optional X-Context-API-Key header for multi-tenant.' },
    tools: MCP_TOOLS.map(t => ({ name: t.name, description: t.description })),
    compatibility: { platforms: ['web', 'desktop'] }
  });
});

// GET /mcp — Server metadata + tool discovery
app.get('/mcp', (req, res) => {
  res.json({
    name: MCP_SERVER_INFO.name,
    version: MCP_SERVER_INFO.version,
    protocol_version: MCP_PROTOCOL_VERSION,
    capabilities: { tools: {} },
    tools: MCP_TOOLS
  });
});

// POST /mcp — MCP JSON-RPC endpoint (Streamable HTTP transport)
// Auth bypass: claude.ai Custom Connectors cannot send custom headers.
// If X-Context-API-Key is present, use apiAuth normally.
// If absent, default to tenant eefc79c7 (CJ's tenant).
app.post('/mcp', async (req, res) => {
  const key = req.headers['x-context-api-key'];
  if (key) {
    // Run through normal apiAuth
    return apiAuth(req, res, () => handleMcpRequest(req, res));
  }
  // Default tenant fallback for unauthenticated MCP (claude.ai Custom Connectors)
  const defaultTenantId = 'eefc79c7';
  const tenantDir = path.join(GRAPH_DIR, `tenant-${defaultTenantId}`);
  if (!fs.existsSync(tenantDir)) fs.mkdirSync(tenantDir, { recursive: true });
  req.agentId = 'claude-ai-connector';
  req.graphDir = tenantDir;
  req.isAdmin = false;
  req.tenantId = defaultTenantId;
  return handleMcpRequest(req, res);
});

async function handleMcpRequest(req, res) {
  const body = req.body;

  // Validate JSON-RPC envelope
  if (!body || body.jsonrpc !== '2.0') {
    return res.status(400).json(jsonrpcError(body?.id || null, -32600, 'Invalid JSON-RPC: missing jsonrpc: "2.0"'));
  }

  const { id, method, params } = body;

  try {
    // --- initialize ---
    if (method === 'initialize') {
      return res.json(jsonrpcSuccess(id, {
        protocolVersion: MCP_PROTOCOL_VERSION,
        capabilities: { tools: {} },
        serverInfo: MCP_SERVER_INFO
      }));
    }

    // --- ping ---
    if (method === 'ping') {
      return res.json(jsonrpcSuccess(id, {}));
    }

    // --- notifications/initialized (client notification, no response needed) ---
    if (method === 'notifications/initialized') {
      return res.json(jsonrpcSuccess(id, {}));
    }

    // --- tools/list ---
    if (method === 'tools/list') {
      return res.json(jsonrpcSuccess(id, { tools: MCP_TOOLS }));
    }

    // --- tools/call ---
    if (method === 'tools/call') {
      const toolName = params?.name;
      const toolArgs = params?.arguments || {};
      const handler = MCP_HANDLERS[toolName];

      if (!handler) {
        return res.json(jsonrpcError(id, -32602, `Unknown tool: ${toolName}`));
      }

      try {
        const result = await handler(toolArgs, req.graphDir);
        return res.json(jsonrpcSuccess(id, {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
        }));
      } catch (toolErr) {
        return res.json(jsonrpcSuccess(id, {
          content: [{ type: 'text', text: JSON.stringify({ error: toolErr.message }) }],
          isError: true
        }));
      }
    }

    // --- Unknown method ---
    return res.json(jsonrpcError(id, -32601, `Method not found: ${method}`));

  } catch (err) {
    console.error('MCP endpoint error:', err);
    return res.json(jsonrpcError(id, -32603, err.message || 'Internal error'));
  }
}

// --- Start server ---

const PORT = process.env.PORT || 3000;

// --- Spoke Migration (runs once on startup) ---
// Ensures all tenant directories have spokes.json and entities have spoke_id
try {
  const tenantDirs = fs.readdirSync(GRAPH_DIR).filter(d => d.startsWith('tenant-') && fs.statSync(path.join(GRAPH_DIR, d)).isDirectory());
  for (const dir of tenantDirs) {
    const tenantPath = path.join(GRAPH_DIR, dir);
    const spokesPath = path.join(tenantPath, 'spokes.json');
    if (!fs.existsSync(spokesPath)) {
      const migrated = migrateEntitiesToSpokes(tenantPath);
      loadSpokes(tenantPath); // bootstrap default spoke
      if (migrated > 0) console.log(`  Spoke migration: ${dir} — ${migrated} entities updated`);
    }
  }
} catch (err) {
  console.error('Spoke migration warning:', err.message);
}

app.listen(PORT, () => {
  console.log('');
  console.log('  Context Engine - Web Demo + API');
  console.log('  ──────────────────────────────');
  console.log('  UI:     http://localhost:' + PORT);
  console.log('  Wiki:   http://localhost:' + PORT + '/wiki');
  console.log('  Import: http://localhost:' + PORT + '/ingest');
  console.log('  API:    http://localhost:' + PORT + '/api/graph/stats');
  console.log('  Share:  http://localhost:' + PORT + '/shared/:shareId');
  console.log('  Auth:   http://localhost:' + PORT + '/auth/google' + (process.env.GOOGLE_CLIENT_ID ? '' : ' (not configured)'));
  console.log('  Graph:  ' + GRAPH_DIR + (GRAPH_IS_PERSISTENT ? ' (persistent disk)' : ' (local)'));
  console.log('  Spokes: Heliocentric Hub-Spoke v1 (MECE-015)');
  console.log('');
});
